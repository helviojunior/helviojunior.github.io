<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Este artigo objetiva demonstrar os conceitos iniciais de criptográfica com chave assimétrica e certificação digital. 1.     O que é criptografia? A criptografia é o processo pelo qual se transforma dados legíveis em algo sem sentido (ilegível), porém sendo capaz de recuperar os dados originais a partir dessas dados sem sentido. A criptografia é uma das ferramentas mais importantes para a proteção dos dados, sejam eles em trânsito ou armazenado. Mas vale a pena ressaltar que a criptografia não é à prova de falhas e toda criptografia pode ser quebrada e, sobretudo, se for implementada incorretamente, ela não agrega nenhuma segurança real. Porque a chave é necessária? Toda criptografia computadorizada opera com chaves, pois manter o algoritmo criptográfico em segredo é algo inviável, sendo assim para proteger os dados basta utilizar um algoritmo de criptografia forte e proteger a chave utilizada. Isso significa também que pode ser utilizado chaves diferentes para proteger diferentes informações, sendo assim, se alguém quebrar uma das chaves, as outras informações ainda estarão seguras. 2.     Criptografia de chave simétrica Nesta abordagem, um algoritmo utiliza uma chave para converter as informações naquilo que se parece com bits aleatórios. Assim, o mesmo algoritmo utiliza a mesma chave para recuperar os dados originais. Esta metodologia tem desempenho bem melhores em se comparado com a criptografia de chave assimétrica, porém como para recuperar os dados cifrados, você também necessita das mesmas chaves que foram utilizadas para cifrar os dados é necessário um bom gerenciamento dessas chaves. Em se tratando de comunicação de via rede este problema da gestão da chave é mais evidente, pois para que dois ativos possam se comunicar os dois necessita conhecer a mesma chave, desta forma tem-se um problema: ou os dois ativos detêm a chave antes do início da comunicação ou a chave necessita ser transmitida via rede sem criptografia. Segue abaixo a imagem ilustrando a utilização do mesmo algoritmo e chave para cifrar a decifrar a mensagem. 3.     Criptografia de chave assimétrica Este esquema utiliza duas chaves diferentes. Mesmo estando relacionadas entre si – elas são parceiras – elas são significativamente diferentes. O relacionamento é matemático; o que uma chave encripta a outra chave decripta. Na criptografia simétrica, a mesma chave é utilizada para encriptar e decriptar (daí a palavra “simétrica” – partes correspondentes); se utilizar outra chave qualquer para decriptar, o resultado será algo sem sentido. Mas com a criptografia assimétrica (conforme imagem abaixo), a chave que é utilizada para encriptar os dados não é utilizada para decriptá-los; apenas a parte correspondente pode (daí palavra “assimétrica” – partes não-correspondentes). Em outras palavras, a chave privada deve permanecer em segredo, enquanto a chave pública pode ser publicada sem qualquer perigo. Neste exemplo é utilizada a chave publica para criptografar os dados, porém somente a chave privada pode decriptografar.   Quando utilizado o algoritmo RSA, qualquer coisa que tenha sido encriptado com a chave pública pode ser decifrado apenas com a chave privada. Bem como qualquer coisa que tenha sido enncriptado com a chave privada pode ser decrifrado apenas com a chave pública. Isto demonstra que o RSA funciona tanto do privado ao público, como do público ao privado. 4.     Assinatura digital Quando se utiliza a chave privada para criptografar os dados, apenas a chave pública pode ser utilizada para decriptografar os dados. Este processo não fornece segurança uma vez que que a chave pública, conceitualmente pode ser conhecida por todos, então para que serve este processo? Para assinatura digital. Pois como somente o proprietário da chave privada pode gerar a informação criptografada, ao descriptografar com a chave pública tem-se a garantia de que o dado criptografado veio de quem diz ser. Desta forma as assinaturas digitais detém duas suposições fundamentais: primeiro, que a chave privada seja segura e que apenas o proprietário da chave tenha acesso a ela e, segundo, que a única maneira de produzir uma assinatura digital seja utilizando a chave privada. A Assinatura digital resolve duas questões relacionadas à criptografia: autenticação e não repúdio. A autenticação permite que alguém no mundo eletrônico confirme dados e identidade, e o não repúdio impede que pessoas retifiquem sua palavra eletrônica. A forma mais comum de assinatura digital conhecida é o certificado digital. Um certificado digital associa um nome a uma chave pública. O certificado digital é produzido de tal maneira que o torna perceptível se um impostor pegou o certificado existente e substituiu a chave pública ou o nome. 5. Hash Hash, ou resumo da mensagem é um algoritmo que recebe qualquer comprimento de entrada (de dados/mensagem) e mescla a entrada para produzir uma saída pseudoaleatória de largura fixa.  Hash detém algumas propriedades: Propriedade 1: Um mesmo algoritmo de hash sempre condensará (reduzir, resumir) o conteúda da entrada de dados em uma saída de tamanho fixo independentemente do tamanho, e do que, for fornecido como entrada; Propriedade 2: A saída de um algoritmo de hash é pseudoaleatória por diversas questões e princípios matemáticos; Propriedade 3: Mesmo que os dados de entrada seja quase idêntico (mudando apenas 1 bit, por exemplo), o a saída será dramaticamente diferente; Propriedade 4: Não pode reconstruir a mensagem de entrada (mensagem original) a partir de uma saída hash, este princípio é conhecido como função de uma única via; Propriedade 5: Um bom algoritmo de hash não são tão fáceis de examinar; Propriedade 6: Não é possível localizar uma mensagem que produza um hash em particular; Propriedade 7: Um bom algoritmo de hash não pode encontrar duas mensagens que produzam uma mesma saída; Hash e Colisões Até o momento da escrita deste post não existe nenhum algoritmo capaz de satisfazer as propriedades 6 e 7 de forma perfeita,  então quando um algoritmo de hash viola as duas ultimas propriedades, o resultado é uma colisão, o termo técnico para descrever uma situação em que duas mensagens produzem um mesmo hash. Segue abaixo uma tabela com as informações dos principais hashes utilizados atualmente: Diferença principal entre Criptografia e Hash Este é um tema controverso, dependendo da literatura que se adota, sendo assim para este estudo vamos entender de forma geral como sendo: Criptografia: Reversível; Hash: Não reversível; 6.     Infraestrutura de chave pública e o padrão X.509 Um certificado de chave pública (public-key certificate – PKC) é um conjunto de dados à prova de falsificação que atesta a associação de uma chave pública a um usuário final. Para fornecer essa associação, um conjunto de terceiros confiáveis confirma a identidade do usuário. Os terceiros chamados de autoridades certificadoras (certification authorities – Cas), emitem certificados para o usuário com o nome de usuário, a chave pública e outras informações que o identifiquem. Após serem assinados digitalmente pela CA, esses certificados podem ser transferidos e armazenados. O formato de certificado mais amplamente aceito é o X.509 Versão 3. Em 1999 foi publicado um perfil para o X.509 na RFC2459. Todas as versões dos certificados X.509 contêm os seguintes campos: Campo Descrição Version (Versão) Este campo deferência as sucessivas versões do certificado, como Versão 1, Versão 2 e Versão 3. O campo Versão também permite possíveis versões futuras. Certificate Serial Number (Número serial de certificado) Esse campo contém um valor de inteiro único em cada certificado. É gerado pela CA. Signature Algorithm Identifier (Identificador do algoritmo de assinatura) Este campo indica o identificador do algoritmo utilizado para assinar o certificado junto com quaisquer parâmetros associados. Issue Name (Nome do emissor) Esse campo identifica o nome distinto (distinguished name – DN) com o qual a CA cria e assina esse certificado. Validity (Not before/After) (Validade – Não antes/Não depois) Esse campo conte´m dois valores de data/hora – Not Valid Before e Not Valid After – que definem o período que esse certificado pode ser considerado válido a menos que, caso, contrário, seja revogado. Subject Name (Nome do sujeito) Esse campo identifica o DN da entidade final a que o certificado se refere, isto é, o sujeito que mantém a chave privada correspondente. Esse campo deve ter uma entrada, a menos que um nome alternativo seja utilizado nas extensões da Versão 3. Subject Public Key Information (Informação sobre a chave pública do sujeito) Esse campo contém o valor da chave pública so sijeito, bem como o identificador de algoritmo e quaisquer parâmetros associados ao algoritmo pelos quais a chave deve ser utilizada. Esse campo sempre deve ter uma entrada. Os certificados versões 2 e 3 podem conter outros campos com: Issue Unique Identifier (identificador único de emissor) Subject Unique Identifier (Identificador único de sujeito) Extensions (Extensões) (Somente versão 3) Authority Key Identifier (Identificador de chave de autoridade) Subject Key Identifier (Identificador de chave de sujeito) Key Usage (Utilização de chave) Extened Key Usage (Utilização de chave estendida) CRL Distribution Point (Ponto de distribuição de CRL) Private Key Usage Period (Período de uso de chave privada) Certificate Policies (Políticas de certificado) Policy Mapping (Mapeamento de políticas) Subject Alternate Name (Nome alternativo so sujeito) Issue Alternate Name (Nome alternativo do emissor) Subject Directory attributes (Atributos do diretório do sujeito) Basic Constraints (Restições básicas) Name Constraints (Restições de nome) Policy Constraints (Restições de diretiva) Com foco no estudo deste documento as únicas extensões que iremos descrever é a Basic Constraints (Restições básicas) e Certificate Policies (Políticas de certificado). Basic Constraints (Restições básicas) Essa extensão indica se o sujeito pode agir como uma CA, fornecendo uma maneira para restringir que usuários finais atuem como CAs. Se este campo estiver presente, também poderá ser especificado um comprimento do caminho de certificaçã. O comprimento do caminho de certificação limita os poderes certificadores de uma nova autoridade (por exemplo, se a Verisign poderia permitir que a RSA Inc. atuasse como uma CA, mas ao mesmo tempo, não permitisse que a RSA Inc. criasse novas CAs). A RFC2459 ordena que essa extensão esteja presente e marcada como crítica em todos os certificados de CA. Certificate Policies (Políticas de certificado) Essa extensão identifica as informações sobre as políticas e qualificadores opcionais que a CA associa ao certificado. Se essa extensão for marcada como crítica, o aplicativo de processamento deve seguir pelo menos uma das políticas indicadas ou o certificado não deverá ser utilizado. 6.1.           Hierarquia de certificado À medida que uma população de PKI (public-key infraestructure) começa a aumentar, torna-se difícil para uma CA monitorar de maneira eficaz a identidade de todas as partes que ela certificou. Uma solução é utilizar uma hierarquia de certificados, onde uma CA delega sua autoridade para uma ou mais autoridades subsidiarias. Essas autoridades, por sua vez, designam seus próprios subsidiários. A figura abaixo ilustra o conceito de hierarquia de certificados. Um recurso poderoso das hierarquias de certificado é que nem todas as partes devem confiar automaticamente em todas as autoridades certificadoras. De fato, a única autoridade cuja confiança deve ser estabelecida por todos é a CA superior. Por causa da sua posição na hierarquia, essa autoridade é geralmente conhecida como autoridade raiz. Os exemplos atuais de CAs de raiz pública incluem Verisign, Thawte e a raiz de CA do U.S Postal Service. 7.     Padrão PKCS#12 O formato PKCS#12 foi criado pela “RSA Laboratories” para armazenamento do certificado X.509 acompanhado da chave privada. Esse arquivo geralmente tem a extensão “pfx” e “p12”. 8.     Bas64 encoding Base64 NÃO é criptografia é um algoritmo de codificação Base64 é um método para codificação de dados para transferência na Internet (codificação MIME para transferência de conteúdo). É utilizado frequentemente para transmitir dados binários por meios de transmissão que lidam apenas com texto, como por exemplo para enviar arquivos anexos por e-mail. É constituído por 64 caracteres ([A-Z],[a-z],[0-9], &quot;/&quot; e &quot;+&quot;) que deram origem ao seu nome. Exemplo: Texto original: Treinamento Desenvolvimento Seguro Texto convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Busca parcial Texto anterior completo convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Texto original: Desenvolvimento Texto convertido para Base64: RGVzZW52b2x2aW1lbnRv &nbsp; 9.     Referencias bibliográficas BURNETT, Steve, Criptografia e segurança: o guia oficial RSA, tradução de Edson Fumankiewcz. Ed. Rio de Janeiro: Elsevier, 2002. https://tools.ietf.org/html/rfc4648" /><meta property="og:description" content="Este artigo objetiva demonstrar os conceitos iniciais de criptográfica com chave assimétrica e certificação digital. 1.     O que é criptografia? A criptografia é o processo pelo qual se transforma dados legíveis em algo sem sentido (ilegível), porém sendo capaz de recuperar os dados originais a partir dessas dados sem sentido. A criptografia é uma das ferramentas mais importantes para a proteção dos dados, sejam eles em trânsito ou armazenado. Mas vale a pena ressaltar que a criptografia não é à prova de falhas e toda criptografia pode ser quebrada e, sobretudo, se for implementada incorretamente, ela não agrega nenhuma segurança real. Porque a chave é necessária? Toda criptografia computadorizada opera com chaves, pois manter o algoritmo criptográfico em segredo é algo inviável, sendo assim para proteger os dados basta utilizar um algoritmo de criptografia forte e proteger a chave utilizada. Isso significa também que pode ser utilizado chaves diferentes para proteger diferentes informações, sendo assim, se alguém quebrar uma das chaves, as outras informações ainda estarão seguras. 2.     Criptografia de chave simétrica Nesta abordagem, um algoritmo utiliza uma chave para converter as informações naquilo que se parece com bits aleatórios. Assim, o mesmo algoritmo utiliza a mesma chave para recuperar os dados originais. Esta metodologia tem desempenho bem melhores em se comparado com a criptografia de chave assimétrica, porém como para recuperar os dados cifrados, você também necessita das mesmas chaves que foram utilizadas para cifrar os dados é necessário um bom gerenciamento dessas chaves. Em se tratando de comunicação de via rede este problema da gestão da chave é mais evidente, pois para que dois ativos possam se comunicar os dois necessita conhecer a mesma chave, desta forma tem-se um problema: ou os dois ativos detêm a chave antes do início da comunicação ou a chave necessita ser transmitida via rede sem criptografia. Segue abaixo a imagem ilustrando a utilização do mesmo algoritmo e chave para cifrar a decifrar a mensagem. 3.     Criptografia de chave assimétrica Este esquema utiliza duas chaves diferentes. Mesmo estando relacionadas entre si – elas são parceiras – elas são significativamente diferentes. O relacionamento é matemático; o que uma chave encripta a outra chave decripta. Na criptografia simétrica, a mesma chave é utilizada para encriptar e decriptar (daí a palavra “simétrica” – partes correspondentes); se utilizar outra chave qualquer para decriptar, o resultado será algo sem sentido. Mas com a criptografia assimétrica (conforme imagem abaixo), a chave que é utilizada para encriptar os dados não é utilizada para decriptá-los; apenas a parte correspondente pode (daí palavra “assimétrica” – partes não-correspondentes). Em outras palavras, a chave privada deve permanecer em segredo, enquanto a chave pública pode ser publicada sem qualquer perigo. Neste exemplo é utilizada a chave publica para criptografar os dados, porém somente a chave privada pode decriptografar.   Quando utilizado o algoritmo RSA, qualquer coisa que tenha sido encriptado com a chave pública pode ser decifrado apenas com a chave privada. Bem como qualquer coisa que tenha sido enncriptado com a chave privada pode ser decrifrado apenas com a chave pública. Isto demonstra que o RSA funciona tanto do privado ao público, como do público ao privado. 4.     Assinatura digital Quando se utiliza a chave privada para criptografar os dados, apenas a chave pública pode ser utilizada para decriptografar os dados. Este processo não fornece segurança uma vez que que a chave pública, conceitualmente pode ser conhecida por todos, então para que serve este processo? Para assinatura digital. Pois como somente o proprietário da chave privada pode gerar a informação criptografada, ao descriptografar com a chave pública tem-se a garantia de que o dado criptografado veio de quem diz ser. Desta forma as assinaturas digitais detém duas suposições fundamentais: primeiro, que a chave privada seja segura e que apenas o proprietário da chave tenha acesso a ela e, segundo, que a única maneira de produzir uma assinatura digital seja utilizando a chave privada. A Assinatura digital resolve duas questões relacionadas à criptografia: autenticação e não repúdio. A autenticação permite que alguém no mundo eletrônico confirme dados e identidade, e o não repúdio impede que pessoas retifiquem sua palavra eletrônica. A forma mais comum de assinatura digital conhecida é o certificado digital. Um certificado digital associa um nome a uma chave pública. O certificado digital é produzido de tal maneira que o torna perceptível se um impostor pegou o certificado existente e substituiu a chave pública ou o nome. 5. Hash Hash, ou resumo da mensagem é um algoritmo que recebe qualquer comprimento de entrada (de dados/mensagem) e mescla a entrada para produzir uma saída pseudoaleatória de largura fixa.  Hash detém algumas propriedades: Propriedade 1: Um mesmo algoritmo de hash sempre condensará (reduzir, resumir) o conteúda da entrada de dados em uma saída de tamanho fixo independentemente do tamanho, e do que, for fornecido como entrada; Propriedade 2: A saída de um algoritmo de hash é pseudoaleatória por diversas questões e princípios matemáticos; Propriedade 3: Mesmo que os dados de entrada seja quase idêntico (mudando apenas 1 bit, por exemplo), o a saída será dramaticamente diferente; Propriedade 4: Não pode reconstruir a mensagem de entrada (mensagem original) a partir de uma saída hash, este princípio é conhecido como função de uma única via; Propriedade 5: Um bom algoritmo de hash não são tão fáceis de examinar; Propriedade 6: Não é possível localizar uma mensagem que produza um hash em particular; Propriedade 7: Um bom algoritmo de hash não pode encontrar duas mensagens que produzam uma mesma saída; Hash e Colisões Até o momento da escrita deste post não existe nenhum algoritmo capaz de satisfazer as propriedades 6 e 7 de forma perfeita,  então quando um algoritmo de hash viola as duas ultimas propriedades, o resultado é uma colisão, o termo técnico para descrever uma situação em que duas mensagens produzem um mesmo hash. Segue abaixo uma tabela com as informações dos principais hashes utilizados atualmente: Diferença principal entre Criptografia e Hash Este é um tema controverso, dependendo da literatura que se adota, sendo assim para este estudo vamos entender de forma geral como sendo: Criptografia: Reversível; Hash: Não reversível; 6.     Infraestrutura de chave pública e o padrão X.509 Um certificado de chave pública (public-key certificate – PKC) é um conjunto de dados à prova de falsificação que atesta a associação de uma chave pública a um usuário final. Para fornecer essa associação, um conjunto de terceiros confiáveis confirma a identidade do usuário. Os terceiros chamados de autoridades certificadoras (certification authorities – Cas), emitem certificados para o usuário com o nome de usuário, a chave pública e outras informações que o identifiquem. Após serem assinados digitalmente pela CA, esses certificados podem ser transferidos e armazenados. O formato de certificado mais amplamente aceito é o X.509 Versão 3. Em 1999 foi publicado um perfil para o X.509 na RFC2459. Todas as versões dos certificados X.509 contêm os seguintes campos: Campo Descrição Version (Versão) Este campo deferência as sucessivas versões do certificado, como Versão 1, Versão 2 e Versão 3. O campo Versão também permite possíveis versões futuras. Certificate Serial Number (Número serial de certificado) Esse campo contém um valor de inteiro único em cada certificado. É gerado pela CA. Signature Algorithm Identifier (Identificador do algoritmo de assinatura) Este campo indica o identificador do algoritmo utilizado para assinar o certificado junto com quaisquer parâmetros associados. Issue Name (Nome do emissor) Esse campo identifica o nome distinto (distinguished name – DN) com o qual a CA cria e assina esse certificado. Validity (Not before/After) (Validade – Não antes/Não depois) Esse campo conte´m dois valores de data/hora – Not Valid Before e Not Valid After – que definem o período que esse certificado pode ser considerado válido a menos que, caso, contrário, seja revogado. Subject Name (Nome do sujeito) Esse campo identifica o DN da entidade final a que o certificado se refere, isto é, o sujeito que mantém a chave privada correspondente. Esse campo deve ter uma entrada, a menos que um nome alternativo seja utilizado nas extensões da Versão 3. Subject Public Key Information (Informação sobre a chave pública do sujeito) Esse campo contém o valor da chave pública so sijeito, bem como o identificador de algoritmo e quaisquer parâmetros associados ao algoritmo pelos quais a chave deve ser utilizada. Esse campo sempre deve ter uma entrada. Os certificados versões 2 e 3 podem conter outros campos com: Issue Unique Identifier (identificador único de emissor) Subject Unique Identifier (Identificador único de sujeito) Extensions (Extensões) (Somente versão 3) Authority Key Identifier (Identificador de chave de autoridade) Subject Key Identifier (Identificador de chave de sujeito) Key Usage (Utilização de chave) Extened Key Usage (Utilização de chave estendida) CRL Distribution Point (Ponto de distribuição de CRL) Private Key Usage Period (Período de uso de chave privada) Certificate Policies (Políticas de certificado) Policy Mapping (Mapeamento de políticas) Subject Alternate Name (Nome alternativo so sujeito) Issue Alternate Name (Nome alternativo do emissor) Subject Directory attributes (Atributos do diretório do sujeito) Basic Constraints (Restições básicas) Name Constraints (Restições de nome) Policy Constraints (Restições de diretiva) Com foco no estudo deste documento as únicas extensões que iremos descrever é a Basic Constraints (Restições básicas) e Certificate Policies (Políticas de certificado). Basic Constraints (Restições básicas) Essa extensão indica se o sujeito pode agir como uma CA, fornecendo uma maneira para restringir que usuários finais atuem como CAs. Se este campo estiver presente, também poderá ser especificado um comprimento do caminho de certificaçã. O comprimento do caminho de certificação limita os poderes certificadores de uma nova autoridade (por exemplo, se a Verisign poderia permitir que a RSA Inc. atuasse como uma CA, mas ao mesmo tempo, não permitisse que a RSA Inc. criasse novas CAs). A RFC2459 ordena que essa extensão esteja presente e marcada como crítica em todos os certificados de CA. Certificate Policies (Políticas de certificado) Essa extensão identifica as informações sobre as políticas e qualificadores opcionais que a CA associa ao certificado. Se essa extensão for marcada como crítica, o aplicativo de processamento deve seguir pelo menos uma das políticas indicadas ou o certificado não deverá ser utilizado. 6.1.           Hierarquia de certificado À medida que uma população de PKI (public-key infraestructure) começa a aumentar, torna-se difícil para uma CA monitorar de maneira eficaz a identidade de todas as partes que ela certificou. Uma solução é utilizar uma hierarquia de certificados, onde uma CA delega sua autoridade para uma ou mais autoridades subsidiarias. Essas autoridades, por sua vez, designam seus próprios subsidiários. A figura abaixo ilustra o conceito de hierarquia de certificados. Um recurso poderoso das hierarquias de certificado é que nem todas as partes devem confiar automaticamente em todas as autoridades certificadoras. De fato, a única autoridade cuja confiança deve ser estabelecida por todos é a CA superior. Por causa da sua posição na hierarquia, essa autoridade é geralmente conhecida como autoridade raiz. Os exemplos atuais de CAs de raiz pública incluem Verisign, Thawte e a raiz de CA do U.S Postal Service. 7.     Padrão PKCS#12 O formato PKCS#12 foi criado pela “RSA Laboratories” para armazenamento do certificado X.509 acompanhado da chave privada. Esse arquivo geralmente tem a extensão “pfx” e “p12”. 8.     Bas64 encoding Base64 NÃO é criptografia é um algoritmo de codificação Base64 é um método para codificação de dados para transferência na Internet (codificação MIME para transferência de conteúdo). É utilizado frequentemente para transmitir dados binários por meios de transmissão que lidam apenas com texto, como por exemplo para enviar arquivos anexos por e-mail. É constituído por 64 caracteres ([A-Z],[a-z],[0-9], &quot;/&quot; e &quot;+&quot;) que deram origem ao seu nome. Exemplo: Texto original: Treinamento Desenvolvimento Seguro Texto convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Busca parcial Texto anterior completo convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Texto original: Desenvolvimento Texto convertido para Base64: RGVzZW52b2x2aW1lbnRv &nbsp; 9.     Referencias bibliográficas BURNETT, Steve, Criptografia e segurança: o guia oficial RSA, tradução de Edson Fumankiewcz. Ed. Rio de Janeiro: Elsevier, 2002. https://tools.ietf.org/html/rfc4648" /><link rel="canonical" href="https://www.helviojunior.com.br/it/security/introducao-criptografia/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/security/introducao-criptografia/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2012-03-07T03:37:40-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2012-03-07T03:37:40-03:00","description":"Este artigo objetiva demonstrar os conceitos iniciais de criptográfica com chave assimétrica e certificação digital. 1.     O que é criptografia? A criptografia é o processo pelo qual se transforma dados legíveis em algo sem sentido (ilegível), porém sendo capaz de recuperar os dados originais a partir dessas dados sem sentido. A criptografia é uma das ferramentas mais importantes para a proteção dos dados, sejam eles em trânsito ou armazenado. Mas vale a pena ressaltar que a criptografia não é à prova de falhas e toda criptografia pode ser quebrada e, sobretudo, se for implementada incorretamente, ela não agrega nenhuma segurança real. Porque a chave é necessária? Toda criptografia computadorizada opera com chaves, pois manter o algoritmo criptográfico em segredo é algo inviável, sendo assim para proteger os dados basta utilizar um algoritmo de criptografia forte e proteger a chave utilizada. Isso significa também que pode ser utilizado chaves diferentes para proteger diferentes informações, sendo assim, se alguém quebrar uma das chaves, as outras informações ainda estarão seguras. 2.     Criptografia de chave simétrica Nesta abordagem, um algoritmo utiliza uma chave para converter as informações naquilo que se parece com bits aleatórios. Assim, o mesmo algoritmo utiliza a mesma chave para recuperar os dados originais. Esta metodologia tem desempenho bem melhores em se comparado com a criptografia de chave assimétrica, porém como para recuperar os dados cifrados, você também necessita das mesmas chaves que foram utilizadas para cifrar os dados é necessário um bom gerenciamento dessas chaves. Em se tratando de comunicação de via rede este problema da gestão da chave é mais evidente, pois para que dois ativos possam se comunicar os dois necessita conhecer a mesma chave, desta forma tem-se um problema: ou os dois ativos detêm a chave antes do início da comunicação ou a chave necessita ser transmitida via rede sem criptografia. Segue abaixo a imagem ilustrando a utilização do mesmo algoritmo e chave para cifrar a decifrar a mensagem. 3.     Criptografia de chave assimétrica Este esquema utiliza duas chaves diferentes. Mesmo estando relacionadas entre si – elas são parceiras – elas são significativamente diferentes. O relacionamento é matemático; o que uma chave encripta a outra chave decripta. Na criptografia simétrica, a mesma chave é utilizada para encriptar e decriptar (daí a palavra “simétrica” – partes correspondentes); se utilizar outra chave qualquer para decriptar, o resultado será algo sem sentido. Mas com a criptografia assimétrica (conforme imagem abaixo), a chave que é utilizada para encriptar os dados não é utilizada para decriptá-los; apenas a parte correspondente pode (daí palavra “assimétrica” – partes não-correspondentes). Em outras palavras, a chave privada deve permanecer em segredo, enquanto a chave pública pode ser publicada sem qualquer perigo. Neste exemplo é utilizada a chave publica para criptografar os dados, porém somente a chave privada pode decriptografar.   Quando utilizado o algoritmo RSA, qualquer coisa que tenha sido encriptado com a chave pública pode ser decifrado apenas com a chave privada. Bem como qualquer coisa que tenha sido enncriptado com a chave privada pode ser decrifrado apenas com a chave pública. Isto demonstra que o RSA funciona tanto do privado ao público, como do público ao privado. 4.     Assinatura digital Quando se utiliza a chave privada para criptografar os dados, apenas a chave pública pode ser utilizada para decriptografar os dados. Este processo não fornece segurança uma vez que que a chave pública, conceitualmente pode ser conhecida por todos, então para que serve este processo? Para assinatura digital. Pois como somente o proprietário da chave privada pode gerar a informação criptografada, ao descriptografar com a chave pública tem-se a garantia de que o dado criptografado veio de quem diz ser. Desta forma as assinaturas digitais detém duas suposições fundamentais: primeiro, que a chave privada seja segura e que apenas o proprietário da chave tenha acesso a ela e, segundo, que a única maneira de produzir uma assinatura digital seja utilizando a chave privada. A Assinatura digital resolve duas questões relacionadas à criptografia: autenticação e não repúdio. A autenticação permite que alguém no mundo eletrônico confirme dados e identidade, e o não repúdio impede que pessoas retifiquem sua palavra eletrônica. A forma mais comum de assinatura digital conhecida é o certificado digital. Um certificado digital associa um nome a uma chave pública. O certificado digital é produzido de tal maneira que o torna perceptível se um impostor pegou o certificado existente e substituiu a chave pública ou o nome. 5. Hash Hash, ou resumo da mensagem é um algoritmo que recebe qualquer comprimento de entrada (de dados/mensagem) e mescla a entrada para produzir uma saída pseudoaleatória de largura fixa.  Hash detém algumas propriedades: Propriedade 1: Um mesmo algoritmo de hash sempre condensará (reduzir, resumir) o conteúda da entrada de dados em uma saída de tamanho fixo independentemente do tamanho, e do que, for fornecido como entrada; Propriedade 2: A saída de um algoritmo de hash é pseudoaleatória por diversas questões e princípios matemáticos; Propriedade 3: Mesmo que os dados de entrada seja quase idêntico (mudando apenas 1 bit, por exemplo), o a saída será dramaticamente diferente; Propriedade 4: Não pode reconstruir a mensagem de entrada (mensagem original) a partir de uma saída hash, este princípio é conhecido como função de uma única via; Propriedade 5: Um bom algoritmo de hash não são tão fáceis de examinar; Propriedade 6: Não é possível localizar uma mensagem que produza um hash em particular; Propriedade 7: Um bom algoritmo de hash não pode encontrar duas mensagens que produzam uma mesma saída; Hash e Colisões Até o momento da escrita deste post não existe nenhum algoritmo capaz de satisfazer as propriedades 6 e 7 de forma perfeita,  então quando um algoritmo de hash viola as duas ultimas propriedades, o resultado é uma colisão, o termo técnico para descrever uma situação em que duas mensagens produzem um mesmo hash. Segue abaixo uma tabela com as informações dos principais hashes utilizados atualmente: Diferença principal entre Criptografia e Hash Este é um tema controverso, dependendo da literatura que se adota, sendo assim para este estudo vamos entender de forma geral como sendo: Criptografia: Reversível; Hash: Não reversível; 6.     Infraestrutura de chave pública e o padrão X.509 Um certificado de chave pública (public-key certificate – PKC) é um conjunto de dados à prova de falsificação que atesta a associação de uma chave pública a um usuário final. Para fornecer essa associação, um conjunto de terceiros confiáveis confirma a identidade do usuário. Os terceiros chamados de autoridades certificadoras (certification authorities – Cas), emitem certificados para o usuário com o nome de usuário, a chave pública e outras informações que o identifiquem. Após serem assinados digitalmente pela CA, esses certificados podem ser transferidos e armazenados. O formato de certificado mais amplamente aceito é o X.509 Versão 3. Em 1999 foi publicado um perfil para o X.509 na RFC2459. Todas as versões dos certificados X.509 contêm os seguintes campos: Campo Descrição Version (Versão) Este campo deferência as sucessivas versões do certificado, como Versão 1, Versão 2 e Versão 3. O campo Versão também permite possíveis versões futuras. Certificate Serial Number (Número serial de certificado) Esse campo contém um valor de inteiro único em cada certificado. É gerado pela CA. Signature Algorithm Identifier (Identificador do algoritmo de assinatura) Este campo indica o identificador do algoritmo utilizado para assinar o certificado junto com quaisquer parâmetros associados. Issue Name (Nome do emissor) Esse campo identifica o nome distinto (distinguished name – DN) com o qual a CA cria e assina esse certificado. Validity (Not before/After) (Validade – Não antes/Não depois) Esse campo conte´m dois valores de data/hora – Not Valid Before e Not Valid After – que definem o período que esse certificado pode ser considerado válido a menos que, caso, contrário, seja revogado. Subject Name (Nome do sujeito) Esse campo identifica o DN da entidade final a que o certificado se refere, isto é, o sujeito que mantém a chave privada correspondente. Esse campo deve ter uma entrada, a menos que um nome alternativo seja utilizado nas extensões da Versão 3. Subject Public Key Information (Informação sobre a chave pública do sujeito) Esse campo contém o valor da chave pública so sijeito, bem como o identificador de algoritmo e quaisquer parâmetros associados ao algoritmo pelos quais a chave deve ser utilizada. Esse campo sempre deve ter uma entrada. Os certificados versões 2 e 3 podem conter outros campos com: Issue Unique Identifier (identificador único de emissor) Subject Unique Identifier (Identificador único de sujeito) Extensions (Extensões) (Somente versão 3) Authority Key Identifier (Identificador de chave de autoridade) Subject Key Identifier (Identificador de chave de sujeito) Key Usage (Utilização de chave) Extened Key Usage (Utilização de chave estendida) CRL Distribution Point (Ponto de distribuição de CRL) Private Key Usage Period (Período de uso de chave privada) Certificate Policies (Políticas de certificado) Policy Mapping (Mapeamento de políticas) Subject Alternate Name (Nome alternativo so sujeito) Issue Alternate Name (Nome alternativo do emissor) Subject Directory attributes (Atributos do diretório do sujeito) Basic Constraints (Restições básicas) Name Constraints (Restições de nome) Policy Constraints (Restições de diretiva) Com foco no estudo deste documento as únicas extensões que iremos descrever é a Basic Constraints (Restições básicas) e Certificate Policies (Políticas de certificado). Basic Constraints (Restições básicas) Essa extensão indica se o sujeito pode agir como uma CA, fornecendo uma maneira para restringir que usuários finais atuem como CAs. Se este campo estiver presente, também poderá ser especificado um comprimento do caminho de certificaçã. O comprimento do caminho de certificação limita os poderes certificadores de uma nova autoridade (por exemplo, se a Verisign poderia permitir que a RSA Inc. atuasse como uma CA, mas ao mesmo tempo, não permitisse que a RSA Inc. criasse novas CAs). A RFC2459 ordena que essa extensão esteja presente e marcada como crítica em todos os certificados de CA. Certificate Policies (Políticas de certificado) Essa extensão identifica as informações sobre as políticas e qualificadores opcionais que a CA associa ao certificado. Se essa extensão for marcada como crítica, o aplicativo de processamento deve seguir pelo menos uma das políticas indicadas ou o certificado não deverá ser utilizado. 6.1.           Hierarquia de certificado À medida que uma população de PKI (public-key infraestructure) começa a aumentar, torna-se difícil para uma CA monitorar de maneira eficaz a identidade de todas as partes que ela certificou. Uma solução é utilizar uma hierarquia de certificados, onde uma CA delega sua autoridade para uma ou mais autoridades subsidiarias. Essas autoridades, por sua vez, designam seus próprios subsidiários. A figura abaixo ilustra o conceito de hierarquia de certificados. Um recurso poderoso das hierarquias de certificado é que nem todas as partes devem confiar automaticamente em todas as autoridades certificadoras. De fato, a única autoridade cuja confiança deve ser estabelecida por todos é a CA superior. Por causa da sua posição na hierarquia, essa autoridade é geralmente conhecida como autoridade raiz. Os exemplos atuais de CAs de raiz pública incluem Verisign, Thawte e a raiz de CA do U.S Postal Service. 7.     Padrão PKCS#12 O formato PKCS#12 foi criado pela “RSA Laboratories” para armazenamento do certificado X.509 acompanhado da chave privada. Esse arquivo geralmente tem a extensão “pfx” e “p12”. 8.     Bas64 encoding Base64 NÃO é criptografia é um algoritmo de codificação Base64 é um método para codificação de dados para transferência na Internet (codificação MIME para transferência de conteúdo). É utilizado frequentemente para transmitir dados binários por meios de transmissão que lidam apenas com texto, como por exemplo para enviar arquivos anexos por e-mail. É constituído por 64 caracteres ([A-Z],[a-z],[0-9], &quot;/&quot; e &quot;+&quot;) que deram origem ao seu nome. Exemplo: Texto original: Treinamento Desenvolvimento Seguro Texto convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Busca parcial Texto anterior completo convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw== Texto original: Desenvolvimento Texto convertido para Base64: RGVzZW52b2x2aW1lbnRv &nbsp; 9.     Referencias bibliográficas BURNETT, Steve, Criptografia e segurança: o guia oficial RSA, tradução de Edson Fumankiewcz. Ed. Rio de Janeiro: Elsevier, 2002. https://tools.ietf.org/html/rfc4648","headline":"Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/security/introducao-criptografia/"},"url":"https://www.helviojunior.com.br/it/security/introducao-criptografia/"}</script><title>Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital) | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span>Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 7, 2012, 3:37 AM -0300" prep="on" > Mar 7, 2012 <i class="unloaded">2012-03-07T03:37:40-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1970 words">10 min</span></div></div><div class="post-content"><p>Este artigo objetiva demonstrar os conceitos iniciais de criptográfica com chave assimétrica e certificação digital.</p><p></p><h2>1.     O que é criptografia?</h2><p>A criptografia é o processo pelo qual se transforma dados legíveis em algo sem sentido (ilegível), porém sendo capaz de recuperar os dados originais a partir dessas dados sem sentido. A criptografia é uma das ferramentas mais importantes para a proteção dos dados, sejam eles em trânsito ou armazenado. Mas vale a pena ressaltar que a criptografia não é à prova de falhas e toda criptografia pode ser quebrada e, sobretudo, se for implementada incorretamente, ela não agrega nenhuma segurança real.</p><h3>Porque a chave é necessária?</h3><p>Toda criptografia computadorizada opera com chaves, pois manter o algoritmo criptográfico em segredo é algo inviável, sendo assim para proteger os dados basta utilizar um algoritmo de criptografia forte e proteger a chave utilizada. Isso significa também que pode ser utilizado chaves diferentes para proteger diferentes informações, sendo assim, se alguém quebrar uma das chaves, as outras informações ainda estarão seguras.</p><h2>2.     Criptografia de chave simétrica</h2><p>Nesta abordagem, um algoritmo utiliza uma chave para converter as informações naquilo que se parece com bits aleatórios. Assim, o mesmo algoritmo utiliza a mesma chave para recuperar os dados originais.</p><p>Esta metodologia tem desempenho bem melhores em se comparado com a criptografia de chave assimétrica, porém como para recuperar os dados cifrados, você também necessita das mesmas chaves que foram utilizadas para cifrar os dados é necessário um bom gerenciamento dessas chaves. Em se tratando de comunicação de via rede este problema da gestão da chave é mais evidente, pois para que dois ativos possam se comunicar os dois necessita conhecer a mesma chave, desta forma tem-se um problema: ou os dois ativos detêm a chave antes do início da comunicação ou a chave necessita ser transmitida via rede sem criptografia.</p><p>Segue abaixo a imagem ilustrando a utilização do mesmo algoritmo e chave para cifrar a decifrar a mensagem.</p><p style="text-align: center;"><a href="/assets/2012/03/image1.jpeg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 374 462'%3E%3C/svg%3E" title="Chave-Simetrica" data-src="/assets/2012/03/image1.jpeg" alt="" width="374" height="462" class="lazyload" data-proofer-ignore></a></p><h2>3.     Criptografia de chave assimétrica</h2><p>Este esquema utiliza duas chaves diferentes. Mesmo estando relacionadas entre si – elas são parceiras – elas são significativamente diferentes. O relacionamento é matemático; o que uma chave encripta a outra chave decripta. Na criptografia simétrica, a mesma chave é utilizada para encriptar e decriptar (daí a palavra “simétrica” – partes correspondentes); se utilizar outra chave qualquer para decriptar, o resultado será algo sem sentido. Mas com a criptografia assimétrica (conforme imagem abaixo), a chave que é utilizada para encriptar os dados não é utilizada para decriptá-los; apenas a parte correspondente pode (daí palavra “assimétrica” – partes não-correspondentes).</p><p>Em outras palavras, a chave privada deve permanecer em segredo, enquanto a chave pública pode ser publicada sem qualquer perigo. Neste exemplo é utilizada a <b>chave publica </b>para <b>criptografar</b> os dados, porém somente a <b>chave privada </b>pode <b>decriptografar</b>.</p><p style="text-align: center;" align="left"> <a href="/assets/2012/03/image2.jpeg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 353 485'%3E%3C/svg%3E" title="chave-assimetrica" data-src="/assets/2012/03/image2.jpeg" alt="" width="353" height="485" class="lazyload" data-proofer-ignore></a></p><p align="left">Quando utilizado o algoritmo RSA, qualquer coisa que tenha sido encriptado com a chave pública pode ser decifrado apenas com a chave privada. Bem como qualquer coisa que tenha sido enncriptado com a chave privada pode ser decrifrado apenas com a chave pública. Isto demonstra que o RSA funciona tanto do privado ao público, como do público ao privado.</p><h2>4.     Assinatura digital</h2><p>Quando se utiliza a chave privada para criptografar os dados, apenas a chave pública pode ser utilizada para decriptografar os dados. Este processo não fornece segurança uma vez que que a chave pública, conceitualmente pode ser conhecida por todos, então para que serve este processo? Para assinatura digital. Pois como somente o proprietário da chave privada pode gerar a informação criptografada, ao descriptografar com a chave pública tem-se a garantia de que o dado criptografado veio de quem diz ser.</p><p>Desta forma as assinaturas digitais detém duas suposições fundamentais: primeiro, que a chave privada seja segura e que apenas o proprietário da chave tenha acesso a ela e, segundo, que a única maneira de produzir uma assinatura digital seja utilizando a chave privada.</p><p>A Assinatura digital resolve duas questões relacionadas à criptografia: autenticação e não repúdio. A autenticação permite que alguém no mundo eletrônico confirme dados e identidade, e o não repúdio impede que pessoas retifiquem sua palavra eletrônica.</p><p>A forma mais comum de assinatura digital conhecida é o certificado digital. Um certificado digital associa um nome a uma chave pública. O certificado digital é produzido de tal maneira que o torna perceptível se um impostor pegou o certificado existente e substituiu a chave pública ou o nome.</p><h2>5. Hash</h2><p>Hash, ou resumo da mensagem é um algoritmo que recebe qualquer comprimento de entrada (de dados/mensagem) e mescla a entrada para produzir uma saída pseudoaleatória de largura fixa.  Hash detém algumas propriedades:</p><ul><li><b>Propriedade 1: </b>Um mesmo algoritmo de hash sempre condensará (reduzir, resumir) o conteúda da entrada de dados em uma saída de tamanho fixo independentemente do tamanho, e do que, for fornecido como entrada;<li><b>Propriedade 2: </b>A saída de um algoritmo de hash é pseudoaleatória por diversas questões e princípios matemáticos;<li><b>Propriedade 3: </b>Mesmo que os dados de entrada seja quase idêntico (mudando apenas 1 bit, por exemplo), o a saída será dramaticamente diferente;<li><b>Propriedade 4: </b>Não pode reconstruir a mensagem de entrada (mensagem original) a partir de uma saída hash, este princípio é conhecido como função de uma única via;<li><b>Propriedade 5: </b>Um bom algoritmo de hash não são tão fáceis de examinar;<li><b>Propriedade 6: </b>Não é possível localizar uma mensagem que produza um hash em particular;<li><b>Propriedade 7: </b>Um bom algoritmo de hash não pode encontrar duas mensagens que produzam uma mesma saída;</ul><h3>Hash e Colisões</h3><p>Até o momento da escrita deste post não existe nenhum algoritmo capaz de satisfazer as propriedades 6 e 7 de forma perfeita,  então quando um algoritmo de hash viola as duas ultimas propriedades, o resultado é uma colisão, o termo técnico para descrever uma situação em que duas mensagens produzem um mesmo hash.</p><p>Segue abaixo uma tabela com as informações dos principais hashes utilizados atualmente:</p><p><a href="/assets/2012/03/Hashes.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1305 325'%3E%3C/svg%3E" data-src="/assets/2012/03/Hashes.png" alt="" width="1305" height="325" class="lazyload" data-proofer-ignore></a></p><h3>Diferença principal entre Criptografia e Hash</h3><p>Este é um tema controverso, dependendo da literatura que se adota, sendo assim para este estudo vamos entender de forma geral como sendo:</p><ul><li><b>Criptografia: </b>Reversível;<li><b>Hash: </b>Não reversível;</ul><h2>6.     Infraestrutura de chave pública e o padrão X.509</h2><p>Um certificado de chave pública (public-key certificate – PKC) é um conjunto de dados à prova de falsificação que atesta a associação de uma chave pública a um usuário final. Para fornecer essa associação, um conjunto de terceiros confiáveis confirma a identidade do usuário. Os terceiros chamados de autoridades certificadoras (certification authorities – Cas), emitem certificados para o usuário com o nome de usuário, a chave pública e outras informações que o identifiquem. Após serem assinados digitalmente pela CA, esses certificados podem ser transferidos e armazenados.</p><p>O formato de certificado mais amplamente aceito é o X.509 Versão 3. Em 1999 foi publicado um perfil para o X.509 na RFC2459.</p><p>Todas as versões dos certificados X.509 contêm os seguintes campos:</p><div class="table-wrapper"><table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top" width="206"><strong>Campo</strong><td valign="top" width="428"><strong>Descrição</strong><tr><td valign="top" width="206"><strong>Version (Versão)</strong><td valign="top" width="428">Este campo deferência as sucessivas versões do certificado, como Versão 1, Versão 2 e Versão 3. O campo Versão também permite possíveis versões futuras.<tr><td valign="top" width="206"><strong>Certificate Serial Number (Número serial de certificado)</strong><td valign="top" width="428">Esse campo contém um valor de inteiro único em cada certificado. É gerado pela CA.<tr><td valign="top" width="206"><strong>Signature Algorithm Identifier (Identificador do algoritmo de assinatura)</strong><td valign="top" width="428">Este campo indica o identificador do algoritmo utilizado para assinar o certificado junto com quaisquer parâmetros associados.<tr><td valign="top" width="206"><strong>Issue Name (Nome do emissor)</strong><td valign="top" width="428">Esse campo identifica o nome distinto (distinguished name – DN) com o qual a CA cria e assina esse certificado.<tr><td valign="top" width="206"><strong>Validity (Not before/After) (Validade – Não antes/Não depois)</strong><td valign="top" width="428">Esse campo conte´m dois valores de data/hora – Not Valid Before e Not Valid After – que definem o período que esse certificado pode ser considerado válido a menos que, caso, contrário, seja revogado.<tr><td valign="top" width="206"><strong>Subject Name (Nome do sujeito)</strong><td valign="top" width="428">Esse campo identifica o DN da entidade final a que o certificado se refere, isto é, o sujeito que mantém a chave privada correspondente. Esse campo deve ter uma entrada, a menos que um nome alternativo seja utilizado nas extensões da Versão 3.<tr><td valign="top" width="206"><strong>Subject Public Key Information (Informação sobre a chave pública do sujeito)</strong><td valign="top" width="428">Esse campo contém o valor da chave pública so sijeito, bem como o identificador de algoritmo e quaisquer parâmetros associados ao algoritmo pelos quais a chave deve ser utilizada. Esse campo sempre deve ter uma entrada.</table></div><p>Os certificados versões 2 e 3 podem conter outros campos com:</p><ul><li>Issue Unique Identifier (identificador único de emissor)<li>Subject Unique Identifier (Identificador único de sujeito)<li>Extensions (Extensões) (Somente versão 3)<ul><li>Authority Key Identifier (Identificador de chave de autoridade)<li>Subject Key Identifier (Identificador de chave de sujeito)<li>Key Usage (Utilização de chave)<li>Extened Key Usage (Utilização de chave estendida)<li>CRL Distribution Point (Ponto de distribuição de CRL)<li>Private Key Usage Period (Período de uso de chave privada)<li>Certificate Policies (Políticas de certificado)<li>Policy Mapping (Mapeamento de políticas)<li>Subject Alternate Name (Nome alternativo so sujeito)<li>Issue Alternate Name (Nome alternativo do emissor)<li>Subject Directory attributes (Atributos do diretório do sujeito)<li>Basic Constraints (Restições básicas)<li>Name Constraints (Restições de nome)<li>Policy Constraints (Restições de diretiva)</ul></ul><p>Com foco no estudo deste documento as únicas extensões que iremos descrever é a <strong>Basic Constraints (Restições básicas)</strong> e <strong>Certificate Policies (Políticas de certificado).</strong></p><ul><li>Basic Constraints (Restições básicas)</ul><p>Essa extensão indica se o sujeito pode agir como uma CA, fornecendo uma maneira para restringir que usuários finais atuem como CAs. Se este campo estiver presente, também poderá ser especificado um comprimento do caminho de certificaçã. O comprimento do caminho de certificação limita os poderes certificadores de uma nova autoridade (por exemplo, se a Verisign poderia permitir que a RSA Inc. atuasse como uma CA, mas ao mesmo tempo, não permitisse que a RSA Inc. criasse novas CAs). A RFC2459 ordena que essa extensão esteja presente e marcada como crítica em todos os certificados de CA.</p><ul><li>Certificate Policies (Políticas de certificado)</ul><p>Essa extensão identifica as informações sobre as políticas e qualificadores opcionais que a CA associa ao certificado. Se essa extensão for marcada como crítica, o aplicativo de processamento deve seguir pelo menos uma das políticas indicadas ou o certificado não deverá ser utilizado.</p><h3>6.1.           Hierarquia de certificado</h3><p>À medida que uma população de PKI (public-key infraestructure) começa a aumentar, torna-se difícil para uma CA monitorar de maneira eficaz a identidade de todas as partes que ela certificou. Uma solução é utilizar uma hierarquia de certificados, onde uma CA delega sua autoridade para uma ou mais autoridades subsidiarias. Essas autoridades, por sua vez, designam seus próprios subsidiários. A figura abaixo ilustra o conceito de hierarquia de certificados.</p><p style="text-align: center;"><a href="/assets/2012/03/image3.jpeg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308 234'%3E%3C/svg%3E" title="Hierarquia de certificação" data-src="/assets/2012/03/image3.jpeg" alt="" width="308" height="234" class="lazyload" data-proofer-ignore></a></p><p>Um recurso poderoso das hierarquias de certificado é que nem todas as partes devem confiar automaticamente em todas as autoridades certificadoras. De fato, a única autoridade cuja confiança deve ser estabelecida por todos é a CA superior. Por causa da sua posição na hierarquia, essa autoridade é geralmente conhecida como autoridade raiz. Os exemplos atuais de CAs de raiz pública incluem Verisign, Thawte e a raiz de CA do U.S Postal Service.</p><h2>7.     Padrão PKCS#12</h2><p>O formato PKCS#12 foi criado pela “RSA Laboratories” para armazenamento do certificado X.509 acompanhado da chave privada. Esse arquivo geralmente tem a extensão “pfx” e “p12”.</p><h2>8.     Bas64 encoding</h2><p><b>Base64 NÃO é criptografia é um algoritmo de codificação</b></p><p>Base64 é um método para codificação de dados para transferência na Internet (codificação MIME para transferência de conteúdo). É utilizado frequentemente para transmitir dados binários por meios de transmissão que lidam apenas com texto, como por exemplo para enviar arquivos anexos por e-mail. É constituído por 64 caracteres ([A-Z],[a-z],[0-9], "/" e "+") que deram origem ao seu nome.</p><p>Exemplo:</p><ul><li>Texto original: Treinamento Desenvolvimento Seguro<li>Texto convertido para Base64: VHJlaW5hbWVudG8gRGVzZW52b2x2aW1lbnRvIFNlZ3Vybw==</ul><p>Busca parcial</p><ul><li>Texto anterior completo convertido para Base64: VHJlaW5hbWVudG8g<span style="color: #ff0000;">RGVzZW52b2x2aW1lbnRv</span>IFNlZ3Vybw==<li>Texto original: Desenvolvimento<li>Texto convertido para Base64: RGVzZW52b2x2aW1lbnRv</ul><p>&nbsp;</p><h2>9.     Referencias bibliográficas</h2><p>BURNETT, Steve, <strong>Criptografia e segurança: o guia oficial RSA, </strong>tradução de Edson Fumankiewcz. Ed. Rio de Janeiro: Elsevier, 2002.</p><p>https://tools.ietf.org/html/rfc4648</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/it/'>IT</a>, <a href='/categories/seguran%C3%A7a-da-informa%C3%A7%C3%A3o/'>Segurança da Informação</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/autoridade-certificadora/" class="post-tag no-text-decoration" >autoridade certificadora</a> <a href="/tags/ca/" class="post-tag no-text-decoration" >ca</a> <a href="/tags/certificate-authority/" class="post-tag no-text-decoration" >certificate authority</a> <a href="/tags/openssl/" class="post-tag no-text-decoration" >openssl</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital) - Helvio Junior&url=https://www.helviojunior.com.br/it/security/introducao-criptografia/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital) - Helvio Junior&u=https://www.helviojunior.com.br/it/security/introducao-criptografia/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital) - Helvio Junior&url=https://www.helviojunior.com.br/it/security/introducao-criptografia/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/security/introducao-criptografia/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/security/transport-layer-security-tls-e-secure-sockets-layer-ssl/"><div class="card-body"> <span class="timeago small" > Mar 7, 2012 <i class="unloaded">2012-03-07T12:07:51-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Transport Layer Security (TLS) e Secure Sockets Layer (SSL)</h3><div class="text-muted small"><p> O TLS/SSL é utilizado para garantir a confidencialidade e autenticidade de servidores e clientes na internet, o seu uso é mais comum em protocolos como HTTP e SMTP comumente chamados de HTTPS e SMT...</p></div></div></a></div><div class="card"> <a href="/it/security/instalando-autoridade-certificadora-raiz-ca-root-com-openssl/"><div class="card-body"> <span class="timeago small" > Mar 7, 2012 <i class="unloaded">2012-03-07T12:56:35-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Instalando autoridade certificadora raiz (CA Root) com OpenSSL</h3><div class="text-muted small"><p> Este método de geração de uma CA utiliza-se do aplicativo OpenSSL disponível para Windows e linux, não tendo alteração dos comandos para os diferentes sistemas operacionais. 1 – Efetue a instalaçã...</p></div></div></a></div><div class="card"> <a href="/it/security/instalando-autoridade-certificadora-raiz-ca-root-com-windows/"><div class="card-body"> <span class="timeago small" > Mar 7, 2012 <i class="unloaded">2012-03-07T13:08:58-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Instalando autoridade certificadora raiz (CA Root) com windows</h3><div class="text-muted small"><p> 1 - Para efetuar a instalação da Autoridade certificadora (CA - Certificate Authority) vá até o Windows 2003, entre no Painel de controle, selecione a opção de Adicionar e remover programas e cliqu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/clareza-e-produtividade-na-gestao-do-firewall-aker-6-1/" class="btn btn-outline-primary" prompt="Older"><p>Clareza e produtividade na gestão do Firewall Aker 6.1</p></a> <a href="/it/security/importando-certificado-x-509-no-windows/" class="btn btn-outline-primary" prompt="Newer"><p>Importando certificado X.509 no Windows</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Introdução a Criptografia (Criptografia, hash, base64 encoding e certificação digital)'; this.page.url = 'https://www.helviojunior.com.br/it/security/introducao-criptografia/'; this.page.identifier = '/it/security/introducao-criptografia/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
