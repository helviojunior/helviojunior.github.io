<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Criação de Exploits - Parte 0 - Um pouco de teoria" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow. Caso você deseje segue o link para a lista completa de posts sobre a criação de exploits e buffer overflow: https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/ Mas antes de começar a colocar a mão na massa, como sempre, precisamos de um pouco de teoria para embasar e entender todo o contexto, e como quando falamos de Buffer Overflow, falamos de memória, pilha, push pop, assembly e etc... nada é tão simples e tão trivial, então se posso dar uma recomendação é: leia e releia toda a teoria, busque outros sites, outros livros, outras referencias para complementar o seu conhecimento, pois isso será base para o sucesso ou falha no momento da criação dos seus exploits. Segue a referência de um site onde tem bastante conteúdo sobre este assunto: https://www.corelan.be Antes de mais nada, o que é Buffer Overflow? Weidman define Buffer Overflow como &quot;o processo pelo qual manipulamos a memória de uma aplicação de forma que preenchemos mais dados do que a aplicação esperava receber extrapolando o tamanho da variável no stack de memória e sobrepondo o espaço de memória adjacente&quot;. Se um pedaço de memória crítica for sobreposta a aplicação irá falhar/gerar uma exceção/erro. Com um pouco de técnica e cuidado podemos sobrepor partes importantes e controlar o fluxo de execução da aplicação após essa falha. Definição de ambiente Antes de mais nada é importante ressaltar que todos os procedimentos que explicarei nessa série de posts são baseados em Microsoft Windows com aplicação rodando em 32 bits. Arquitetura e Memória Antes de ir a fundo em Buffer Overflow e criação de Exploits certamente precisamos entender como a memória funciona, pois o princípio base de Buffer Overflow é a manipulação de memória. Nosso objetivo final sempre será manipular a memória de forma que aplicação execute o que vamos inserir nela. Quando se estuda a arquitetura de um ambiente computacional há uma sistema hierárquico de proteção conhecido como Protection Ring, basicamente isso é um mecanismo de proteção e tolerância a falhas dos sistemas. Em um ambiente Windows 32 bits o endereçamento de memória vai de 0x00000000 a 0xFFFFFFFF, onde se divide em duas faixas: a primeira que vai de 0x00000000 a 0x7FFFFFFF é atribuída ao Ring 3 - User-land, e a segunda vai de 0x80000000 a 0xFFFFFFFF que é atribuída ao Ring 0 - Kernel-land. O Endereçamento de memória dentro do kernel-land somente é acessível pelo Sistema Operacional. O Windows utiliza um modelo de endereçamento de memória conhecido como flat memory model, que basicamente indica que a memória aparece para as aplicações como um único espaço contínuo. A CPU pode diretamente (and linearmente) endereçar toda memória disponível sem a necessidade de utilizar segmentação/paginação de memória. Memória Primeiro precisamos entender um pouco mais como é a memória de um aplicativo, veja a imagem abaixo: [caption id=&quot;attachment_1826&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Visualização da memória[/caption] Cada aplicação utiliza parte da memória, a aplicação contém basicamente alguns segmentos de memória, conforme abaixo: segmento de código (text): código do programa a ser executado segmento data: informações globais da aplicação, estes dados são carregados no momento do início da aplicação, são estáticos (não mudam enquanto o programa está rodando) e estão disponíveis para a toda a aplicação segmento pilha (stack): tem tamanho fixo e é usado para armazenar argumentos das funções e variáveis locais. segmento heap: armazena as variáveis dinâmicas Embora a imagem mostre varias seções ordenadas, não existe uma garantia que essa ordem sempre será a ordem na sua aplicação pois elas podem ser alocadas em qualquer ordem desejada. Em uma arquitetura baseada em Intel x86 (32 bits) temos os seguintes registradores de uso geral: EAX : acumulador : utilizado para realizar cálculos e para armazenar valores de retorno em chamadas de função. Operações básicas como adição, subtração e comparação utilizam este registrador EBX : base : Não há um propósito geral para este registrador, mas pode ser utilizado para armazenar dados ECX : contador : utilizado para interações/laços/loops. ECX conta de forma decrescente. EDX : data : ele é uma extensão para o EAX pois possibilita calculos mais complexos como multiplicação e divisão permitindo o armazenamento de dados extras para facilitar estes cálculos. ESP : ponteiro do topo da pilha (stack pointer) EBP : ponteiro da base da pilha (base pointer) ESI :  índice de origem (source index) : mantém a localização dos dados de entrada EDI : índice de destino (destination index) : mantém a localização onde o dado do resultado da operação é armazenado EIP : ponto de instrução (instruction pointer) : mantém o ponto de memória do código da próxima instrução Os registradores ESP, EBP e EIP são os mais interessantes e utilizados quando o assunto é Buffer Overflow. Conforme descrito acima e ilustrado na imagem abaixo, o registrador ESP aponta para o início do stack (menor endereço de memória) e o EBP para o final do stack (maior endereço de memória). E o EIP mantém o endereço da próxima instrução a ser executada, por isso, para que a aplicação execute o que desejamos nosso primeiro objetivo em um Buffer Overflow será controlar o EIP. [caption id=&quot;attachment_1831&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Stack Frame[/caption] Registradores Em uma arquitetura 32 bits todos os registradores de uso geral possuem 32 bits (4 bytes) de tamanho e em um código assembly podem ser referenciados como 32 ou 16 bits. Por exemplo o EAX é a referencia para 32 bits inteiro e AX é a referencia para 16 bits menores do registrador EAX. Quatro registradores (EAX, EBX, ECX e EDX) podem ser referenciado também com 8 bits, para 8 bits mais baixo ou o segundo 8 bits mais baixo, AL e AH respectivamente. A imagem abaixo visa demonstrar de forma gráfica essas diversas formas de utilização dos registradores. [caption id=&quot;attachment_1833&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Registradores[/caption] Pilha (stack) Segundo Foster, A pilha &quot;é uma área de memória usada para manter/armazenar dados temporários. A pilha cresce e reduz durante a execução da aplicação.&quot; e após a definição incrementa a informação onde &quot;Buffer Overflow comuns ocorrem na área de memória da pilha&quot; conceito este que veremos logo a seguir como funciona o Stack Buffer Overflow. A utilização primária da pilha é a troca de dados entre funções. A pilha tem uma arquitetura caracterizada por PUSHs e POPs em um modelo LIFO (last in, first out), ou seja, o ultimo dado a entrar na pilha será o primeiro a sair. Por exemplo, se você empilha (PUSH) os números 1, 2 e 3 nessa ordem, o primeiro número a ser desempilhado será o 3 pois ele foi o último a ser empilhado. Para alguns ataques mais avançados de Buffer Overflow é extremamente importante entender esse funcionamento e como a manipulação do ESP + a arquitetura LIFO funciona. Se você deseja acessar a pilha diretamente, isso é possível usando o registrador ESP (Stack Pointer), que por sua vez aponta para o top da pilha (menor endereço de memória). Após um PUSH, o ESP irá apontar para um endereço menor (o endereço será decrementado com o tamanho do dado que foi inserido na pilha, em caso de endereço ou ponteiro será 4 bytes) Depois de um POP, o ESP irá apontar para um endereço maior (o endereço será incrementado com o tamanho do dado que foi retirado da pilha, em caso de endereço ou ponteiro será 4 bytes) &nbsp; &nbsp; Stack Buffer Overflow Usando o trecho de código C abaixo [sourcecode language=&quot;c&quot;]#include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; void function1(char *str){ char buffer[5]; strcpy(buffer, str); } void main(int argc, char *argv[]) { function1(argv[1]); printf(&amp;quot;%s\n&amp;quot;, &amp;quot;Executed normally&amp;quot;); } [/sourcecode] Este código, bem simples por sinal, não faz muita coisa útil, mas é extremamente importante para entendermos os conceitos desejados. Após compilado a execução dessa aplicação, via linha de comando será:  overflowteste.exe AAAA Note que a função main resgata o primeiro parâmetro passado pela linha de comando (AAAA) e preenche como parâmetro da função function1, que por sua vez irá copiar este valor dentro da variável local que detém o tamanho máximo de 5 caracteres (bytes). Estes 5 bytes são teóricos, pois como essa variável é uma cadeia (array) de caracteres ela se utiliza de uma função de proteção que o C detém, essa função de proteção sempre adiciona ao final de uma string um caractere conhecido como nullbyte (0), que tem sua representação em hexa 0x00. O nullbyte tem a função de proteger a aplicação e é comumente utilizado nas operações com string para indicar para a aplicação que ali finalizou a string (cadeia de caracteres). Desta forma como a aplicação automaticamente adicionará o nullbyte ao final do nosso texto, teremos a quantidade de caracteres passadas por parâmetro mais o nullbyte, então se passarmos 5 As mais o nullbyte já teríamos uma condição de buffer overflow, pois a variável local só suporta 5 bytes e neste caso teríamos 6. Na linha 11 do código temos a chamada da função function1, sendo assim uma nova pilha será criada para essa função e teremos algo parecido com a imagem abaixo [caption id=&quot;attachment_1837&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Pilha (stack) após a chamada da função function1[/caption] &nbsp; Note que temos o ESP no topo da pilha, a pilha (que neste caso terá o conteúdo que foi passado para a função) depois a base da pilha (EBP) e por fim o endereço de retorno (EIP), que neste ambiente será o endereço de memória da linha 12 da nossa aplicação, ou seja, o endereço que será utilizado pela nossa aplicação depois que a function1 fizer todo o seu trabalho e a aplicação precisa seguir o fluxo de execução. Em uma execução da aplicação teremos o seguinte retorno: [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAA Executed normally [/sourcecode] Agora se executarmos a aplicação com um texto maior que 4 caracteres (conforme a linha de comando abaixo), iremos causar a falha na aplicação e teríamos algo similar a imagem abaixo [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [/sourcecode] [caption id=&quot;attachment_1840&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Memória depois do strcpy[/caption] Conforme podemos ver na imagem acima, estouramos o espaço de memória inicialmente atribuído para a variável local (5 bytes), de forma que substituímos diversas informações inclusive (e o mais importante) o endereço de retorno. Neste caso hipotético a aplicação tentará executar o endereço de memória 41414141 (a representação em hexadecimal dos 4 As) o que vai causar uma falha na aplicação pois o endereço de memória 41414141 não faz parte dessa aplicação causando então uma falha de segmentação (segmentation fault). Um alerta aos navegantes: Este é um exemplo básico de stack buffer overflow e sempre temos que tem em mente que até o momento não comentamos de algumas proteções de memória que o Windows em versões mais novas detém como: data execution prevention (DEP) e address space layout randomization (ASLR). Assuntos estes que serão abordados em posts futuros. Sendo assim quando forem brincar com isso use um Windows XP ou Windows Vista. Considerações finais Estes foram os conceitos básicos que quis trazer para vocês, espero que tenha sido claro e consistente nos assuntos, que de certa forma são novos e confusos para muitos. Segue o link do próximo post (Parte 1 - Stack Buffer Overflow), onde veremos na prática como realizar um Buffer Overflow. &nbsp; Fontes: https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/ Penetration Testing: A Hands-On Introduction to Hacking de Georgia Weidman Buffer Overflow Attacks: Detect, exploit, prevent de James C. Foster De forma complementar a este post segue um vídeo com a explicação dos conceitos base do Buffer Overflow:" /><meta property="og:description" content="Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow. Caso você deseje segue o link para a lista completa de posts sobre a criação de exploits e buffer overflow: https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/ Mas antes de começar a colocar a mão na massa, como sempre, precisamos de um pouco de teoria para embasar e entender todo o contexto, e como quando falamos de Buffer Overflow, falamos de memória, pilha, push pop, assembly e etc... nada é tão simples e tão trivial, então se posso dar uma recomendação é: leia e releia toda a teoria, busque outros sites, outros livros, outras referencias para complementar o seu conhecimento, pois isso será base para o sucesso ou falha no momento da criação dos seus exploits. Segue a referência de um site onde tem bastante conteúdo sobre este assunto: https://www.corelan.be Antes de mais nada, o que é Buffer Overflow? Weidman define Buffer Overflow como &quot;o processo pelo qual manipulamos a memória de uma aplicação de forma que preenchemos mais dados do que a aplicação esperava receber extrapolando o tamanho da variável no stack de memória e sobrepondo o espaço de memória adjacente&quot;. Se um pedaço de memória crítica for sobreposta a aplicação irá falhar/gerar uma exceção/erro. Com um pouco de técnica e cuidado podemos sobrepor partes importantes e controlar o fluxo de execução da aplicação após essa falha. Definição de ambiente Antes de mais nada é importante ressaltar que todos os procedimentos que explicarei nessa série de posts são baseados em Microsoft Windows com aplicação rodando em 32 bits. Arquitetura e Memória Antes de ir a fundo em Buffer Overflow e criação de Exploits certamente precisamos entender como a memória funciona, pois o princípio base de Buffer Overflow é a manipulação de memória. Nosso objetivo final sempre será manipular a memória de forma que aplicação execute o que vamos inserir nela. Quando se estuda a arquitetura de um ambiente computacional há uma sistema hierárquico de proteção conhecido como Protection Ring, basicamente isso é um mecanismo de proteção e tolerância a falhas dos sistemas. Em um ambiente Windows 32 bits o endereçamento de memória vai de 0x00000000 a 0xFFFFFFFF, onde se divide em duas faixas: a primeira que vai de 0x00000000 a 0x7FFFFFFF é atribuída ao Ring 3 - User-land, e a segunda vai de 0x80000000 a 0xFFFFFFFF que é atribuída ao Ring 0 - Kernel-land. O Endereçamento de memória dentro do kernel-land somente é acessível pelo Sistema Operacional. O Windows utiliza um modelo de endereçamento de memória conhecido como flat memory model, que basicamente indica que a memória aparece para as aplicações como um único espaço contínuo. A CPU pode diretamente (and linearmente) endereçar toda memória disponível sem a necessidade de utilizar segmentação/paginação de memória. Memória Primeiro precisamos entender um pouco mais como é a memória de um aplicativo, veja a imagem abaixo: [caption id=&quot;attachment_1826&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Visualização da memória[/caption] Cada aplicação utiliza parte da memória, a aplicação contém basicamente alguns segmentos de memória, conforme abaixo: segmento de código (text): código do programa a ser executado segmento data: informações globais da aplicação, estes dados são carregados no momento do início da aplicação, são estáticos (não mudam enquanto o programa está rodando) e estão disponíveis para a toda a aplicação segmento pilha (stack): tem tamanho fixo e é usado para armazenar argumentos das funções e variáveis locais. segmento heap: armazena as variáveis dinâmicas Embora a imagem mostre varias seções ordenadas, não existe uma garantia que essa ordem sempre será a ordem na sua aplicação pois elas podem ser alocadas em qualquer ordem desejada. Em uma arquitetura baseada em Intel x86 (32 bits) temos os seguintes registradores de uso geral: EAX : acumulador : utilizado para realizar cálculos e para armazenar valores de retorno em chamadas de função. Operações básicas como adição, subtração e comparação utilizam este registrador EBX : base : Não há um propósito geral para este registrador, mas pode ser utilizado para armazenar dados ECX : contador : utilizado para interações/laços/loops. ECX conta de forma decrescente. EDX : data : ele é uma extensão para o EAX pois possibilita calculos mais complexos como multiplicação e divisão permitindo o armazenamento de dados extras para facilitar estes cálculos. ESP : ponteiro do topo da pilha (stack pointer) EBP : ponteiro da base da pilha (base pointer) ESI :  índice de origem (source index) : mantém a localização dos dados de entrada EDI : índice de destino (destination index) : mantém a localização onde o dado do resultado da operação é armazenado EIP : ponto de instrução (instruction pointer) : mantém o ponto de memória do código da próxima instrução Os registradores ESP, EBP e EIP são os mais interessantes e utilizados quando o assunto é Buffer Overflow. Conforme descrito acima e ilustrado na imagem abaixo, o registrador ESP aponta para o início do stack (menor endereço de memória) e o EBP para o final do stack (maior endereço de memória). E o EIP mantém o endereço da próxima instrução a ser executada, por isso, para que a aplicação execute o que desejamos nosso primeiro objetivo em um Buffer Overflow será controlar o EIP. [caption id=&quot;attachment_1831&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Stack Frame[/caption] Registradores Em uma arquitetura 32 bits todos os registradores de uso geral possuem 32 bits (4 bytes) de tamanho e em um código assembly podem ser referenciados como 32 ou 16 bits. Por exemplo o EAX é a referencia para 32 bits inteiro e AX é a referencia para 16 bits menores do registrador EAX. Quatro registradores (EAX, EBX, ECX e EDX) podem ser referenciado também com 8 bits, para 8 bits mais baixo ou o segundo 8 bits mais baixo, AL e AH respectivamente. A imagem abaixo visa demonstrar de forma gráfica essas diversas formas de utilização dos registradores. [caption id=&quot;attachment_1833&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Registradores[/caption] Pilha (stack) Segundo Foster, A pilha &quot;é uma área de memória usada para manter/armazenar dados temporários. A pilha cresce e reduz durante a execução da aplicação.&quot; e após a definição incrementa a informação onde &quot;Buffer Overflow comuns ocorrem na área de memória da pilha&quot; conceito este que veremos logo a seguir como funciona o Stack Buffer Overflow. A utilização primária da pilha é a troca de dados entre funções. A pilha tem uma arquitetura caracterizada por PUSHs e POPs em um modelo LIFO (last in, first out), ou seja, o ultimo dado a entrar na pilha será o primeiro a sair. Por exemplo, se você empilha (PUSH) os números 1, 2 e 3 nessa ordem, o primeiro número a ser desempilhado será o 3 pois ele foi o último a ser empilhado. Para alguns ataques mais avançados de Buffer Overflow é extremamente importante entender esse funcionamento e como a manipulação do ESP + a arquitetura LIFO funciona. Se você deseja acessar a pilha diretamente, isso é possível usando o registrador ESP (Stack Pointer), que por sua vez aponta para o top da pilha (menor endereço de memória). Após um PUSH, o ESP irá apontar para um endereço menor (o endereço será decrementado com o tamanho do dado que foi inserido na pilha, em caso de endereço ou ponteiro será 4 bytes) Depois de um POP, o ESP irá apontar para um endereço maior (o endereço será incrementado com o tamanho do dado que foi retirado da pilha, em caso de endereço ou ponteiro será 4 bytes) &nbsp; &nbsp; Stack Buffer Overflow Usando o trecho de código C abaixo [sourcecode language=&quot;c&quot;]#include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; void function1(char *str){ char buffer[5]; strcpy(buffer, str); } void main(int argc, char *argv[]) { function1(argv[1]); printf(&amp;quot;%s\n&amp;quot;, &amp;quot;Executed normally&amp;quot;); } [/sourcecode] Este código, bem simples por sinal, não faz muita coisa útil, mas é extremamente importante para entendermos os conceitos desejados. Após compilado a execução dessa aplicação, via linha de comando será:  overflowteste.exe AAAA Note que a função main resgata o primeiro parâmetro passado pela linha de comando (AAAA) e preenche como parâmetro da função function1, que por sua vez irá copiar este valor dentro da variável local que detém o tamanho máximo de 5 caracteres (bytes). Estes 5 bytes são teóricos, pois como essa variável é uma cadeia (array) de caracteres ela se utiliza de uma função de proteção que o C detém, essa função de proteção sempre adiciona ao final de uma string um caractere conhecido como nullbyte (0), que tem sua representação em hexa 0x00. O nullbyte tem a função de proteger a aplicação e é comumente utilizado nas operações com string para indicar para a aplicação que ali finalizou a string (cadeia de caracteres). Desta forma como a aplicação automaticamente adicionará o nullbyte ao final do nosso texto, teremos a quantidade de caracteres passadas por parâmetro mais o nullbyte, então se passarmos 5 As mais o nullbyte já teríamos uma condição de buffer overflow, pois a variável local só suporta 5 bytes e neste caso teríamos 6. Na linha 11 do código temos a chamada da função function1, sendo assim uma nova pilha será criada para essa função e teremos algo parecido com a imagem abaixo [caption id=&quot;attachment_1837&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Pilha (stack) após a chamada da função function1[/caption] &nbsp; Note que temos o ESP no topo da pilha, a pilha (que neste caso terá o conteúdo que foi passado para a função) depois a base da pilha (EBP) e por fim o endereço de retorno (EIP), que neste ambiente será o endereço de memória da linha 12 da nossa aplicação, ou seja, o endereço que será utilizado pela nossa aplicação depois que a function1 fizer todo o seu trabalho e a aplicação precisa seguir o fluxo de execução. Em uma execução da aplicação teremos o seguinte retorno: [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAA Executed normally [/sourcecode] Agora se executarmos a aplicação com um texto maior que 4 caracteres (conforme a linha de comando abaixo), iremos causar a falha na aplicação e teríamos algo similar a imagem abaixo [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [/sourcecode] [caption id=&quot;attachment_1840&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Memória depois do strcpy[/caption] Conforme podemos ver na imagem acima, estouramos o espaço de memória inicialmente atribuído para a variável local (5 bytes), de forma que substituímos diversas informações inclusive (e o mais importante) o endereço de retorno. Neste caso hipotético a aplicação tentará executar o endereço de memória 41414141 (a representação em hexadecimal dos 4 As) o que vai causar uma falha na aplicação pois o endereço de memória 41414141 não faz parte dessa aplicação causando então uma falha de segmentação (segmentation fault). Um alerta aos navegantes: Este é um exemplo básico de stack buffer overflow e sempre temos que tem em mente que até o momento não comentamos de algumas proteções de memória que o Windows em versões mais novas detém como: data execution prevention (DEP) e address space layout randomization (ASLR). Assuntos estes que serão abordados em posts futuros. Sendo assim quando forem brincar com isso use um Windows XP ou Windows Vista. Considerações finais Estes foram os conceitos básicos que quis trazer para vocês, espero que tenha sido claro e consistente nos assuntos, que de certa forma são novos e confusos para muitos. Segue o link do próximo post (Parte 1 - Stack Buffer Overflow), onde veremos na prática como realizar um Buffer Overflow. &nbsp; Fontes: https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/ Penetration Testing: A Hands-On Introduction to Hacking de Georgia Weidman Buffer Overflow Attacks: Detect, exploit, prevent de James C. Foster De forma complementar a este post segue um vídeo com a explicação dos conceitos base do Buffer Overflow:" /><link rel="canonical" href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-09-30T17:45:47-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Criação de Exploits - Parte 0 - Um pouco de teoria" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2018-09-30T17:45:47-03:00","description":"Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow. Caso você deseje segue o link para a lista completa de posts sobre a criação de exploits e buffer overflow: https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/ Mas antes de começar a colocar a mão na massa, como sempre, precisamos de um pouco de teoria para embasar e entender todo o contexto, e como quando falamos de Buffer Overflow, falamos de memória, pilha, push pop, assembly e etc... nada é tão simples e tão trivial, então se posso dar uma recomendação é: leia e releia toda a teoria, busque outros sites, outros livros, outras referencias para complementar o seu conhecimento, pois isso será base para o sucesso ou falha no momento da criação dos seus exploits. Segue a referência de um site onde tem bastante conteúdo sobre este assunto: https://www.corelan.be Antes de mais nada, o que é Buffer Overflow? Weidman define Buffer Overflow como &quot;o processo pelo qual manipulamos a memória de uma aplicação de forma que preenchemos mais dados do que a aplicação esperava receber extrapolando o tamanho da variável no stack de memória e sobrepondo o espaço de memória adjacente&quot;. Se um pedaço de memória crítica for sobreposta a aplicação irá falhar/gerar uma exceção/erro. Com um pouco de técnica e cuidado podemos sobrepor partes importantes e controlar o fluxo de execução da aplicação após essa falha. Definição de ambiente Antes de mais nada é importante ressaltar que todos os procedimentos que explicarei nessa série de posts são baseados em Microsoft Windows com aplicação rodando em 32 bits. Arquitetura e Memória Antes de ir a fundo em Buffer Overflow e criação de Exploits certamente precisamos entender como a memória funciona, pois o princípio base de Buffer Overflow é a manipulação de memória. Nosso objetivo final sempre será manipular a memória de forma que aplicação execute o que vamos inserir nela. Quando se estuda a arquitetura de um ambiente computacional há uma sistema hierárquico de proteção conhecido como Protection Ring, basicamente isso é um mecanismo de proteção e tolerância a falhas dos sistemas. Em um ambiente Windows 32 bits o endereçamento de memória vai de 0x00000000 a 0xFFFFFFFF, onde se divide em duas faixas: a primeira que vai de 0x00000000 a 0x7FFFFFFF é atribuída ao Ring 3 - User-land, e a segunda vai de 0x80000000 a 0xFFFFFFFF que é atribuída ao Ring 0 - Kernel-land. O Endereçamento de memória dentro do kernel-land somente é acessível pelo Sistema Operacional. O Windows utiliza um modelo de endereçamento de memória conhecido como flat memory model, que basicamente indica que a memória aparece para as aplicações como um único espaço contínuo. A CPU pode diretamente (and linearmente) endereçar toda memória disponível sem a necessidade de utilizar segmentação/paginação de memória. Memória Primeiro precisamos entender um pouco mais como é a memória de um aplicativo, veja a imagem abaixo: [caption id=&quot;attachment_1826&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Visualização da memória[/caption] Cada aplicação utiliza parte da memória, a aplicação contém basicamente alguns segmentos de memória, conforme abaixo: segmento de código (text): código do programa a ser executado segmento data: informações globais da aplicação, estes dados são carregados no momento do início da aplicação, são estáticos (não mudam enquanto o programa está rodando) e estão disponíveis para a toda a aplicação segmento pilha (stack): tem tamanho fixo e é usado para armazenar argumentos das funções e variáveis locais. segmento heap: armazena as variáveis dinâmicas Embora a imagem mostre varias seções ordenadas, não existe uma garantia que essa ordem sempre será a ordem na sua aplicação pois elas podem ser alocadas em qualquer ordem desejada. Em uma arquitetura baseada em Intel x86 (32 bits) temos os seguintes registradores de uso geral: EAX : acumulador : utilizado para realizar cálculos e para armazenar valores de retorno em chamadas de função. Operações básicas como adição, subtração e comparação utilizam este registrador EBX : base : Não há um propósito geral para este registrador, mas pode ser utilizado para armazenar dados ECX : contador : utilizado para interações/laços/loops. ECX conta de forma decrescente. EDX : data : ele é uma extensão para o EAX pois possibilita calculos mais complexos como multiplicação e divisão permitindo o armazenamento de dados extras para facilitar estes cálculos. ESP : ponteiro do topo da pilha (stack pointer) EBP : ponteiro da base da pilha (base pointer) ESI :  índice de origem (source index) : mantém a localização dos dados de entrada EDI : índice de destino (destination index) : mantém a localização onde o dado do resultado da operação é armazenado EIP : ponto de instrução (instruction pointer) : mantém o ponto de memória do código da próxima instrução Os registradores ESP, EBP e EIP são os mais interessantes e utilizados quando o assunto é Buffer Overflow. Conforme descrito acima e ilustrado na imagem abaixo, o registrador ESP aponta para o início do stack (menor endereço de memória) e o EBP para o final do stack (maior endereço de memória). E o EIP mantém o endereço da próxima instrução a ser executada, por isso, para que a aplicação execute o que desejamos nosso primeiro objetivo em um Buffer Overflow será controlar o EIP. [caption id=&quot;attachment_1831&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Stack Frame[/caption] Registradores Em uma arquitetura 32 bits todos os registradores de uso geral possuem 32 bits (4 bytes) de tamanho e em um código assembly podem ser referenciados como 32 ou 16 bits. Por exemplo o EAX é a referencia para 32 bits inteiro e AX é a referencia para 16 bits menores do registrador EAX. Quatro registradores (EAX, EBX, ECX e EDX) podem ser referenciado também com 8 bits, para 8 bits mais baixo ou o segundo 8 bits mais baixo, AL e AH respectivamente. A imagem abaixo visa demonstrar de forma gráfica essas diversas formas de utilização dos registradores. [caption id=&quot;attachment_1833&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Registradores[/caption] Pilha (stack) Segundo Foster, A pilha &quot;é uma área de memória usada para manter/armazenar dados temporários. A pilha cresce e reduz durante a execução da aplicação.&quot; e após a definição incrementa a informação onde &quot;Buffer Overflow comuns ocorrem na área de memória da pilha&quot; conceito este que veremos logo a seguir como funciona o Stack Buffer Overflow. A utilização primária da pilha é a troca de dados entre funções. A pilha tem uma arquitetura caracterizada por PUSHs e POPs em um modelo LIFO (last in, first out), ou seja, o ultimo dado a entrar na pilha será o primeiro a sair. Por exemplo, se você empilha (PUSH) os números 1, 2 e 3 nessa ordem, o primeiro número a ser desempilhado será o 3 pois ele foi o último a ser empilhado. Para alguns ataques mais avançados de Buffer Overflow é extremamente importante entender esse funcionamento e como a manipulação do ESP + a arquitetura LIFO funciona. Se você deseja acessar a pilha diretamente, isso é possível usando o registrador ESP (Stack Pointer), que por sua vez aponta para o top da pilha (menor endereço de memória). Após um PUSH, o ESP irá apontar para um endereço menor (o endereço será decrementado com o tamanho do dado que foi inserido na pilha, em caso de endereço ou ponteiro será 4 bytes) Depois de um POP, o ESP irá apontar para um endereço maior (o endereço será incrementado com o tamanho do dado que foi retirado da pilha, em caso de endereço ou ponteiro será 4 bytes) &nbsp; &nbsp; Stack Buffer Overflow Usando o trecho de código C abaixo [sourcecode language=&quot;c&quot;]#include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; void function1(char *str){ char buffer[5]; strcpy(buffer, str); } void main(int argc, char *argv[]) { function1(argv[1]); printf(&amp;quot;%s\\n&amp;quot;, &amp;quot;Executed normally&amp;quot;); } [/sourcecode] Este código, bem simples por sinal, não faz muita coisa útil, mas é extremamente importante para entendermos os conceitos desejados. Após compilado a execução dessa aplicação, via linha de comando será:  overflowteste.exe AAAA Note que a função main resgata o primeiro parâmetro passado pela linha de comando (AAAA) e preenche como parâmetro da função function1, que por sua vez irá copiar este valor dentro da variável local que detém o tamanho máximo de 5 caracteres (bytes). Estes 5 bytes são teóricos, pois como essa variável é uma cadeia (array) de caracteres ela se utiliza de uma função de proteção que o C detém, essa função de proteção sempre adiciona ao final de uma string um caractere conhecido como nullbyte (0), que tem sua representação em hexa 0x00. O nullbyte tem a função de proteger a aplicação e é comumente utilizado nas operações com string para indicar para a aplicação que ali finalizou a string (cadeia de caracteres). Desta forma como a aplicação automaticamente adicionará o nullbyte ao final do nosso texto, teremos a quantidade de caracteres passadas por parâmetro mais o nullbyte, então se passarmos 5 As mais o nullbyte já teríamos uma condição de buffer overflow, pois a variável local só suporta 5 bytes e neste caso teríamos 6. Na linha 11 do código temos a chamada da função function1, sendo assim uma nova pilha será criada para essa função e teremos algo parecido com a imagem abaixo [caption id=&quot;attachment_1837&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Pilha (stack) após a chamada da função function1[/caption] &nbsp; Note que temos o ESP no topo da pilha, a pilha (que neste caso terá o conteúdo que foi passado para a função) depois a base da pilha (EBP) e por fim o endereço de retorno (EIP), que neste ambiente será o endereço de memória da linha 12 da nossa aplicação, ou seja, o endereço que será utilizado pela nossa aplicação depois que a function1 fizer todo o seu trabalho e a aplicação precisa seguir o fluxo de execução. Em uma execução da aplicação teremos o seguinte retorno: [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAA Executed normally [/sourcecode] Agora se executarmos a aplicação com um texto maior que 4 caracteres (conforme a linha de comando abaixo), iremos causar a falha na aplicação e teríamos algo similar a imagem abaixo [sourcecode language=&quot;bash&quot;]overflowtest.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [/sourcecode] [caption id=&quot;attachment_1840&quot; align=&quot;alignnone&quot; width=&quot;300&quot;] Memória depois do strcpy[/caption] Conforme podemos ver na imagem acima, estouramos o espaço de memória inicialmente atribuído para a variável local (5 bytes), de forma que substituímos diversas informações inclusive (e o mais importante) o endereço de retorno. Neste caso hipotético a aplicação tentará executar o endereço de memória 41414141 (a representação em hexadecimal dos 4 As) o que vai causar uma falha na aplicação pois o endereço de memória 41414141 não faz parte dessa aplicação causando então uma falha de segmentação (segmentation fault). Um alerta aos navegantes: Este é um exemplo básico de stack buffer overflow e sempre temos que tem em mente que até o momento não comentamos de algumas proteções de memória que o Windows em versões mais novas detém como: data execution prevention (DEP) e address space layout randomization (ASLR). Assuntos estes que serão abordados em posts futuros. Sendo assim quando forem brincar com isso use um Windows XP ou Windows Vista. Considerações finais Estes foram os conceitos básicos que quis trazer para vocês, espero que tenha sido claro e consistente nos assuntos, que de certa forma são novos e confusos para muitos. Segue o link do próximo post (Parte 1 - Stack Buffer Overflow), onde veremos na prática como realizar um Buffer Overflow. &nbsp; Fontes: https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/ Penetration Testing: A Hands-On Introduction to Hacking de Georgia Weidman Buffer Overflow Attacks: Detect, exploit, prevent de James C. Foster De forma complementar a este post segue um vídeo com a explicação dos conceitos base do Buffer Overflow:","headline":"Criação de Exploits - Parte 0 - Um pouco de teoria","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/"},"url":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/"}</script><title>Criação de Exploits - Parte 0 - Um pouco de teoria | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span> <a href="/criacao-de-exploits"> Criacao-de-exploits </a> </span> <span>Criação de Exploits - Parte 0 - Um pouco de teoria</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Criação de Exploits - Parte 0 - Um pouco de teoria</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Sep 30, 2018, 5:45 PM -0300" prep="on" > Sep 30, 2018 <i class="unloaded">2018-09-30T17:45:47-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1899 words">10 min</span></div></div><div class="post-content"><p>Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow.</p><p>Caso você deseje segue o link para a lista completa de posts sobre a criação de exploits e buffer overflow: <a href="https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/">https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/</a></p><p>Mas antes de começar a colocar a mão na massa, como sempre, precisamos de um pouco de teoria para embasar e entender todo o contexto, e como quando falamos de Buffer Overflow, falamos de memória, pilha, push pop, assembly e etc... nada é tão simples e tão trivial, então se posso dar uma recomendação é: leia e releia toda a teoria, busque outros sites, outros livros, outras referencias para complementar o seu conhecimento, pois isso será base para o sucesso ou falha no momento da criação dos seus exploits.</p><p>Segue a referência de um site onde tem bastante conteúdo sobre este assunto: <a href="https://www.corelan.be">https://www.corelan.be</a></p><p></p><h2>Antes de mais nada, o que é Buffer Overflow?</h2><p><em>Weidman</em> define<em> Buffer Overflow </em>como "o processo pelo qual manipulamos a memória de uma aplicação de forma que preenchemos mais dados do que a aplicação esperava receber extrapolando o tamanho da variável no stack de memória e sobrepondo o espaço de memória adjacente". Se um pedaço de memória crítica for sobreposta a aplicação irá falhar/gerar uma exceção/erro. Com um pouco de técnica e cuidado podemos sobrepor partes importantes e controlar o fluxo de execução da aplicação após essa falha.</p><h2></h2><h2>Definição de ambiente</h2><p>Antes de mais nada é importante ressaltar que todos os procedimentos que explicarei nessa série de posts são baseados em Microsoft Windows com aplicação rodando em 32 bits.</p><h2></h2><h2>Arquitetura e Memória</h2><p>Antes de ir a fundo em Buffer Overflow e criação de Exploits certamente precisamos entender como a memória funciona, pois o princípio base de Buffer Overflow é a manipulação de memória. Nosso objetivo final sempre será manipular a memória de forma que aplicação execute o que vamos inserir nela.</p><p>Quando se estuda a arquitetura de um ambiente computacional há uma sistema hierárquico de proteção conhecido como <a href="https://en.wikipedia.org/wiki/Protection_ring">Protection Ring</a>, basicamente isso é um mecanismo de proteção e tolerância a falhas dos sistemas. Em um ambiente Windows 32 bits o endereçamento de memória vai de 0x00000000 a 0xFFFFFFFF, onde se divide em duas faixas: a primeira que vai de 0x00000000 a 0x7FFFFFFF é atribuída ao Ring 3 - User-land, e a segunda vai de 0x80000000 a 0xFFFFFFFF que é atribuída ao Ring 0 - Kernel-land. O Endereçamento de memória dentro do kernel-land somente é acessível pelo Sistema Operacional.</p><p>O Windows utiliza um modelo de endereçamento de memória conhecido como <a href="http://en.wikipedia.org/wiki/Flat_memory_model" target="_blank" rel="noopener">flat memory model</a>, que basicamente indica que a memória aparece para as aplicações como um único espaço contínuo. A CPU pode diretamente (and linearmente) endereçar toda memória disponível sem a necessidade de utilizar segmentação/paginação de memória.</p><h2></h2><h2>Memória</h2><p>Primeiro precisamos entender um pouco mais como é a memória de um aplicativo, veja a imagem abaixo:</p><p>[caption id="attachment_1826" align="alignnone" width="300"]<a href="/assets/2018/09/001-memory_visualization.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 258'%3E%3C/svg%3E" data-src="/assets/2018/09/001-memory_visualization-300x258.png" alt="" width="300" height="258" class="lazyload" data-proofer-ignore></a> Visualização da memória[/caption]</p><p>Cada aplicação utiliza parte da memória, a aplicação contém basicamente alguns segmentos de memória, conforme abaixo:</p><ul><li>segmento de código (text): código do programa a ser executado<li>segmento data: informações globais da aplicação, estes dados são carregados no momento do início da aplicação, são estáticos (não mudam enquanto o programa está rodando) e estão disponíveis para a toda a aplicação<li>segmento pilha (stack): tem tamanho fixo e é usado para armazenar argumentos das funções e variáveis locais.<li>segmento heap: armazena as variáveis dinâmicas</ul><p>Embora a imagem mostre varias seções ordenadas, não existe uma garantia que essa ordem sempre será a ordem na sua aplicação pois elas podem ser alocadas em qualquer ordem desejada.</p><p>Em uma arquitetura baseada em Intel x86 (32 bits) temos os seguintes registradores de uso geral:</p><ul><li><strong>EAX</strong> : acumulador : utilizado para realizar cálculos e para armazenar valores de retorno em chamadas de função. Operações básicas como adição, subtração e comparação utilizam este registrador<li><strong>EBX</strong> : base : Não há um propósito geral para este registrador, mas pode ser utilizado para armazenar dados<li><strong>ECX</strong> : contador : utilizado para interações/laços/loops. ECX conta de forma decrescente.<li><strong>EDX</strong> : data : ele é uma extensão para o EAX pois possibilita calculos mais complexos como multiplicação e divisão permitindo o armazenamento de dados extras para facilitar estes cálculos.<li><strong>ESP</strong> : ponteiro do topo da pilha (stack pointer)<li><strong>EBP</strong> : ponteiro da base da pilha (base pointer)<li><strong>ESI</strong> :  índice de origem (source index) : mantém a localização dos dados de entrada<li><strong>EDI</strong> : índice de destino (destination index) : mantém a localização onde o dado do resultado da operação é armazenado<li><strong>EIP</strong> : ponto de instrução (instruction pointer) : mantém o ponto de memória do código da próxima instrução</ul><p>Os registradores ESP, EBP e EIP são os mais interessantes e utilizados quando o assunto é<em> Buffer Overflow</em>. Conforme descrito acima e ilustrado na imagem abaixo, o registrador ESP aponta para o início do stack (menor endereço de memória) e o EBP para o final do stack (maior endereço de memória). E o EIP mantém o endereço da próxima instrução a ser executada, por isso, para que a aplicação execute o que desejamos nosso primeiro objetivo em um <em>Buffer Overflow</em> será controlar o EIP.</p><p>[caption id="attachment_1831" align="alignnone" width="300"]<a href="/assets/2018/09/001-stack_frame.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 145'%3E%3C/svg%3E" data-src="/assets/2018/09/001-stack_frame-300x145.png" alt="" width="300" height="145" class="lazyload" data-proofer-ignore></a> Stack Frame[/caption]</p><h2></h2><h2>Registradores</h2><p>Em uma arquitetura 32 bits todos os registradores de uso geral possuem 32 bits (4 bytes) de tamanho e em um código assembly podem ser referenciados como 32 ou 16 bits. Por exemplo o EAX é a referencia para 32 bits inteiro e AX é a referencia para 16 bits menores do registrador EAX.</p><p>Quatro registradores (EAX, EBX, ECX e EDX) podem ser referenciado também com 8 bits, para 8 bits mais baixo ou o segundo 8 bits mais baixo, AL e AH respectivamente. A imagem abaixo visa demonstrar de forma gráfica essas diversas formas de utilização dos registradores.</p><p>[caption id="attachment_1833" align="alignnone" width="300"]<a href="/assets/2018/09/003-registradores.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 211'%3E%3C/svg%3E" data-src="/assets/2018/09/003-registradores-300x211.png" alt="" width="300" height="211" class="lazyload" data-proofer-ignore></a> Registradores[/caption]</p><h2></h2><h2>Pilha (stack)</h2><p>Segundo <em>Foster</em>, A pilha "é uma área de memória usada para manter/armazenar dados temporários. A pilha cresce e reduz durante a execução da aplicação." e após a definição incrementa a informação onde "<em>Buffer Overflow</em> comuns ocorrem na área de memória da pilha" conceito este que veremos logo a seguir como funciona o <em>Stack Buffer Overflow</em>.</p><p>A utilização primária da pilha é a troca de dados entre funções. A pilha tem uma arquitetura caracterizada por PUSHs e POPs em um modelo LIFO (last in, first out), ou seja, o ultimo dado a entrar na pilha será o primeiro a sair. Por exemplo, se você empilha (PUSH) os números 1, 2 e 3 nessa ordem, o primeiro número a ser desempilhado será o 3 pois ele foi o último a ser empilhado.</p><p>Para alguns ataques mais avançados de Buffer Overflow é extremamente importante entender esse funcionamento e como a manipulação do ESP + a arquitetura LIFO funciona. Se você deseja acessar a pilha diretamente, isso é possível usando o registrador ESP (Stack Pointer), que por sua vez aponta para o top da pilha (menor endereço de memória).</p><ul><li>Após um PUSH, o ESP irá apontar para um endereço menor (o endereço será decrementado com o tamanho do dado que foi inserido na pilha, em caso de endereço ou ponteiro será 4 bytes)<li>Depois de um POP, o ESP irá apontar para um endereço maior (o endereço será incrementado com o tamanho do dado que foi retirado da pilha, em caso de endereço ou ponteiro será 4 bytes)</ul><p>&nbsp;</p><p>&nbsp;</p><h2>Stack Buffer Overflow</h2><p>Usando o trecho de código C abaixo</p><p>[sourcecode language="c"]#include &amp;lt;string.h&amp;gt;<br /> #include &amp;lt;stdio.h&amp;gt;</p><p>void function1(char *str){<br /> char buffer[5];<br /> strcpy(buffer, str);<br /> }</p><p>void main(int argc, char *argv[])<br /> {<br /> function1(argv[1]);<br /> printf(&amp;quot;%s\n&amp;quot;, &amp;quot;Executed normally&amp;quot;);<br /> }<br /> [/sourcecode]</p><p>Este código, bem simples por sinal, não faz muita coisa útil, mas é extremamente importante para entendermos os conceitos desejados.</p><p>Após compilado a execução dessa aplicação, via linha de comando será:  <strong>overflowteste.exe AAAA</strong></p><p>Note que a função <em>main</em> resgata o primeiro parâmetro passado pela linha de comando (AAAA) e preenche como parâmetro da função <em>function1,</em> que por sua vez irá copiar este valor dentro da variável local que detém o tamanho máximo de 5 caracteres (bytes).</p><blockquote><p>Estes 5 bytes são teóricos, pois como essa variável é uma cadeia (array) de caracteres ela se utiliza de uma função de proteção que o C detém, essa função de proteção sempre adiciona ao final de uma string um caractere conhecido como nullbyte (0), que tem sua representação em hexa 0x00. O nullbyte tem a função de proteger a aplicação e é comumente utilizado nas operações com string para indicar para a aplicação que ali finalizou a string (cadeia de caracteres). Desta forma como a aplicação automaticamente adicionará o nullbyte ao final do nosso texto, teremos a quantidade de caracteres passadas por parâmetro mais o nullbyte, então se passarmos 5 As mais o nullbyte já teríamos uma condição de buffer overflow, pois a variável local só suporta 5 bytes e neste caso teríamos 6.</p></blockquote><p>Na linha 11 do código temos a chamada da função <em>function1</em>, sendo assim uma nova pilha será criada para essa função e teremos algo parecido com a imagem abaixo</p><p>[caption id="attachment_1837" align="alignnone" width="300"]<a href="/assets/2018/09/004-stack-after-call-to-function1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 250'%3E%3C/svg%3E" data-src="/assets/2018/09/004-stack-after-call-to-function1-300x250.png" alt="" width="300" height="250" class="lazyload" data-proofer-ignore></a> Pilha (stack) após a chamada da função function1[/caption]</p><p>&nbsp;</p><p>Note que temos o ESP no topo da pilha, a pilha (que neste caso terá o conteúdo que foi passado para a função) depois a base da pilha (EBP) e por fim o endereço de retorno (EIP), que neste ambiente será o endereço de memória da linha 12 da nossa aplicação, ou seja, o endereço que será utilizado pela nossa aplicação depois que a function1 fizer todo o seu trabalho e a aplicação precisa seguir o fluxo de execução.</p><p>Em uma execução da aplicação teremos o seguinte retorno:</p><p>[sourcecode language="bash"]overflowtest.exe AAAA<br /> Executed normally<br /> [/sourcecode]</p><p>Agora se executarmos a aplicação com um texto maior que 4 caracteres (conforme a linha de comando abaixo), iremos causar a falha na aplicação e teríamos algo similar a imagem abaixo</p><p>[sourcecode language="bash"]overflowtest.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br /> [/sourcecode]</p><p>[caption id="attachment_1840" align="alignnone" width="300"]<a href="/assets/2018/09/005-memory-after-overflow.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 247'%3E%3C/svg%3E" data-src="/assets/2018/09/005-memory-after-overflow-300x247.png" alt="" width="300" height="247" class="lazyload" data-proofer-ignore></a> Memória depois do strcpy[/caption]</p><p>Conforme podemos ver na imagem acima, estouramos o espaço de memória inicialmente atribuído para a variável local (5 bytes), de forma que substituímos diversas informações inclusive (e o mais importante) o endereço de retorno. Neste caso hipotético a aplicação tentará executar o endereço de memória 41414141 (a representação em hexadecimal dos 4 As) o que vai causar uma falha na aplicação pois o endereço de memória 41414141 não faz parte dessa aplicação causando então uma falha de segmentação (segmentation fault).</p><blockquote><p>Um alerta aos navegantes: Este é um exemplo básico de stack buffer overflow e sempre temos que tem em mente que até o momento não comentamos de algumas proteções de memória que o Windows em versões mais novas detém como: <em>data execution prevention</em> (DEP) e <em>address space layout randomization</em> (ASLR). Assuntos estes que serão abordados em posts futuros. Sendo assim quando forem brincar com isso use um Windows XP ou Windows Vista.</p></blockquote><h2></h2><h2>Considerações finais</h2><p>Estes foram os conceitos básicos que quis trazer para vocês, espero que tenha sido claro e consistente nos assuntos, que de certa forma são novos e confusos para muitos.</p><p>Segue o link do próximo post (<a href="https://www.helviojunior.com.br/it/criacao-de-exploits-parte-1-stack-buffer-overflow/" target="_blank" rel="noopener">Parte 1 - Stack Buffer Overflow</a>), onde veremos na prática como realizar um Buffer Overflow.</p><p>&nbsp;</p><h3>Fontes:</h3><ol><li><a href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/">https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/</a><li>Penetration Testing: A Hands-On Introduction to Hacking de Georgia Weidman<li>Buffer Overflow Attacks: Detect, exploit, prevent de James C. Foster</ol><p>De forma complementar a este post segue um vídeo com a explicação dos conceitos base do Buffer Overflow:<br /> <iframe width="560" height="315" src="https://www.youtube.com/embed/wLi-dGphpdg?controls=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cria%C3%A7%C3%A3o-de-exploits/'>Criação de Exploits</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Criação de Exploits - Parte 0 - Um pouco de teoria - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Criação de Exploits - Parte 0 - Um pouco de teoria - Helvio Junior&u=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Criação de Exploits - Parte 0 - Um pouco de teoria - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"><div class="card-body"> <span class="timeago small" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</h3><div class="text-muted small"><p> Introdução Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicaçã...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/como-realizar-stack-buffer-overflow/"><div class="card-body"> <span class="timeago small" > Sep 30, 2018 <i class="unloaded">2018-09-30T23:11:59-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 1 - Como realizar um Stack buffer overflow?</h3><div class="text-muted small"><p> Este post faz parte da série de criação de exploits, este é o segundo post dessa série, caso não tenha visto de uma olhada primeiramente na Parte 0 - Um pouco de teoria Segue abaixo os vídeos de d...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-2-removendo-bad-chars-usando-immunity-debugger-e-mona/"><div class="card-body"> <span class="timeago small" > Feb 3, 2019 <i class="unloaded">2019-02-03T15:34:32-02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 2 - Removendo bad chars usando Immunity Debugger e Mona</h3><div class="text-muted small"><p> Este post faz parte da série de criação de exploits, este é o terceiro post dessa série, caso não tenha visto de uma olhada primeiramente na Parte 0 - Um pouco de teoria Como ninguém é uma ilha e n...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/minha-experiencia-no-oscp/" class="btn btn-outline-primary" prompt="Older"><p>Minha experiência no OSCP</p></a> <a href="/it/security/criacao-de-exploits/como-realizar-stack-buffer-overflow/" class="btn btn-outline-primary" prompt="Newer"><p>Criação de Exploits - Parte 1 - Como realizar um Stack buffer overflow?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Criação de Exploits - Parte 0 - Um pouco de teoria'; this.page.url = 'https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/'; this.page.identifier = '/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
