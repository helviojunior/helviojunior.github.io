<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicação." /><meta property="og:description" content="Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicação." /><link rel="canonical" href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" /><meta property="og:url" content="https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-15T16:26:52-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-12-15T12:13:17-03:00","datePublished":"2021-08-15T16:26:52-03:00","description":"Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicação.","headline":"Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"},"url":"https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"}</script><title>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span> <a href="/criacao-de-exploits"> Criacao-de-exploits </a> </span> <span>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 15, 2021, 4:26 PM -0300" prep="on" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Dec 15, 2023, 12:13 PM -0300" prefix="Updated " > Dec 15, 2023 <i class="unloaded">2023-12-15T12:13:17-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5878 words">32 min</span></div></div><div class="post-content"><h2 id="introdução"><span class="me-2">Introdução</span><a href="#introdução" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicação.</p><p>Porém, antes de entrarmos efetivamente no assunto deste post é interessante conceituar algumas coisas: A primeira delas é sobre o termo Shellcoding.</p><p>Shellcoding é um termo muito utilizado para designar um código escrito em assembly utilizando durante o processo de exploração de binários (Windows e Linux), seja para criação de um shell reverso, bind shell como para execução de comandos, execução de uma aplicação e etc.</p><p>Em um processo de criação de shellcoding temos a possibilidade de trabalhar com 2 estratégias, a primeira delas utilizando Syscall e a segunda utilizando APIs dos subsistemas do sistema operacional.</p><h2 id="arquitetura-windows-e-linux"><span class="me-2">Arquitetura Windows e Linux</span><a href="#arquitetura-windows-e-linux" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>De forma simplificada a imagem abaixo ilustra a arquitetura do sistema operacional Linux</p><p><a href="/assets/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Fonte: <a href="https://infoslack.com/devops/linux-101-arquitetura">https://infoslack.com/devops/linux-101-arquitetura</a></p><p>Bem como temos a figura abaixo ilustrando a arquitetura do Windows</p><p><a href="/assets/2021/08/36c41ddc969a4761a25396a46edbf8a3.png" class="img-link shimmer" ><img data-src="/assets/2021/08/36c41ddc969a4761a25396a46edbf8a3.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Fonte: Pavel, Y at all. Windows Internals Part 1: 1. ed. Washington: Microsoft, 2017. Pg 47</p><h2 id="problema-do-syscall"><span class="me-2">Problema do Syscall</span><a href="#problema-do-syscall" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Como observado am ambas arquiteturas (Windows e Linux) temos 2 possibilidades de realizar chamadas para o SO, a primeira delas utilizando as bibliotecas e subsistemas do sistema operacional (glibc, kernel32.dll, user32.dll e etc…), a segunda metodologia é utilizando system calls (ou também conhecida como syscall).</p><p>Em um Linux é muito comum e fácil se utilizar as syscalls pois no Linux os IDs das syscalls não se alteram com novas releases, versões e etc, além de serem amplamente documentada. Já em um ambiente Windows não existe uma documentação oficial sobre o tema e é altamente refutado a utilização, pois a cada release do SO os ids das syscalls se alteram, desta forma um shellcode não se torna confiável.</p><p>Vale a pena ressaltar que existem técnicas para identificar os IDs da syscall e utiliza-las, mas isso fica para outro artigo.</p><p>Desta forma é muito comum em um ambiente windows os shellcodings utilizarem as funções expostas diretamente pelas APIs do windows (ou também conhecidas como subsistemas) que são a Kernel32.dll, user32.dll etc…</p><p>Para um melhor aprofundamento recomendo a visualização do vídeo do Rafael Salema falando sobre o assunto <a href="https://www.youtube.com/watch?v=nQNxAje5SxI">Stop calling APIs! Demystifying direct syscall</a></p><h2 id="objetivo-deste-artigo"><span class="me-2">Objetivo deste artigo</span><a href="#objetivo-deste-artigo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Como em shellcoding windows geralmente utilizamos as APIs do sistema operacional e estas APIs geralmente executam no sistema operacional com <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address space layout randomization - ASLR</a> de forma que a cada execução ou a cada reboot do sistema operacional, bem como a cada compilação da DLL tem-se um endereço diferente para as chamadas de funções.</p><p>Sendo assim o shellcode para ser confiável precisa deter um método de identificar dinamicamente o endereço de uma função.</p><p>Em nossos treinamentos ensinamos a utilizar as bibliotecas da Metasploit, chamadas Block API, para este fim. Bibliotecas disponíveis em:</p><ul><li><strong>32 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a><li><strong>64 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a></ul><blockquote class="prompt-tip"><p>A propósito eu realizei algumas otimizações para que o ASM da versão em 64 bits não tenha nullbyte e de quebra houve uma redução de tamanho. Por questões internas e comentadas no Pull Request o mesmo não foi realizado o merge, mas para quem tiver interesse segue a referencia: <a href="https://github.com/rapid7/metasploit-framework/pull/17934">Pull Request #17934</a>.</p></blockquote><p>Inclusive temos um mini-treinamento disponível em nosso canal do Youtube sobre Shellcoding para 64 bits: <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a> utilizando essa biblioteca.</p><p>O que faremos neste artigo é entender passo a passo (dissecar) o que essa biblioteca realiza, quais estruturas, tabelas e dados da aplicação ela analisa para chegar a identificar de forma precisa o endereço exato da função dentro do Windows.</p><p>Sendo assim este artigo focará somente no sistema operacional Windows.</p><h2 id="conceitos-e-referencias-complementares"><span class="me-2">Conceitos e referencias complementares</span><a href="#conceitos-e-referencias-complementares" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Durante este estudo iremos falar de diversos assuntos e daremos ênfase/aprofundamento somente naquilo que é pertinente para o nosso estudo, sendo assim para um melhor entendimento e aprofundamento recomendo a consulta aos seguintes materiais:</p><ul><li>Windows PE Format: PE é o acronimo de Portable Executable, que na prática é qualquer binário executável no windows incluindo .exe, .dll. Especificações técnicas: <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a> e https://www.aldeid.com/wiki/PE-Portable-executable])https://www.aldeid.com/wiki/PE-Portable-executable)<li>Intel® 64 and IA-32 Architectures Software Developer Manuals: Este manual traz de forma detalhada diversas questões de desenvolvimento para Intel, mas o foco que utilizamos é para o entendimento das principais instruções Assembly utilizadas neste artigo: <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a><li>WinDBG: Neste artigo utilizaremos o WinDBG como debugger disponível em: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a><li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a></ul><blockquote class="prompt-warning"><p>Caso não tenha familiaridade com instruções assembly, ponteiros e pilha, recomendo antes da continuidade da leitura a visualização desta aula do Youtube <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a> pois nesta aula é apresentada diversos conceitos extremamente necessários para o entendimento deste artigo.</p></blockquote><h2 id="instalando-windbg"><span class="me-2">Instalando WinDbg</span><a href="#instalando-windbg" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Para realizar a instalação do WinDBG faça o download do SDK do Windows 10 disponível em: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p><p><a href="/assets/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png" class="img-link shimmer" ><img data-src="/assets/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Após instalado realize a configuração do local de armazenamento e download dos símbolos de debug.</p><p>Abra o WinDBG x68 e vá em File &gt; Symbol File Path e adicione o conteúdo abaixo</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>srv<span class="se">\*</span>c:<span class="se">\s</span>ymbols<span class="se">\*</span>c:<span class="se">\s</span>ymbols<span class="se">\*</span>http://msdl.microsoft.com/download/symbols  
</pre></table></code></div></div><p><a href="/assets/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Carregue uma aplicação qualquer em 32 bits como</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>C:<span class="se">\W</span>indows<span class="se">\S</span>ysWOW64<span class="se">\n</span>otepad.exe  
</pre></table></code></div></div><p><a href="/assets/2021/08/f50155a62904444dae9b7655288ae33f.png" class="img-link shimmer" ><img data-src="/assets/2021/08/f50155a62904444dae9b7655288ae33f.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Recarregue todos os simbolos</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>.reload /f  
</pre></table></code></div></div><p><a href="/assets/2021/08/388d8891016e4654a101bc40fb85bc0b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/388d8891016e4654a101bc40fb85bc0b.png" alt="" class="lazyload" data-proofer-ignore></a></p><h2 id="process-internals"><span class="me-2">Process Internals</span><a href="#process-internals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Cada processo windows é representado por um bloco EPROCESS (Executive Process), o bloco EPROCESS contem uma série de apontamentos para um numero grande de outras estruturas, por exemplo ETHREADS, TEB, PED entre outras.</p><p>A Figura abaixo simplifica o diagrama das estruturas do processo e threads.</p><p><a href="/assets/2021/08/d817862488ea47d683756ffa2da72a85.png" class="img-link shimmer" ><img data-src="/assets/2021/08/d817862488ea47d683756ffa2da72a85.png" alt="" class="lazyload" data-proofer-ignore></a><br /> Fonte: Russinovich, M at all. Windows Internals: 5. ed. Washington: Microsoft, 2009. Pg 336</p><p>Para nosso estudo vale ressaltar uma tabela extremamente importante que é a TEB (Thread Environment Block), por compatibilidade também conhecida como TIB (Thread Information Block). A TEB pode ser utilizada para obter uma série de informações do processo sem a necessidade de realizar chamadas para as APIs Win32. Entre outras informações armazena o endereço do SEH e o endereço da tabela PEB (Process Environment Block), que por sua vez através da PEB pode-se obter acesso a IAT (Import Address Table) e muito mais.<br /> A TEB pode pode ser acessada através do registrador de segmento FS.</p><h3 id="loader"><span class="me-2">Loader</span><a href="#loader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>No momento da inicialização do aplicativo uma série de atividades são realizadas. Na prática o loader é executado antes do código da própria aplicação de forma que o mesmo é transparente ao usuário. Dentre as atividades em que o loader é responsável iremos destacar duas que são importantes para nosso estudo:</p><ul><li>Tratar a IAT (Import Address Table) da aplicação e olhar para todas as DLLs que a aplicação necessita, bem como analisar recursivamente a IAS de todas as DLLs carregadas, seguido da análise da tabela de exportação das DLLs para ter certeza que as funções desejadas estão presentes.<li>Carregar e descarregar DLLs em tempo de execução, mesmo as carregadas sobre demanda e manter a lista de todos os módulos conhecida como Módules Database ou também como LDR (Loader Data Table).</ul><h2 id="análise-da-block-api-32-bits"><span class="me-2">Análise da block api 32 bits</span><a href="#análise-da-block-api-32-bits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A biblioteca da Block API está disponível no github da Metasploit em <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></p><h3 id="utilização"><span class="me-2">Utilização</span><a href="#utilização" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Antes de adentrarmos a análise do código da BlockAPI vamos a um exemplo de utilização.</p><p>Neste exemplo iremos utilizar a função ExitProcess documentada em <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess</a></p><p>Tendo sua sintaxe como abaixo:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ExitProcess</span><span class="p">(</span>  
<span class="n">UINT</span> <span class="n">uExitCode</span>  
<span class="p">);</span>  
</pre></table></code></div></div><h4 id="código-c"><span class="me-2">Código C</span><a href="#código-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div file="exit.c" class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="exit.c"><i class="far fa-file-code fa-fw"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="c1">  </span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>

<span class="n">ExitProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>  
</pre></table></code></div></div><h4 id="hash-da-api"><span class="me-2">Hash da api</span><a href="#hash-da-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>A block_api espera como entrada no topo da pilha o hash da função desejada seguido dos parâmetros da função.</p><p>Para o cálculo do hash da função utilizaremos uma aplicação desenvolvida por mim disponível em <a href="https://github.com/helviojunior/addrfinder">https://github.com/helviojunior/addrfinder</a></p><p><a href="/assets/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note que o hash da função <strong>ExitProcess</strong> é <strong>0x56A2B5F0</strong>, este hash não se altera mesmo em releases diferentes do windows.</p><h4 id="assembly---utilizando-a-block_api"><span class="me-2">Assembly - utilizando a block_api</span><a href="#assembly---utilizando-a-block_api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div file="exit.asm" class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="exit.asm"><i class="far fa-file-code fa-fw"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>[BITS 32]

global _start

_start:  
jmp short block_api

get_block_api:  
pop edi ; Copia o endereço da block_api no registrador edi

; Sai da aplicação sem aprentar erro  
xor eax,eax ; Zera EAX  
push eax ; Coloca na pilha o "exit code" = 0x00

; Realiza a chamada da função ExitProcess  
push 0x56A2B5F0 ; Coloca o endereço do hash função ExitProcess na pilha  
call edi ; Executa a block_api para localizar e executar a função

block_api:  
call get_block_api  
%include "../block_api.asm"  
</pre></table></code></div></div><p><a href="/assets/2021/08/5033fcd6f11140fcb573c532cee9d279.png" class="img-link shimmer" ><img data-src="/assets/2021/08/5033fcd6f11140fcb573c532cee9d279.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Como podemos observar no código acima na linha 22 realizamos a inclusão do arquivo da biblioteca (exatamente o mesmo arquivo listado no link do github acima)</p><p>Utilizando a estratégia de JMP; Call; POP salvamos o endereço da primeira instrução da block_api no registrador EDI</p><p>Sendo assim podemos colocar na pilha de forma que ficará como abaixo:</p><ul><li>ESP + 0x00 = 0x56A2B5F0<li>ESP + 0x04 = 0x00000000</ul><p>E posteriormente executamos a block_api através da instrução <strong>call edi</strong></p><h4 id="montagem-e-executando"><span class="me-2">Montagem e executando</span><a href="#montagem-e-executando" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote class="prompt-warning"><p>Utilizaremos a aplicação <code class="language-plaintext highlighter-rouge">shellcodetester</code> desenvolvida por mim para a realização dos testes. Denso assim você pode realizar a instalação diretamente via PyPi com o comando <code class="language-plaintext highlighter-rouge">pip3 install shellcodetester</code></p></blockquote><p>Para a montagem (conversão dos mnemônico ASM para binário/hexa) utilizaremos o o ShellcodeTester (Disponível em <a href="https://github.com/helviojunior/shellcodetester">https://github.com/helviojunior/shellcodetester</a>)</p><p>Para a instalação do mesmo basta realizar o comando</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>pip3 <span class="nb">install</span> <span class="nt">--upgrade</span> shellcodetester
</pre></table></code></div></div><p>Após a instalação realize a montagem e compilação de um EXE através do comando</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>shellcodetester <span class="nt">-asm</span> exit.asm <span class="nt">--break-point</span>
</pre></table></code></div></div><p>Abra o Windbg e execute o arquivo gerado <code class="language-plaintext highlighter-rouge">st-exit.exe</code></p><p>Agora na console do windbg digite o comando <code class="language-plaintext highlighter-rouge">go</code></p><h2 id="análise-do-nosso-shellcode"><span class="me-2">Análise do nosso shellcode</span><a href="#análise-do-nosso-shellcode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Antes de chegar efetivamente na biblioteca da block api nós temos algumas instruções das quais podemos colocar lado a lado com nosso código</p><p><a href="/assets/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png" class="img-link shimmer" ><img data-src="/assets/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Como o foco é na execução da própria block_api vamos até o ponto da chamada <strong>call edi</strong></p><p>Neste momento temos no registrador EDI o endereço da block_api</p><p><a href="/assets/2021/08/19c8531c17944b009ff8244113f6172f.png" class="img-link shimmer" ><img data-src="/assets/2021/08/19c8531c17944b009ff8244113f6172f.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>E começaremos a nossa análise deste ponto</p><h2 id="análise-da-block_api"><span class="me-2">Análise da block_api</span><a href="#análise-da-block_api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Para facilitar o processo de análise vou colocando o código da block_api conforme formos evoluindo no mesmo.</p><h3 id="tabelas"><span class="me-2">Tabelas</span><a href="#tabelas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Como comentado anteriormente há uma série de tabelas existentes e utilizadas em nosso aplicativo, sendo assim segue um diagrama com o fluxo que realizaremos na próximas instruções</p><p><a href="/assets/2021/08/fb50b1ae0c2247498d36b0864c28432a.png" class="img-link shimmer" ><img data-src="/assets/2021/08/fb50b1ae0c2247498d36b0864c28432a.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Primeiramente utilizaremos o registrador de segmento FS em seu offset 0x30 para obter o endereço relativo (offset) de memória da tabela TEB, posteriormente pegaremos de dentro da TEB em seu offset 0x0C o endereço da tabela LDR e por fim dentro da tabela LDR pegaremos o endereço de memória do primeiro elemento da array InMemoryOrderModuleList.</p><h3 id="termos-de-memória"><span class="me-2">Termos de memória</span><a href="#termos-de-memória" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="vra-virtual-relative-addres"><span class="me-2">VRA (Virtual Relative Addres)</span><a href="#vra-virtual-relative-addres" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Daqui para frente utilizaremos o termo VRA (Virtual Relative Address) este termo refere-se a um endereço de memória relativo ao Base Address (ou também conhecido como Offset), de forma que o offset de uma DLL só se altera se houver a recompilação da mesma, o que o ASLR interfere é no BaseAddress, este sim se altera a cada reboot da maquina ou a cada execução da aplicação.</p><h4 id="vma-virtual-memory-address"><span class="me-2">VMA (Virtual Memory Address)</span><a href="#vma-virtual-memory-address" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>O VMA é igual ao VRA + BaseAddress, ou seja o endereço virtual que pode ser utilizado dentro da aplicação.</p><h3 id="função-api_call"><span class="me-2">Função api_call</span><a href="#função-api_call" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Segue abaixo o trecho de código da primeira função api_call</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>api_call:  
pushad <span class="p">;</span> We preserve all the registers <span class="k">for </span>the <span class="nb">caller</span>, bar EAX and ECX.  
mov ebp, esp <span class="p">;</span> Create a new stack frame  
xor edx, edx <span class="p">;</span> Zero EDX  
mov edx, <span class="o">[</span>fs:edx+0x30] <span class="p">;</span> Get a pointer to the PEB  
mov edx, <span class="o">[</span>edx+0xc] <span class="p">;</span> Get PEB-&gt;Ldr  
mov edx, <span class="o">[</span>edx+0x14] <span class="p">;</span> Get the first module from the InMemoryOrder module list  
</pre></table></code></div></div><h4 id="pushad"><span class="me-2">pushad</span><a href="#pushad" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Pushad é uma instrução que coloca na pilha todos os registradores, em outras palavras, salva o valor de todos os registradores na pilha. Este processo consome 20 bytes da pilha</p><h4 id="mov-ebp-esp"><span class="me-2">mov ebp, esp</span><a href="#mov-ebp-esp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o endereço do topo da pilha para ebp. Este processo é conhecido como prólogo de uma função, ou seja, está igualando ESP e EBP para iniciar um novo <strong>stack frame</strong></p><h4 id="xor-edx-edx"><span class="me-2">xor edx, edx</span><a href="#xor-edx-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>A operação matematica XOR de um valor com ele mesmo sempre resultará em Zero, sendo assim esta instrução zera o valor do registrador EDX</p><h4 id="mov-edx-fsedx0x30"><span class="me-2">mov edx, [fs:edx+0x30]</span><a href="#mov-edx-fsedx0x30" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o VRA da PEB para dentro do registrador EDX</p><p>Dentro do windbg podemos visualizar essa informação com o comando abaixo</p><pre><code class="language-txt">0:009&gt; dt nt!_TEB @$teb  
ntdll!_TEB  
+0x000 NtTib : _NT_TIB  
+0x01c EnvironmentPointer : (null)  
+0x020 ClientId : _CLIENT_ID  
+0x028 ActiveRpcHandle : (null)  
+0x02c ThreadLocalStoragePointer : 0x0146a988 Void  
+0x030 ProcessEnvironmentBlock : 0x010da000 _PEB  
+0x034 LastErrorValue : 0  
+0x038 CountOfOwnedCriticalSections : 0  
+0x03c CsrClientThread : (null)  
+0x040 Win32ThreadInfo : (null)  
+0x044 User32Reserved : [26] 0  
+0x0ac UserReserved : [5] 0  
+0x0c0 WOW32Reserved : 0x77c16000 Void  
+0x0c4 CurrentLocale : 0x409  
+0x0c8 FpSoftwareStatusRegister : 0  
+0x0cc ReservedForDebuggerInstrumentation : [16] (null)  
+0x10c SystemReserved1 : [26] (null)  
+0x174 PlaceholderCompatibilityMode : 0 ''  
+0x175 PlaceholderHydrationAlwaysExplicit : 0 ''  
+0x176 PlaceholderReserved : [10] ""  
+0x180 ProxiedProcessId : 0  
</code></pre><p>E confirmando a informação após a execução da instrução</p><p><a href="/assets/2021/08/21769f1837a241d0b7dcf1cc39f28526.png" class="img-link shimmer" ><img data-src="/assets/2021/08/21769f1837a241d0b7dcf1cc39f28526.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-edx-edx0xc"><span class="me-2">mov edx, [edx+0xc]</span><a href="#mov-edx-edx0xc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o VRA da LDR para dentro do registrador EDX</p><pre><code class="language-txt">0:009&gt; dt nt!_PEB 0x010da000  
ntdll!_PEB  
+0x000 InheritedAddressSpace : 0 ''  
+0x001 ReadImageFileExecOptions : 0 ''  
+0x002 BeingDebugged : 0x1 ''  
+0x003 BitField : 0 ''  
+0x003 ImageUsesLargePages : 0y0  
+0x003 IsProtectedProcess : 0y0  
+0x003 IsImageDynamicallyRelocated : 0y0  
+0x003 SkipPatchingUser32Forwarders : 0y0  
+0x003 IsPackagedProcess : 0y0  
+0x003 IsAppContainer : 0y0  
+0x003 IsProtectedProcessLight : 0y0  
+0x003 IsLongPathAwareProcess : 0y0  
+0x004 Mutant : 0xffffffff Void  
+0x008 ImageBaseAddress : 0x00f40000 Void  
+0x00c Ldr : 0x77d40c40 _PEB_LDR_DATA  
+0x010 ProcessParameters : 0x013d19d0 _RTL_USER_PROCESS_PARAMETERS  
+0x014 SubSystemData : (null)  
+0x018 ProcessHeap : 0x013d0000 Void  
+0x01c FastPebLock : 0x77d409e0 _RTL_CRITICAL_SECTION  
+0x020 AtlThunkSListPtr : (null)  
+0x024 IFEOKey : (null)  
+0x028 CrossProcessFlags : 9  
+0x028 ProcessInJob : 0y1  
+0x028 ProcessInitializing : 0y0  
</code></pre><p><a href="/assets/2021/08/637cc9ff49334ee78bcf36a095d040ea.png" class="img-link shimmer" ><img data-src="/assets/2021/08/637cc9ff49334ee78bcf36a095d040ea.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-edx-edx0x14"><span class="me-2">mov edx, [edx+0x14]</span><a href="#mov-edx-edx0x14" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o VRA do primeiro elemento da array <strong>InMemoryOrderModuleList</strong> da tabela LDR para o registrador EDX.</p><pre><code class="language-txt">0:009&gt; dt _PEB_LDR_DATA 0x77d40c40  
ntdll!_PEB_LDR_DATA  
+0x000 Length : 0x30  
+0x004 Initialized : 0x1 ''  
+0x008 SsHandle : (null)  
+0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x13d32a0 - 0x140d710 ]  
+0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x13d32a8 - 0x140d718 ]  
+0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x13d31c8 - 0x140d670 ]  
+0x024 EntryInProgress : (null)  
+0x028 ShutdownInProgress : 0 ''  
+0x02c ShutdownThreadId : (null)  
</code></pre><p><a href="/assets/2021/08/8d5afbd757e84622bee6ac7587f5d806.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8d5afbd757e84622bee6ac7587f5d806.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Neste ponto temos em <strong>EDX</strong> o VRA do primeiro elemento da lista duplamente encadeada <strong>InMemoryOrderModuleList</strong>.</p><p><a href="/assets/2021/08/263625546a4046e3b33d92971fae19ea.png" class="img-link shimmer" ><img data-src="/assets/2021/08/263625546a4046e3b33d92971fae19ea.png" alt="" class="lazyload" data-proofer-ignore></a></p><pre><code class="language-txt">0:009&gt; dt _LIST_ENTRY (0x77d40c40 + 0x14)  
ntdll!_LIST_ENTRY  
[ 0x13d32a8 - 0x140d718 ]  
+0x000 Flink : 0x013d32a8 _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]  
+0x004 Blink : 0x0140d718 _LIST_ENTRY [ 0x77d40c54 - 0x140d878 ]

</code></pre><p>Essa informação não parece muito útil, mas conforme podemos visualizar na documentação (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a>) a estrutura LIST_ENTRY faz parte de uma estrutura maior chamada <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code></p><pre><code class="language-txt">typedef struct _LIST_ENTRY {  
struct _LIST_ENTRY \*Flink;  
struct _LIST_ENTRY \*Blink;  
} LIST_ENTRY, \*PLIST_ENTRY, \*RESTRICTED_POINTER PRLIST_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY {  
PVOID Reserved1[2];  
LIST_ENTRY InMemoryOrderLinks;  
PVOID Reserved2[2];  
PVOID DllBase;  
PVOID EntryPoint;  
PVOID Reserved3;  
UNICODE_STRING FullDllName;  
BYTE Reserved4[8];  
PVOID Reserved5[3];  
union {  
ULONG CheckSum;  
PVOID Reserved6;  
};  
ULONG TimeDateStamp;  
} LDR_DATA_TABLE_ENTRY, \*PLDR_DATA_TABLE_ENTRY;  
</code></pre><p>Para realizar o dump da estrutura temos de subtrair 0x08 do endereço da <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code> com o objetivo de encontrar o início da estrutura <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code></p><pre><code class="language-txt">0:009&gt; dt _LDR_DATA_TABLE_ENTRY (013d32a8 - 0x8)  
ntdll!_LDR_DATA_TABLE_ENTRY  
+0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x13d31b8 - 0x77d40c4c ]  
+0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]  
+0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]  
+0x018 DllBase : 0x00f40000 Void  
+0x01c EntryPoint : (null)  
+0x020 SizeOfImage : 0xa2000  
+0x024 FullDllName : _UNICODE_STRING "C:\Tools\ShellcodeTester\Runner.exe"  
+0x02c BaseDllName : _UNICODE_STRING "Runner.exe"  
+0x034 FlagGroup : [4] "???"  
+0x034 Flags : 0x14022c4  
</code></pre><p><a href="/assets/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png" class="img-link shimmer" ><img data-src="/assets/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png" alt="" class="lazyload" data-proofer-ignore></a></p><h3 id="função-next_mod"><span class="me-2">Função next_mod</span><a href="#função-next_mod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>next_mod: ;  
mov esi, [edx+0x28] ; Get pointer to modules name (unicode string)  
movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check  
xor edi, edi ; Clear EDI which will store the hash of the module name  
</pre></table></code></div></div><h4 id="mov-esi-edx0x28"><span class="me-2">mov esi, [edx+0x28]</span><a href="#mov-esi-edx0x28" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o VMA do nome do módulo</p><pre><code class="language-txt">0:009&gt; du @esi  
013d1eb6 "Runner.exe"  
</code></pre><p><a href="/assets/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="movzx-ecx-word-edx0x26"><span class="me-2">movzx ecx, word [edx+0x26]</span><a href="#movzx-ecx-word-edx0x26" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Recupera o tamanho do nome do módulo, lembrando que cada caractere em unicode corresponde a 2 bytes e temos mais os 2 null bytes no final</p><p>Em nosso cenário:</p><ul><li>Runner.exe = 10 Caracteres + 1 null byte<li>11 * 2 = 22</ul><p><a href="/assets/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="xor-edi-edi"><span class="me-2">xor edi, edi</span><a href="#xor-edi-edi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Zera o EDI para utilizar como local de armazenamento do hash do nome do módulo</p><h3 id="função-loop_modname"><span class="me-2">Função loop_modname</span><a href="#função-loop_modname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>loop_modname: ;  
xor eax, eax ; Clear EAX  
lodsb ; Read in the next byte of the name  
cmp al, 'a' ; Some versions of Windows use lower case module names  
jl not_lowercase ;  
sub al, 0x20 ; If so normalise to uppercase  
</pre></table></code></div></div><h4 id="xor-eax-eax"><span class="me-2">xor eax, eax</span><a href="#xor-eax-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Zera EAX</p><h4 id="lodsb"><span class="me-2">lodsb</span><a href="#lodsb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Carrega o primeiro byte vindo do ESI para o registrador AL.</p><h4 id="cmp-al-a"><span class="me-2">cmp al, ‘a’</span><a href="#cmp-al-a" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compara o byte recebido com o caractere ‘a’</p><h4 id="jl-not_lowercase"><span class="me-2">jl not_lowercase</span><a href="#jl-not_lowercase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Antes de vermos a comparação propriamente dita vamos analisar a tabela ASCII</p><p><a href="/assets/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png" class="img-link shimmer" ><img data-src="/assets/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Observe na tabela ASCII que o alfabeto minúsculo vai do hexa-decimal 0x61 até 0x7a e o maiúsculo vai de 0x41 a 0x5a, então:</p><ul><li>O minúsculo é exatamente 0x20 bytes que sua representação em maiúsculo<li>O hexa-decimal do caractere em minúsculo é maior que sua representação em maúsculo</ul><p>A instrução JL (Jump Short if less) verifica se o caractere em questão é menor que o caractere ‘a’, considerando que os valores em decimal/hexa-decimal dos caracteres em maiúsculo são menores que os em minúsculo, se sim o caractere é maiúsculo, neste cenário salta para a função <strong>not_lowercase</strong></p><h4 id="sub-al-0x20"><span class="me-2">sub al, 0x20</span><a href="#sub-al-0x20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Caso o caractere seja minúsculo, basta subtratir 0x20 que ele se tornará maiúsculo</p><h3 id="função-not_lowercase"><span class="me-2">Função not_lowercase</span><a href="#função-not_lowercase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Esta é uma função grande que na verdade realiza as seguintes operaçÕes:</p><ul><li>Cálculo do hash do nome do módulo<li>Resgata uma série de informações do módulo (Base Address, índice na lista, tabela de exports, número de funções, tabela de nomes da funções)</ul><p>Desta forma iremos analisar parte por parte dessa função (em pequenos códigos)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>not_lowercase: ;  
ror edi, 0xd ; Rotate right our hash value  
add edi, eax ; Add the next byte of the name  
dec ecx  
jnz loop_modname ; Loop until we have read enough  
; We now have the module hash computed  
push edx ; Save the current position in the module list for later  
push edi ; Save the current module hash for later  
</pre></table></code></div></div><h4 id="ror-edi-0xd"><span class="me-2">ror edi, 0xd</span><a href="#ror-edi-0xd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Rotaciona 0xd (decimal, 13) bits para a direita do valor presente no EDI (Hash Value)</p><h4 id="add-edi-eax"><span class="me-2">add edi, eax</span><a href="#add-edi-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o byte (resgatado do nome da função) ao valor presente no EDI e salva o resultado no próprio EDI</p><h4 id="dec-ecx"><span class="me-2">dec ecx</span><a href="#dec-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Decrementa o ECX (nosso contador)</p><h4 id="jnz-loop_modname"><span class="me-2">jnz loop_modname</span><a href="#jnz-loop_modname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump short if not zero, verifica se o resultado da ultima operação matemática é diferente de zero, ou seja, irá saltar para a função <strong>loop_modname</strong> enquanto o ECX for maior que zero</p><h4 id="push-edx"><span class="me-2">push edx</span><a href="#push-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Salva na pilha o valor de EDX que neste momento representa o índice do módulo na tabela LDR.InMemoryOrderModuleList</p><h4 id="push-edi"><span class="me-2">push edi</span><a href="#push-edi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Salva na pilha o hash do nome do módulo atual</p><h3 id="função-not_lowercase---parte-2"><span class="me-2">Função not_lowercase - parte 2</span><a href="#função-not_lowercase---parte-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Essa fase da função irá buscar as informações das funções exportadas de dentro do módulo atual.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>; Proceed to iterate the export address table,  
mov edx, [edx+0x10] ; Get this modules base address  
mov eax, [edx+0x3c] ; Get PE header  
add eax, edx ; Add the modules base address  
mov eax, [eax+0x78] ; Get export tables RVA  
test eax, eax ; Test if no export address table is present  
jz get_next_mod1 ; If no EAT present, process the next module  
add eax, edx ; Add the modules base address  
push eax ; Save the current modules EAT  
mov ecx, [eax+0x18] ; Get the number of function names  
mov ebx, [eax+0x20] ; Get the rva of the function names  
add ebx, edx ; Add the modules base address  
</pre></table></code></div></div><h4 id="mov-edx-edx0x10"><span class="me-2">mov edx, [edx+0x10]</span><a href="#mov-edx-edx0x10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Neste momento ainda temos no EDX o endereço da estrutura <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code> do módulo atual, sendo assim em seu offset 0x10 tem-se o BaseAddress do módulo, desta forma esta instrução copia o BaseAddress do módulo que está sendo analisado para o Registrador EDX</p><p><a href="/assets/2021/08/472981a7d03842059a6aa08dc1264726.png" class="img-link shimmer" ><img data-src="/assets/2021/08/472981a7d03842059a6aa08dc1264726.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note que para realizar o parse da estrutura <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code> temos de subtrair 0x08, então o Offset que aparece na imagem é 0x18, ou seja 0x10 + 0x08. Onde temos o valor 0x00f40000</p><p>Valor este que podemos confirma de mais outros 2 modos</p><p><a href="/assets/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png" class="img-link shimmer" ><img data-src="/assets/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png" alt="" class="lazyload" data-proofer-ignore></a></p><pre><code class="language-txt">0:009&gt; dd @edx + 10  
013d32b8 00f40000 00000000 000a2000 00480046  
013d32c8 013d1e84 00160014 013d1eb6 014022c4  
013d32d8 0000ffff 77d40ac0 013d31f4 5f125ed8  
013d32e8 00000000 00000000 013d3350 013d3350  
013d32f8 013d3350 00000000 00000000 00000000  
013d3308 00000000 00000000 0140d099 013d4f64  
013d3318 013d38c4 00000000 00400000 00000000  
013d3328 11fb4e0f 01d79199 10078c54 00000004

0:009&gt; lm m runner  
Browse full module list  
start end module name  
00f40000 00fe2000 Runner C (no symbols)  
</code></pre><p>Neste momento temos em EDX o BaseAddress do módulo que está sendo verificado.</p><h3 id="binary-internals"><span class="me-2">Binary internals</span><a href="#binary-internals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Para facilitar o entendimento vamos adentrar nas tabelas que iremos resgatar as informações</p><p><a href="/assets/2021/08/b9a2470b34804531b292d9276ac26780.png" class="img-link shimmer" ><img data-src="/assets/2021/08/b9a2470b34804531b292d9276ac26780.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="ms-dos-pe-header"><span class="me-2">MS-DOS PE HEader</span><a href="#ms-dos-pe-header" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>https://www.aldeid.com/wiki/PE-Portable-executable</p><p><a href="/assets/2021/08/76ca63c41bf6481e9884ffd78bc9730a.png" class="img-link shimmer" ><img data-src="/assets/2021/08/76ca63c41bf6481e9884ffd78bc9730a.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="pe-header"><span class="me-2">PE HEader</span><a href="#pe-header" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>BaseAssress + 0x3c = Início do PE Header</p><p><a href="/assets/2021/08/5fa512a8337a42f2a2a48f2b29147736.png" class="img-link shimmer" ><img data-src="/assets/2021/08/5fa512a8337a42f2a2a48f2b29147736.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/6fee8b530ed94e9e8f3a7060f0883a51.png" class="img-link shimmer" ><img data-src="/assets/2021/08/6fee8b530ed94e9e8f3a7060f0883a51.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="export-table"><span class="me-2">Export Table</span><a href="#export-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://www.aldeid.com/wiki/PE-Portable-executable#Export_Table">https://www.aldeid.com/wiki/PE-Portable-executable#Export_Table</a></p><p>A tabela de exports está no offset 0x78 a partir do início do PE Header. Cada módulo (Executável/DLL) conterá o seu próprio PE Header e consequentemente a sua tabela de exportação.</p><p><a href="/assets/2021/08/e65af62396474ecaa86ea23feaade247.png" class="img-link shimmer" ><img data-src="/assets/2021/08/e65af62396474ecaa86ea23feaade247.png" alt="" class="lazyload" data-proofer-ignore></a></p><h3 id="função-not_lowercase---parte-2-continuação"><span class="me-2">Função not_lowercase - parte 2 continuação</span><a href="#função-not_lowercase---parte-2-continuação" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Temos na imagem o parse dos dados da DOS_HEADER</p><pre><code class="language-txt">0:009&gt; dt ntdll!_IMAGE_DOS_HEADER 00f40000  
+0x000 e_magic : 0x5a4d  
+0x002 e_cblp : 0x90  
+0x004 e_cp : 3  
+0x006 e_crlc : 0  
+0x008 e_cparhdr : 4  
+0x00a e_minalloc : 0  
+0x00c e_maxalloc : 0xffff  
+0x00e e_ss : 0  
+0x010 e_sp : 0xb8  
+0x012 e_csum : 0  
+0x014 e_ip : 0  
+0x016 e_cs : 0  
+0x018 e_lfarlc : 0x40  
+0x01a e_ovno : 0  
+0x01c e_res : [4] 0  
+0x024 e_oemid : 0  
+0x026 e_oeminfo : 0  
+0x028 e_res2 : [10] 0  
+0x03c e_lfanew : 0n128  
0:009&gt; ? 0n128  
Evaluate expression: 128 = 00000080  
</code></pre><p><a href="/assets/2021/08/c1869b05a5bd4058856189c64a200c77.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c1869b05a5bd4058856189c64a200c77.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-eax-edx0x3c"><span class="me-2">mov eax, [edx+0x3c]</span><a href="#mov-eax-edx0x3c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia RVA do PE Header para o registrador EAX</p><p><a href="/assets/2021/08/c0c2939453d0432caaa0e6df186057a5.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c0c2939453d0432caaa0e6df186057a5.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Podemos observar que o EAX teve seu valor definido como 0x80, ou seja o PE Header está em Base Address + 0x80 como vemos no output abaixo</p><pre><code class="language-txt">0:009&gt; dt ntdll!_IMAGE_NT_HEADERS 00f40000 + 0x80  
+0x000 Signature : 0x4550  
+0x004 FileHeader : _IMAGE_FILE_HEADER  
+0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER  
</code></pre><p><a href="/assets/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png" class="img-link shimmer" ><img data-src="/assets/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Adicionalmente podemos observar os cabeçalhos adicionais no Offset 0x80 em relação ao PE Header</p><pre><code class="language-txt">0:009&gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 00f40000 + 0x80 + 0x18  
+0x000 Magic : 0x10b  
+0x002 MajorLinkerVersion : 0x30 '0'  
+0x003 MinorLinkerVersion : 0 ''  
+0x004 SizeOfCode : 0x51e00  
+0x008 SizeOfInitializedData : 0x4b800  
+0x00c SizeOfUninitializedData : 0  
+0x010 AddressOfEntryPoint : 0x53cf2  
+0x014 BaseOfCode : 0x2000  
+0x018 BaseOfData : 0x54000  
+0x01c ImageBase : 0x400000  
+0x020 SectionAlignment : 0x2000  
+0x024 FileAlignment : 0x200  
+0x028 MajorOperatingSystemVersion : 4  
+0x02a MinorOperatingSystemVersion : 0  
+0x02c MajorImageVersion : 0  
+0x02e MinorImageVersion : 0  
+0x030 MajorSubsystemVersion : 4  
+0x032 MinorSubsystemVersion : 0  
+0x034 Win32VersionValue : 0  
+0x038 SizeOfImage : 0xa2000  
+0x03c SizeOfHeaders : 0x200  
+0x040 CheckSum : 0  
+0x044 Subsystem : 2  
+0x046 DllCharacteristics : 0x8540  
+0x048 SizeOfStackReserve : 0x100000  
+0x04c SizeOfStackCommit : 0x1000  
+0x050 SizeOfHeapReserve : 0x100000  
+0x054 SizeOfHeapCommit : 0x1000  
+0x058 LoaderFlags : 0  
+0x05c NumberOfRvaAndSizes : 0x10  
+0x060 DataDirectory : [16] _IMAGE_DATA_DIRECTORY  
</code></pre><p><a href="/assets/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Dentro dos cabeçalhos adicionais podemos encontrar que a Export table (DataDirectory) encontra-se no Offset 0x60 relativo aos cabeçalhos adicionais.</p><p>Desta forma se considerarmos que os cabeçalhos adicionais estão em 0x18 em relação ao PE Heder podemos então inferir que com relação ao PE Header a Exporta table está (0x18 + 0x60) = 0x78</p><h4 id="add-eax-edx"><span class="me-2">add eax, edx</span><a href="#add-eax-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA do PE Header e o salva no registrador EAX</p><h4 id="mov-eax-eax0x78"><span class="me-2">mov eax, [eax+0x78]</span><a href="#mov-eax-eax0x78" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o RVA da tabela de exports para o registrador EAX</p><p><a href="/assets/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Como pode-se observar este é um cenário onde o módulo atual não detém nenhuma função exportada. Sendo assim iremos adicionar um breakpoint neste ponto do código para podermos executar o código até que chegue no módulo desejado. Como a função exitprocess está dentro do módulo kernel32.dll vamos executar o código até chegar neste ponto dentro do módulo kernel32.dll.</p><p><a href="/assets/2021/08/711ed42a3fd44518960877bcbb2f48bb.png" class="img-link shimmer" ><img data-src="/assets/2021/08/711ed42a3fd44518960877bcbb2f48bb.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note que agora vamos executar o comando g, e a execução segue até nosso breakpoint, posteriormente podemos inspecionar qual é o módulo que estamos tratando com o comando <strong>lm a @edx</strong> uma vez que temos em ECX o BaseAddress do módulo atual</p><p><a href="/assets/2021/08/7997667cafec4e4e88a171ae43c7f922.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7997667cafec4e4e88a171ae43c7f922.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Uma vez que chegamos a kernel32.dll, podemos continuar a verificação.</p><p><a href="/assets/2021/08/08564e0c70724f328f260baea7f34fdc.png" class="img-link shimmer" ><img data-src="/assets/2021/08/08564e0c70724f328f260baea7f34fdc.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="test-eax-eax"><span class="me-2">test eax, eax</span><a href="#test-eax-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Verifica se há uma tabela de exports</p><p>Existe a tabela, ou seja EAX é diferente de zero, então o JMP não vai ocorrer.</p><h4 id="jz-get_next_mod1"><span class="me-2">jz get_next_mod1</span><a href="#jz-get_next_mod1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if 0, verifica se o resultado da ultima operação matemática foi zero, se sim, realiza o salto. De forma que verificará se não há tabela de exports salta para a função get_next_mod1, caso contrário continua para a proxima instrução</p><p><a href="/assets/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png" class="img-link shimmer" ><img data-src="/assets/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="add-eax-edx-1"><span class="me-2">add eax, edx</span><a href="#add-eax-edx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da tabela de exportação e o salva no registrador EAX</p><p><a href="/assets/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png" class="img-link shimmer" ><img data-src="/assets/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="push-eax"><span class="me-2">push eax</span><a href="#push-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Salva na pilha o VMA da tabela de exports do módulo atual</p><p><a href="/assets/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png" class="img-link shimmer" ><img data-src="/assets/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ecx-eax0x18"><span class="me-2">mov ecx, [eax+0x18]</span><a href="#mov-ecx-eax0x18" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Uma vez que temos em EAX o VMA da tabela de exporta copia o número de funções exportadas para o registrador ECX</p><p><a href="/assets/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/9db1702461b648c2b5b3f05eec7b2304.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9db1702461b648c2b5b3f05eec7b2304.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax0x20"><span class="me-2">mov ebx, [eax+0x20]</span><a href="#mov-ebx-eax0x20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copia o RVA do array com o nome das funções exportadas (AddressOfNames) para o registrador EBX</p><h4 id="add-ebx-edx"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA do array contendo o nome de todas as funções exportadas pelo módulo atual e o salva no registrador EBX</p><p>Neste momento temos em EBX o endereço de memória com o nome da primeira função</p><h3 id="função-get_next_func"><span class="me-2">Função get_next_func</span><a href="#função-get_next_func" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>; Computing the module hash + function hash  
get_next_func: ;  
test ecx, ecx ; Changed from jecxz to accomodate the larger offset produced by random jmps below  
jz get_next_mod ; When we reach the start of the EAT (we search backwards), process the next module  
dec ecx ; Decrement the function name counter  
mov esi, [ebx+ecx\*4] ; Get rva of next module name  
add esi, edx ; Add the modules base address  
xor edi, edi ; Clear EDI which will store the hash of the function name  
</pre></table></code></div></div><h4 id="test-ecx-ecx"><span class="me-2">test ecx, ecx</span><a href="#test-ecx-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Realiza uma verificação entre ECX e ECX</p><h4 id="jz-get_next_mod"><span class="me-2">jz get_next_mod</span><a href="#jz-get_next_mod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if 0, salta para a função get_next_mod caso o resultado da ultima operação matematica seja zero, ou seja, caso ECX (que é nosso contador de funções) tenha chegado a zero, salta para o ponto de código responsável por iniciar o processo de verificação do próximo módulo. Caso seja ECX maior que zero, continua a execução para a proxima instrução.</p><p><a href="/assets/2021/08/9cf736a54e064aefbb9720a26e91121a.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9cf736a54e064aefbb9720a26e91121a.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>ECX diferente de zero, então o JMP não irá ocorrer</p><h4 id="dec-ecx-1"><span class="me-2">dec ecx</span><a href="#dec-ecx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Decrementa 01 de ECX</p><h4 id="mov-esi-ebx--ecx--4"><span class="me-2">mov esi, [ebx + ecx * 4]</span><a href="#mov-esi-ebx--ecx--4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Resgata o RVA do nome da função. Onde:</p><ul><li>EBX: Contém o VMA do início da array que detém o nome das funções<li>ECX: índice numérico dentro da função<li>ECX * 4: índico numérico multiplicado por 4 Bytes (32 bits) que representa cada endereço que contém o nome da função</ul><h4 id="add-esi-edx"><span class="me-2">add esi, edx</span><a href="#add-esi-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do nome da função e o salva no registrador EAX</p><p><a href="/assets/2021/08/41dad8cb4ece46e8932b9dc629527137.png" class="img-link shimmer" ><img data-src="/assets/2021/08/41dad8cb4ece46e8932b9dc629527137.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Como no decorrer dest loop iremos decrementando o ECX, na pratica vamos varrendo a lista de traz p/ frente, sendo assim na primeira intereção tremos o nome da última função do array.</p><p><a href="/assets/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png" class="img-link shimmer" ><img data-src="/assets/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png" class="img-link shimmer" ><img data-src="/assets/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="xor-edi-edi-1"><span class="me-2">xor edi, edi</span><a href="#xor-edi-edi-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Zera o registrador EDI para utiliza-lo como armazenamento do hash da função</p><h3 id="função-loop_funcname"><span class="me-2">Função loop_funcname</span><a href="#função-loop_funcname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-txt">loop_funcname: ;  
xor eax, eax ; Clear EAX  
lodsb ; Read in the next byte of the ASCII function name  
ror edi, 0xd ; Rotate right our hash value  
add edi, eax ; Add the next byte of the name  
cmp al, ah ; Compare AL (the next byte from the name) to AH (null)  
jne loop_funcname ; If we have not reached the null terminator, continue  
add edi, [ebp-8] ; Add the current module hash to the function hash  
cmp edi, [ebp+0x24] ; Compare the hash to the one we are searchnig for  
jnz get_next_func ; Go compute the next function hash if we have not found it  
; If found, fix up stack, call the function and then value else compute the next one...  
pop eax ; Restore the current modules EAT  
mov ebx, [eax+0x24] ; Get the ordinal table rva  
add ebx, edx ; Add the modules base address  
mov cx, [ebx+2\*ecx] ; Get the desired functions ordinal  
mov ebx, [eax+0x1c] ; Get the function addresses table rva  
add ebx, edx ; Add the modules base address  
mov eax, [ebx+4\*ecx] ; Get the desired functions RVA  
add eax, edx ; Add the modules base address to get the functions actual VA  
</code></pre><h4 id="xor-eax-eax-1"><span class="me-2">xor eax, eax</span><a href="#xor-eax-eax-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Zera o registrador EAX</p><h4 id="lodsb-1"><span class="me-2">lodsb</span><a href="#lodsb-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Carrega o primeiro byte vindo do ESI para o registrador AL.</p><h4 id="ror-edi-0xd-1"><span class="me-2">ror edi, 0xd</span><a href="#ror-edi-0xd-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Rotaciona 0xd (decimal, 13) bits para a direita do valor presente no EDI (Hash Value)</p><h4 id="add-edi-eax-1"><span class="me-2">add edi, eax</span><a href="#add-edi-eax-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o byte (resgatado do nome da função) ao valor presente no EDI e salva o resultado no próprio EDI</p><h4 id="cmp-al-ah"><span class="me-2">cmp al, ah</span><a href="#cmp-al-ah" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compara o byte copiado pela função lodsb salvo em AL com o registrador AH (que neste cenário será zero)</p><h4 id="jne-loop_funcname"><span class="me-2">jne loop_funcname</span><a href="#jne-loop_funcname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if not equal, verifica se o resultado da última comparação não é iguial, ou seja, se o último byte copiado em AL é diferente de zero, caso seja diferente de zero retorna para o início da função loop_funcname para continuar copiando os bytes do nome da função e assim calculando o hash. Caso tenha chegado no terminador de string \0 (NULL Byte) continua para a próxima instrução</p><h4 id="add-edi-ebp-8"><span class="me-2">add edi, [ebp-8]</span><a href="#add-edi-ebp-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Soma o hash do nome da função recem cálculada com o hash do nome do módulo calculado anteriormente e salvo em ebp-8, salvando o resultado no registrador EDI</p><h4 id="cmp-edi-ebp0x24"><span class="me-2">cmp edi, [ebp+0x24]</span><a href="#cmp-edi-ebp0x24" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compara se o hash cálculado é igual ao hash desejado. Onde:</p><ul><li>EDI: Hash cálculado com o nome do módulo + Nome da função<li>EBP + 0x24: Posição da memória que detém o Hash da função desejada. Em nosso exemplo, este Hash foi adicionado na pilha com o PUSH 0x56A2B5F0 que é o hash da função ExitProcess</ul><p><a href="/assets/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png" class="img-link shimmer" ><img data-src="/assets/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Vamos então colocar um breakpoint nessa função para verificar após o cálculo do hash do nome de cada função + o hash do módulo, tendo então o hash final da função para posteriormente poder verificar se é igual ao desejado.</p><p><a href="/assets/2021/08/0e00a89fcb68481aad7fa79e32224480.png" class="img-link shimmer" ><img data-src="/assets/2021/08/0e00a89fcb68481aad7fa79e32224480.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="jnz-get_next_func"><span class="me-2">jnz get_next_func</span><a href="#jnz-get_next_func" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if not zero, caso a comparação anterior aponte como hash diferentes o código será direcionado para a função get_next_func, responsável por verificar a próxima função exportada do módulo atual. Caso os hashes sejam iguais continua para o fluxo da proxima instrução.</p><h4 id="pop-eax"><span class="me-2">pop eax</span><a href="#pop-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Restaura para o registrador EAX o VMA da tabela de exports do módulo atual. Este valor foi salvo na pilha através do PUSH EAX realizado anteriormente.</p><p><a href="/assets/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png" class="img-link shimmer" ><img data-src="/assets/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Colocamos um breakpoint nessa instrução, pois só chegaremos nela no momento em que os hashes forem iguais e posteriormente liberei a execução.</p><p><a href="/assets/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png" class="img-link shimmer" ><img data-src="/assets/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/fe1adf21706641a7bd213526c575cd32.png" class="img-link shimmer" ><img data-src="/assets/2021/08/fe1adf21706641a7bd213526c575cd32.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax0x24"><span class="me-2">mov ebx, [eax+0x24]</span><a href="#mov-ebx-eax0x24" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Relembrando a estrutura da Export table</p><p><a href="/assets/2021/08/e65af62396474ecaa86ea23feaade247-1.png" class="img-link shimmer" ><img data-src="/assets/2021/08/e65af62396474ecaa86ea23feaade247-1.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Temos no offset 0x24 o array AddressOfNameOrdinals, sendo assim esta instrução copia o VMA do array AddressOfNameOrdinals para o registrador EBX</p><p><a href="/assets/2021/08/dade3a9912334bcfb6573adb18d485f0.png" class="img-link shimmer" ><img data-src="/assets/2021/08/dade3a9912334bcfb6573adb18d485f0.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="add-ebx-edx-1"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do array AddressOfNameOrdinals e o salva no registrador EBX</p><h4 id="mov-cx-ebx--2--ecx"><span class="me-2">mov cx, [ebx + 2 * ecx]</span><a href="#mov-cx-ebx--2--ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Em ECX temos o índice da função desejada dentro da array AddressOfNames, como os arrays AddressOfNames e AddressOfNameOrdinals utilizam o mesmo índice podemos reaproveita-lo para endontrar o RVA da função dentro do array AddressOfNameOrdinals. Dentro da array AddressOfNames utiliamos ECX * 4 para saltar em cada um dos registros da array, pois cada registro dentro da AddressOfNames é um valor DWORD, ja na array AddressOfNameOrdinals cada registro é um WORD, sendo assim iremos multiplicar por 0x02 para saltar em cada registro. Conforme podemos observar na tabela de exports do módulo kernel32.dll</p><p><a href="/assets/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax--0x1c"><span class="me-2">mov ebx, [eax + 0x1c]</span><a href="#mov-ebx-eax--0x1c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Antes de utilizar o novo índice calculado anteriormente iremos pegar o RVA do AddressOfFunctions no índice 0x1c da Export table e o salva no registrador EBX</p><h4 id="add-ebx-edx-2"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do array AddressOfFunctions e o salva no registrador EBX</p><h4 id="mov-eax-ebx--4--ecx"><span class="me-2">mov eax, [ebx + 4 * ecx]</span><a href="#mov-eax-ebx--4--ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Resgata o RVA da função desejada dentro da array AddressOfFunctions utilizando o offset resgatado da array AddressOfNameOrdinals. Onde:</p><ul><li>EDX: Endereço virtual do AddressOfFunctions<li>ECX: Índice da função desejada (resgatado do array AddressOfNameOrdinals)<li>ECX * 4: Índice da função * 4 bytes de cada endereço</ul><h4 id="add-eax-edx-2"><span class="me-2">add eax, edx</span><a href="#add-eax-edx-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da função desejada e o salva no registrador EAX</p><blockquote class="prompt-warning"><p>Este ja é o endereço de execução da função e pode ser usado pela instrução <code class="language-plaintext highlighter-rouge">call eax</code> (por exemplo).</p></blockquote><p><a href="/assets/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png" alt="" class="lazyload" data-proofer-ignore></a></p><h3 id="funçao-finish"><span class="me-2">Funçao finish</span><a href="#funçao-finish" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-txt">finish:  
mov [esp+0x24], eax ; Overwrite the old EAX value with the desired api address for the upcoming popad  
pop ebx ; Clear off the current modules hash  
pop ebx ; Clear off the current position in the module list  
popad ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered  
pop ecx ; Pop off the origional return address our caller will have pushed  
pop edx ; Pop off the hash value our caller will have pushed  
push ecx ; Push back the correct return value  
jmp eax ; Jump into the required function  
</code></pre><h4 id="mov-esp0x24-eax"><span class="me-2">mov [esp+0x24], eax</span><a href="#mov-esp0x24-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Altera o valor orginal do EAX adicionado na pilha pelo <strong>pushad</strong> para o endereço da função desejada (que recem calculamos). Este processo é necessário pois daqui algumas instruções iremos restaurar os registrados como estavm no momento da chamada da nossa função. Neste momento o WAX conterá o VMA da função que desejamos chamar.</p><h4 id="pop-ebx"><span class="me-2">pop ebx</span><a href="#pop-ebx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Remove da pilha o hash do módulo atual</p><h4 id="pop-ebx-1"><span class="me-2">pop ebx</span><a href="#pop-ebx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Remove da pilha a posição atual na listagem de módulos</p><h4 id="popad"><span class="me-2">popad</span><a href="#popad" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Restaura todos os registradores conforme seus valores iniciais. Nota para o EAX que será restaurado com o valor que sobrescrevemos a 2 instruçÕes.</p><h4 id="pop-ecx"><span class="me-2">pop ecx</span><a href="#pop-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Remove da pilha e copia para o registrador ECX o endereço de retorno do nosso fluxo de execução original. Este endereço foi adicionado automaticamente na pilha no momento da chamada da instrução CALL.</p><h4 id="pop-edx"><span class="me-2">pop edx</span><a href="#pop-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Remove da pilha o hash da função que adicionamos antes da chamada da função call</p><h4 id="push-ecx"><span class="me-2">push ecx</span><a href="#push-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adiciona novamente na pilha o endereço de retorno para que após a execução da função desejada o código possa continuar sua execução normalmente.</p><h4 id="jmp-eax"><span class="me-2">jmp eax</span><a href="#jmp-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Salta para o endereço da função em que se deseja executar. Do ponto de vista do fluxo de código não continuaremos para as próximas instruções que será estudadas a segir, pois uma vez saltado para a função desejada a mesma finalizará com um RET que retornará, então, para nosso fluxo de execução original.</p><h3 id="funções-adicionais"><span class="me-2">Funções adicionais</span><a href="#funções-adicionais" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-txt">get_next_mod: ;  
pop eax ; Pop off the current (now the previous) modules EAT  
get_next_mod1: ;  
pop edi ; Pop off the current (now the previous) modules hash  
pop edx ; Restore our position in the module list  
mov edx, [edx] ; Get the next module  
jmp next_mod ; Process this module  
</code></pre><p>Conforme podemos visualizar ha outras funções no final do código da biblioteca que ja foram referenciados anteriormente e fazem parte do processo de execução.</p><h2 id="conclusão"><span class="me-2">Conclusão</span><a href="#conclusão" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Como vimos através do estudo da biblioteca block_api é possível localizar em tempo de execução todos os módulos carregados no sistema, inclusive os carregados em tempo de execução, e suas respectivas funções exportadas.</p><h2 id="treinamento"><span class="me-2">Treinamento</span><a href="#treinamento" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Deseja aprender passo a passo como realizar a criação de um Shellcode? Então da uma olhada em nosso treinamento de Shellcoding onde vamos do zero a criação de um shell reverso windows e linux, passando por shellcoding 32 e 64 bits.</p><p>Link do treinamento: <a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/">https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/</a></p><p><a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/" class="img-link shimmer" ><img data-src="/assets/2021/08/image" alt="" class="lazyload" data-proofer-ignore></a></p><h2 id="fontes"><span class="me-2">Fontes</span><a href="#fontes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Pavel, Y at all. Windows Internals Part 1: 7. ed. Washington: Microsoft, 2017.<li>Russinovich, M at all. Windows Internals: 5. ed. Washington: Microsoft, 2009.<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">https://en.wikipedia.org/wiki/Win32_Thread_Information_Block</a><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a><li><a href="https://www.aldeid.com/wiki/PE-Portable-executable">https://www.aldeid.com/wiki/PE-Portable-executable</a><li><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a><li><a href="https://infoslack.com/devops/linux-101-arquitetura">https://infoslack.com/devops/linux-101-arquitetura</a><li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a><li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a><li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a><li><a href="https://cheatsheet.sec4us.com.br/shellcoding">https://cheatsheet.sec4us.com.br/shellcoding</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cria%C3%A7%C3%A3o-de-exploits/'>Criação de Exploits</a>, <a href='/categories/offensive-security/'>Offensive Security</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/offensive-security/" class="post-tag no-text-decoration" >Offensive Security</a> <a href="/tags/buffer-overflow/" class="post-tag no-text-decoration" >Buffer Overflow</a> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >Shellcoding</a> <a href="/tags/osed/" class="post-tag no-text-decoration" >OSED</a> <a href="/tags/osee/" class="post-tag no-text-decoration" >OSEE</a> <a href="/tags/osce3/" class="post-tag no-text-decoration" >OSCE3</a> <a href="/tags/pentest/" class="post-tag no-text-decoration" >Pentest</a> <a href="/tags/cria%C3%A7%C3%A3o-de-exploits/" class="post-tag no-text-decoration" >Criação de Exploits</a> <a href="/tags/windows-internals/" class="post-tag no-text-decoration" >Windows Internals</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api - Helvio Junior&u=https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api - Helvio Junior&url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/"><div class="card-body"> <span class="timeago small" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.</h3><div class="text-muted small"><p> Introduction In this article, we will dissect the Metasploit 32 bits library called Block API, responsible for dynamically locating the addresses of functions within the loaded modules in the appl...</p></div></div></a></div><div class="card"> <a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/"><div class="card-body"> <span class="timeago small" > Sep 14, 2021 <i class="unloaded">2021-09-14T15:26:04-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</h3><div class="text-muted small"><p> Introdução Meu nome é Hélvio Junior, também conhecido como M4v3r1ck. Para quem me conhece, sabe da minha paixão estudo sobre low level exploitation, envolvendo buffer overflow, process injection e...</p></div></div></a></div><div class="card"> <a href="/it/oswe-uma-historia-de-insucessos/"><div class="card-body"> <span class="timeago small" > Dec 29, 2020 <i class="unloaded">2020-12-29T21:31:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OSWE - Uma história de insucessos!</h3><div class="text-muted small"><p> Minha Jornada para a Certificação OSWE Estamos vivendo em um ano que certamente ficará marcado na história da humanidade, mas de forma especial na vida de muitos de nós. Desta forma, decidi escrev...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/oswe-uma-historia-de-insucessos/" class="btn btn-outline-primary" prompt="Older"><p>OSWE - Uma história de insucessos!</p></a> <a href="/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" class="btn btn-outline-primary" prompt="Newer"><p>Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api'; this.page.url = 'https://www.helviojunior.com.br/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/'; this.page.identifier = '/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
