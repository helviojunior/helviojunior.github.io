---
layout: post
title: Criação de Exploits - Parte 0 - Um pouco de teoria
date: 2018-09-30 17:45:47.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Criação de Exploits
tags: []
meta:
  _edit_last: '1'
  _yoast_wpseo_content_score: '30'
  _yoast_wpseo_primary_category: '80'
  _aviaLayoutBuilder_active: ''
  _aviaLayoutBuilderCleanData: ''
  layout: ''
  sidebar: ''
  footer: ''
  header_title_bar: ''
  header_transparency: ''
  _avia_hide_featured_image: '0'
  _yoast_wpseo_metadesc: Veja nesta série passo-a-passo como realizar a criação de
    exploits. Passo 0 - Um pouco de teoria
  _syntaxhighlighter_encoded: '1'
  _av_alb_posts_elements_state: a:0:{}
  _av_el_mgr_version: '1.0'
  _av_alb_element_mgr_version: 1.0.1
  _av_css_styles: a:6:{s:7:"post_id";i:1815;s:8:"css_file";s:13:"post-1815.css";s:9:"timestamp";s:0:"";s:6:"status";s:6:"no_css";s:13:"processed_ids";a:0:{}s:13:"include_posts";a:0:{}}
author: Helvio Junior (m4v3r1ck)







permalink: "/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/"
---
<p>Neste post irei inaugurar uma nova seção do site onde postarei uma série de tutoriais de como realizar a criação de exploits, a maioria deles, utilizando Buffer Overflow.</p>
<p>Caso você deseje segue o link para a lista completa de posts sobre a criação de exploits e buffer overflow: <a href="https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/">https://www.helviojunior.com.br/category/it/security/criacao-de-exploits/</a></p>
<p>Mas antes de começar a colocar a mão na massa, como sempre, precisamos de um pouco de teoria para embasar e entender todo o contexto, e como quando falamos de Buffer Overflow, falamos de memória, pilha, push pop, assembly e etc... nada é tão simples e tão trivial, então se posso dar uma recomendação é: leia e releia toda a teoria, busque outros sites, outros livros, outras referencias para complementar o seu conhecimento, pois isso será base para o sucesso ou falha no momento da criação dos seus exploits.</p>
<p>Segue a referência de um site onde tem bastante conteúdo sobre este assunto: <a href="https://www.corelan.be">https://www.corelan.be</a></p>
<p><!--more--></p>
<h2>Antes de mais nada, o que é Buffer Overflow?</h2>
<p><em>Weidman</em> define<em> Buffer Overflow </em>como "o processo pelo qual manipulamos a memória de uma aplicação de forma que preenchemos mais dados do que a aplicação esperava receber extrapolando o tamanho da variável no stack de memória e sobrepondo o espaço de memória adjacente". Se um pedaço de memória crítica for sobreposta a aplicação irá falhar/gerar uma exceção/erro. Com um pouco de técnica e cuidado podemos sobrepor partes importantes e controlar o fluxo de execução da aplicação após essa falha.</p>
<h2></h2>
<h2>Definição de ambiente</h2>
<p>Antes de mais nada é importante ressaltar que todos os procedimentos que explicarei nessa série de posts são baseados em Microsoft Windows com aplicação rodando em 32 bits.</p>
<h2></h2>
<h2>Arquitetura e Memória</h2>
<p>Antes de ir a fundo em Buffer Overflow e criação de Exploits certamente precisamos entender como a memória funciona, pois o princípio base de Buffer Overflow é a manipulação de memória. Nosso objetivo final sempre será manipular a memória de forma que aplicação execute o que vamos inserir nela.</p>
<p>Quando se estuda a arquitetura de um ambiente computacional há uma sistema hierárquico de proteção conhecido como <a href="https://en.wikipedia.org/wiki/Protection_ring">Protection Ring</a>, basicamente isso é um mecanismo de proteção e tolerância a falhas dos sistemas. Em um ambiente Windows 32 bits o endereçamento de memória vai de 0x00000000 a 0xFFFFFFFF, onde se divide em duas faixas: a primeira que vai de 0x00000000 a 0x7FFFFFFF é atribuída ao Ring 3 - User-land, e a segunda vai de 0x80000000 a 0xFFFFFFFF que é atribuída ao Ring 0 - Kernel-land. O Endereçamento de memória dentro do kernel-land somente é acessível pelo Sistema Operacional.</p>
<p>O Windows utiliza um modelo de endereçamento de memória conhecido como <a href="http://en.wikipedia.org/wiki/Flat_memory_model" target="_blank" rel="noopener">flat memory model</a>, que basicamente indica que a memória aparece para as aplicações como um único espaço contínuo. A CPU pode diretamente (and linearmente) endereçar toda memória disponível sem a necessidade de utilizar segmentação/paginação de memória.</p>
<h2></h2>
<h2>Memória</h2>
<p>Primeiro precisamos entender um pouco mais como é a memória de um aplicativo, veja a imagem abaixo:</p>
<p>[caption id="attachment_1826" align="alignnone" width="300"]<a href="http://www.helviojunior.com.br/wp-content/uploads/2018/09/001-memory_visualization.png"><img class="wp-image-1826 size-medium" src="{{ site.baseurl }}/assets/2018/09/001-memory_visualization-300x258.png" alt="" width="300" height="258" /></a> Visualização da memória[/caption]</p>
<p>Cada aplicação utiliza parte da memória, a aplicação contém basicamente alguns segmentos de memória, conforme abaixo:</p>
<ul>
<li>segmento de código (text): código do programa a ser executado</li>
<li>segmento data: informações globais da aplicação, estes dados são carregados no momento do início da aplicação, são estáticos (não mudam enquanto o programa está rodando) e estão disponíveis para a toda a aplicação</li>
<li>segmento pilha (stack): tem tamanho fixo e é usado para armazenar argumentos das funções e variáveis locais.</li>
<li>segmento heap: armazena as variáveis dinâmicas</li>
</ul>
<p>Embora a imagem mostre varias seções ordenadas, não existe uma garantia que essa ordem sempre será a ordem na sua aplicação pois elas podem ser alocadas em qualquer ordem desejada.</p>
<p>Em uma arquitetura baseada em Intel x86 (32 bits) temos os seguintes registradores de uso geral:</p>
<ul>
<li><strong>EAX</strong> : acumulador : utilizado para realizar cálculos e para armazenar valores de retorno em chamadas de função. Operações básicas como adição, subtração e comparação utilizam este registrador</li>
<li><strong>EBX</strong> : base : Não há um propósito geral para este registrador, mas pode ser utilizado para armazenar dados</li>
<li><strong>ECX</strong> : contador : utilizado para interações/laços/loops. ECX conta de forma decrescente.</li>
<li><strong>EDX</strong> : data : ele é uma extensão para o EAX pois possibilita calculos mais complexos como multiplicação e divisão permitindo o armazenamento de dados extras para facilitar estes cálculos.</li>
<li><strong>ESP</strong> : ponteiro do topo da pilha (stack pointer)</li>
<li><strong>EBP</strong> : ponteiro da base da pilha (base pointer)</li>
<li><strong>ESI</strong> :  índice de origem (source index) : mantém a localização dos dados de entrada</li>
<li><strong>EDI</strong> : índice de destino (destination index) : mantém a localização onde o dado do resultado da operação é armazenado</li>
<li><strong>EIP</strong> : ponto de instrução (instruction pointer) : mantém o ponto de memória do código da próxima instrução</li>
</ul>
<p>Os registradores ESP, EBP e EIP são os mais interessantes e utilizados quando o assunto é<em> Buffer Overflow</em>. Conforme descrito acima e ilustrado na imagem abaixo, o registrador ESP aponta para o início do stack (menor endereço de memória) e o EBP para o final do stack (maior endereço de memória). E o EIP mantém o endereço da próxima instrução a ser executada, por isso, para que a aplicação execute o que desejamos nosso primeiro objetivo em um <em>Buffer Overflow</em> será controlar o EIP.</p>
<p>[caption id="attachment_1831" align="alignnone" width="300"]<a href="http://www.helviojunior.com.br/wp-content/uploads/2018/09/001-stack_frame.png"><img class="wp-image-1831 size-medium" src="{{ site.baseurl }}/assets/2018/09/001-stack_frame-300x145.png" alt="" width="300" height="145" /></a> Stack Frame[/caption]</p>
<h2></h2>
<h2>Registradores</h2>
<p>Em uma arquitetura 32 bits todos os registradores de uso geral possuem 32 bits (4 bytes) de tamanho e em um código assembly podem ser referenciados como 32 ou 16 bits. Por exemplo o EAX é a referencia para 32 bits inteiro e AX é a referencia para 16 bits menores do registrador EAX.</p>
<p>Quatro registradores (EAX, EBX, ECX e EDX) podem ser referenciado também com 8 bits, para 8 bits mais baixo ou o segundo 8 bits mais baixo, AL e AH respectivamente. A imagem abaixo visa demonstrar de forma gráfica essas diversas formas de utilização dos registradores.</p>
<p>[caption id="attachment_1833" align="alignnone" width="300"]<a href="http://www.helviojunior.com.br/wp-content/uploads/2018/09/003-registradores.png"><img class="wp-image-1833 size-medium" src="{{ site.baseurl }}/assets/2018/09/003-registradores-300x211.png" alt="" width="300" height="211" /></a> Registradores[/caption]</p>
<h2></h2>
<h2>Pilha (stack)</h2>
<p>Segundo <em>Foster</em>, A pilha "é uma área de memória usada para manter/armazenar dados temporários. A pilha cresce e reduz durante a execução da aplicação." e após a definição incrementa a informação onde "<em>Buffer Overflow</em> comuns ocorrem na área de memória da pilha" conceito este que veremos logo a seguir como funciona o <em>Stack Buffer Overflow</em>.</p>
<p>A utilização primária da pilha é a troca de dados entre funções. A pilha tem uma arquitetura caracterizada por PUSHs e POPs em um modelo LIFO (last in, first out), ou seja, o ultimo dado a entrar na pilha será o primeiro a sair. Por exemplo, se você empilha (PUSH) os números 1, 2 e 3 nessa ordem, o primeiro número a ser desempilhado será o 3 pois ele foi o último a ser empilhado.</p>
<p>Para alguns ataques mais avançados de Buffer Overflow é extremamente importante entender esse funcionamento e como a manipulação do ESP + a arquitetura LIFO funciona. Se você deseja acessar a pilha diretamente, isso é possível usando o registrador ESP (Stack Pointer), que por sua vez aponta para o top da pilha (menor endereço de memória).</p>
<ul>
<li>Após um PUSH, o ESP irá apontar para um endereço menor (o endereço será decrementado com o tamanho do dado que foi inserido na pilha, em caso de endereço ou ponteiro será 4 bytes)</li>
<li>Depois de um POP, o ESP irá apontar para um endereço maior (o endereço será incrementado com o tamanho do dado que foi retirado da pilha, em caso de endereço ou ponteiro será 4 bytes)</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Stack Buffer Overflow</h2>
<p>Usando o trecho de código C abaixo</p>
<p>[sourcecode language="c"]#include &amp;lt;string.h&amp;gt;<br />
#include &amp;lt;stdio.h&amp;gt;</p>
<p>void function1(char *str){<br />
    char buffer[5];<br />
    strcpy(buffer, str);<br />
}</p>
<p>void main(int argc, char *argv[])<br />
{<br />
    function1(argv[1]);<br />
    printf(&amp;quot;%s\n&amp;quot;, &amp;quot;Executed normally&amp;quot;);<br />
}<br />
[/sourcecode]</p>
<p>Este código, bem simples por sinal, não faz muita coisa útil, mas é extremamente importante para entendermos os conceitos desejados.</p>
<p>Após compilado a execução dessa aplicação, via linha de comando será:  <strong>overflowteste.exe AAAA</strong></p>
<p>Note que a função <em>main</em> resgata o primeiro parâmetro passado pela linha de comando (AAAA) e preenche como parâmetro da função <em>function1,</em> que por sua vez irá copiar este valor dentro da variável local que detém o tamanho máximo de 5 caracteres (bytes).</p>
<blockquote><p>Estes 5 bytes são teóricos, pois como essa variável é uma cadeia (array) de caracteres ela se utiliza de uma função de proteção que o C detém, essa função de proteção sempre adiciona ao final de uma string um caractere conhecido como nullbyte (0), que tem sua representação em hexa 0x00. O nullbyte tem a função de proteger a aplicação e é comumente utilizado nas operações com string para indicar para a aplicação que ali finalizou a string (cadeia de caracteres). Desta forma como a aplicação automaticamente adicionará o nullbyte ao final do nosso texto, teremos a quantidade de caracteres passadas por parâmetro mais o nullbyte, então se passarmos 5 As mais o nullbyte já teríamos uma condição de buffer overflow, pois a variável local só suporta 5 bytes e neste caso teríamos 6.</p></blockquote>
<p>Na linha 11 do código temos a chamada da função <em>function1</em>, sendo assim uma nova pilha será criada para essa função e teremos algo parecido com a imagem abaixo</p>
<p>[caption id="attachment_1837" align="alignnone" width="300"]<a href="http://www.helviojunior.com.br/wp-content/uploads/2018/09/004-stack-after-call-to-function1.png"><img class="wp-image-1837 size-medium" src="{{ site.baseurl }}/assets/2018/09/004-stack-after-call-to-function1-300x250.png" alt="" width="300" height="250" /></a> Pilha (stack) após a chamada da função function1[/caption]</p>
<p>&nbsp;</p>
<p>Note que temos o ESP no topo da pilha, a pilha (que neste caso terá o conteúdo que foi passado para a função) depois a base da pilha (EBP) e por fim o endereço de retorno (EIP), que neste ambiente será o endereço de memória da linha 12 da nossa aplicação, ou seja, o endereço que será utilizado pela nossa aplicação depois que a function1 fizer todo o seu trabalho e a aplicação precisa seguir o fluxo de execução.</p>
<p>Em uma execução da aplicação teremos o seguinte retorno:</p>
<p>[sourcecode language="bash"]overflowtest.exe AAAA<br />
Executed normally<br />
[/sourcecode]</p>
<p>Agora se executarmos a aplicação com um texto maior que 4 caracteres (conforme a linha de comando abaixo), iremos causar a falha na aplicação e teríamos algo similar a imagem abaixo</p>
<p>[sourcecode language="bash"]overflowtest.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br />
[/sourcecode]</p>
<p>[caption id="attachment_1840" align="alignnone" width="300"]<a href="http://www.helviojunior.com.br/wp-content/uploads/2018/09/005-memory-after-overflow.png"><img class="wp-image-1840 size-medium" src="{{ site.baseurl }}/assets/2018/09/005-memory-after-overflow-300x247.png" alt="" width="300" height="247" /></a> Memória depois do strcpy[/caption]</p>
<p>Conforme podemos ver na imagem acima, estouramos o espaço de memória inicialmente atribuído para a variável local (5 bytes), de forma que substituímos diversas informações inclusive (e o mais importante) o endereço de retorno. Neste caso hipotético a aplicação tentará executar o endereço de memória 41414141 (a representação em hexadecimal dos 4 As) o que vai causar uma falha na aplicação pois o endereço de memória 41414141 não faz parte dessa aplicação causando então uma falha de segmentação (segmentation fault).</p>
<blockquote><p>Um alerta aos navegantes: Este é um exemplo básico de stack buffer overflow e sempre temos que tem em mente que até o momento não comentamos de algumas proteções de memória que o Windows em versões mais novas detém como: <em>data execution prevention</em> (DEP) e <em>address space layout randomization</em> (ASLR). Assuntos estes que serão abordados em posts futuros. Sendo assim quando forem brincar com isso use um Windows XP ou Windows Vista.</p></blockquote>
<h2></h2>
<h2>Considerações finais</h2>
<p>Estes foram os conceitos básicos que quis trazer para vocês, espero que tenha sido claro e consistente nos assuntos, que de certa forma são novos e confusos para muitos.</p>
<p>Segue o link do próximo post (<a href="https://www.helviojunior.com.br/it/criacao-de-exploits-parte-1-stack-buffer-overflow/" target="_blank" rel="noopener">Parte 1 - Stack Buffer Overflow</a>), onde veremos na prática como realizar um Buffer Overflow.</p>
<p>&nbsp;</p>
<h3>Fontes:</h3>
<ol>
<li><a href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/">https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/</a></li>
<li>Penetration Testing: A Hands-On Introduction to Hacking de Georgia Weidman</li>
<li>Buffer Overflow Attacks: Detect, exploit, prevent de James C. Foster</li>
</ol>
<p>De forma complementar a este post segue um vídeo com a explicação dos conceitos base do Buffer Overflow:<br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/wLi-dGphpdg?controls=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
