---
layout: post
title: Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca
  block_api
date: 2021-08-15 16:26:52.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Criação de Exploits
tags: []
meta:
  _syntaxhighlighter_encoded: '1'
  _edit_last: '1'
  _yoast_wpseo_content_score: '30'
  _aviaLayoutBuilder_active: ''
  _aviaLayoutBuilderCleanData: ''
  layout: ''
  sidebar: ''
  footer: ''
  header_title_bar: ''
  header_transparency: ''
  _avia_hide_featured_image: '0'
  _oembed_14754e114ea4bde8f1cb5225349f342d: "{{unknown}}"
  _oembed_abf0d53fcac5cf84debb68cec7d848f7: "{{unknown}}"
  _oembed_2bdf3ae46ba31ea4fb98e23d144a1cd7: "{{unknown}}"
  _oembed_9b8359dd2da694fae8b21fede47dd15c: "{{unknown}}"
  _yoast_wpseo_opengraph-title: Encontrando endereço da função dinamicamente. Análise
    da biblioteca block_api
  _yoast_wpseo_opengraph-description: Neste artigo iremos dissecar a biblioteca da
    Metasploit chamada Block API responsável por localizar em tempo de execução o
    endereço das funções dentro dos módulos carregados na aplicação.
  _yoast_wpseo_opengraph-image: http://www.helviojunior.com.br/wp-content/uploads/2021/08/36c41ddc969a4761a25396a46edbf8a3.png
  _yoast_wpseo_opengraph-image-id: '2272'
  _yoast_wpseo_primary_category: '80'
  _av_alb_posts_elements_state: a:0:{}
  _av_el_mgr_version: '1.0'
  _av_alb_element_mgr_version: 1.0.1
  _av_css_styles: a:6:{s:7:"post_id";i:2264;s:8:"css_file";s:13:"post-2264.css";s:9:"timestamp";s:0:"";s:6:"status";s:6:"no_css";s:13:"processed_ids";a:0:{}s:13:"include_posts";a:0:{}}
author:
  login: helvio
  email: helvio_junior@hotmail.com
  display_name: Helvio Junior - M4v3r1ck - OSCE3 (OSEP + OSED + OSWE), OSCE, OSCP,
    eCXD, eMAPT, CEH
  first_name: Helvio
  last_name: Junior - M4v3r1ck - OSCE3 (OSEP + OSED + OSWE), OSCE, OSCP, eCXD, eMAPT,
    CEH
permalink: "/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"
---
<p>Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicação.</p>
<h1>Introdução</h1>
<p>Antes de entrarmos efetivamente no assunto deste post é interessante conceituar algumas coisas: A primeira delas é sobre o termo Shellcoding.</p>
<p>Shellcoding é um termo muito utilizado para designar um código escrito em assembly utilizando durante o processo de exploração de binários (Windows e Linux), seja para criação de um shell reverso, bind shell como para execução de comandos, execução de uma aplicação e etc.</p>
<p>Em um processo de criação de shellcoding temos a possibilidade de trabalhar com 2 estratégias, a primeira delas utilizando Syscall e a segunda utilizando APIs dos subsistemas do sistema operacional.</p>
<p><!--more--></p>
<h2>Arquitetura Windows e Linux</h2>
<p>De forma simplificada a imagem abaixo ilustra a arquitetura do sistema operacional Linux</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png"><img class="alignnone size-full wp-image-2271" src="{{ site.baseurl }}/assets/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png" alt="" width="278" height="202" /></a></p>
<p>Fonte: <a href="https://infoslack.com/devops/linux-101-arquitetura" target="_blank" rel="noopener noreferrer">https://infoslack.com/devops/linux-101-arquitetura</a></p>
<p>Bem como temos a figura abaixo ilustrando a arquitetura do Windows</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/36c41ddc969a4761a25396a46edbf8a3.png"><img class="alignnone size-full wp-image-2272" src="{{ site.baseurl }}/assets/2021/08/36c41ddc969a4761a25396a46edbf8a3.png" alt="" width="532" height="250" /></a></p>
<p>Fonte: Pavel, Y at all. Windows Internals Part 1: 1. ed. Washington: Microsoft, 2017. Pg 47</p>
<h2>Problema do Syscall</h2>
<p>Como observado am ambas arquiteturas (Windows e Linux) temos 2 possibilidades de realizar chamadas para o SO, a primeira delas utilizando as bibliotecas e subsistemas do sistema operacional (glibc, kernel32.dll, user32.dll e etc...), a segunda metodologia é utilizando system calls (ou também conhecida como syscall).</p>
<p>Em um Linux é muito comum e fácil se utilizar as syscalls pois no Linux os IDs das syscalls não se alteram com novas releases, versões e etc, além de serem amplamente documentada. Já em um ambiente Windows não existe uma documentação oficial sobre o tema e é altamente refutado a utilização, pois a cada release do SO os ids das syscalls se alteram, desta forma um shellcode não se torna confiável.</p>
<p>Vale a pena ressaltar que existem técnicas para identificar os IDs da syscall e utiliza-las, mas isso fica para outro artigo.</p>
<p>Desta forma é muito comum em um ambiente windows os shellcodings utilizarem as funções expostas diretamente pelas APIs do windows (ou também conhecidas como subsistemas) que são a Kernel32.dll, user32.dll etc...</p>
<p>Para um melhor aprofundamento recomendo a visualização do vídeo do Rafael Salema falando sobre o assunto <a href="https://www.youtube.com/watch?v=nQNxAje5SxI" target="_blank" rel="noopener noreferrer">Stop calling APIs! Demystifying direct syscall</a></p>
<h2>Objetivo deste artigo</h2>
<p>Como em shellcoding windows geralmente utilizamos as APIs do sistema operacional e estas APIs geralmente executam no sistema operacional com <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="noopener noreferrer">Address space layout randomization - ASLR</a> de forma que a cada execução ou a cada reboot do sistema operacional, bem como a cada compilação da DLL tem-se um endereço diferente para as chamadas de funções.</p>
<p>Sendo assim o shellcode para ser confiável precisa deter um método de identificar dinamicamente o endereço de uma função.</p>
<p>Em nossos treinamentos ensinamos a utilizar as bibliotecas da Metasploit, chamadas Block API, para este fim. Bibliotecas disponíveis em:</p>
<ul>
<li><strong>32 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="noopener noreferrer">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></li>
<li><strong>64 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm" target="_blank" rel="noopener noreferrer">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a></li>
</ul>
<p>Inclusive temos um mini-treinamento disponível em nosso canal do Youtube sobre Shellcoding para 64 bits: <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=ySKEF8MHcZA</a> utilizando essa biblioteca.</p>
<p>O que faremos neste artigo é entender passo a passo (dissecar) o que essa biblioteca realiza, quais estruturas, tabelas e dados da aplicação ela analisa para chegar a identificar de forma precisa o endereço exato da função dentro do Windows.</p>
<p>Sendo assim este artigo focará somente no sistema operacional Windows.</p>
<h2>Conceitos e referencias complementares</h2>
<p>Durante este estudo iremos falar de diversos assuntos e daremos ênfase/aprofundamento somente naquilo que é pertinente para o nosso estudo, sendo assim para um melhor entendimento e aprofundamento recomendo a consulta aos seguintes materiais:</p>
<ul>
<li>Windows PE Format: PE é o acronimo de Portable Executable, que na prática é qualquer binário executável no windows incluindo .exe, .dll. Especificações técnicas: <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format e https://www.aldeid.com/wiki/PE-Portable-executable" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format e https://www.aldeid.com/wiki/PE-Portable-executable</a></li>
<li>Intel® 64 and IA-32 Architectures Software Developer Manuals: Este manual traz de forma detalhada diversas questões de desenvolvimento para Intel, mas o foco que utilizamos é para o entendimento das principais instruções Assembly utilizadas neste artigo: <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html" target="_blank" rel="noopener noreferrer">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a></li>
<li>WinDBG: Neste artigo utilizaremos o WinDBG como debugger disponível em: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></li>
<li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=ySKEF8MHcZA</a></li>
</ul>
<p><strong>Nota:</strong> Caso não tenha familiaridade com instruções assembly, ponteiros e pilha, recomendo antes da continuidade da leitura a visualização desta aula do Youtube <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=ySKEF8MHcZA</a> pois nesta aula é apresentada diversos conceitos extremamente necessários para o entendimento deste artigo.</p>
<h2>Instalando WinDbg</h2>
<p>Para realizar a instalação do WinDBG faça o download do SDK do Windows 10 disponível em: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png"><img class="alignnone size-full wp-image-2273" src="{{ site.baseurl }}/assets/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png" alt="" width="1492" height="526" /></a></p>
<p>Após instalado realize a configuração do local de armazenamento e download dos símbolos de debug.</p>
<p>Abra o WinDBG x68 e vá em File &gt; Symbol File Path e adicione o conteúdo abaixo</p>
<p>[sourcecode language="shell"]<br />
srv*c:\symbols*c:\symbols*http://msdl.microsoft.com/download/symbols<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png"><img class="alignnone size-full wp-image-2274" src="{{ site.baseurl }}/assets/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png" alt="" width="1160" height="556" /></a></p>
<p>Carregue uma aplicação qualquer em 32 bits como</p>
<p>[sourcecode language="shell"]<br />
C:\Windows\SysWOW64\notepad.exe<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/f50155a62904444dae9b7655288ae33f.png"><img class="alignnone size-full wp-image-2275" src="{{ site.baseurl }}/assets/2021/08/f50155a62904444dae9b7655288ae33f.png" alt="" width="1400" height="930" /></a></p>
<p>Recarregue todos os simbolos</p>
<p>[sourcecode language="shell"]<br />
.reload /f<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/388d8891016e4654a101bc40fb85bc0b.png"><img class="alignnone size-full wp-image-2276" src="{{ site.baseurl }}/assets/2021/08/388d8891016e4654a101bc40fb85bc0b.png" alt="" width="1372" height="784" /></a></p>
<h2>Process Internals</h2>
<p>Cada processo windows é representado por um bloco EPROCESS (Executive Process), o bloco EPROCESS contem uma série de apontamentos para um numero grande de outras estruturas, por exemplo ETHREADS, TEB, PED entre outras.</p>
<p>A Figura abaixo simplifica o diagrama das estruturas do processo e threads.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/d817862488ea47d683756ffa2da72a85.png"><img class="alignnone size-full wp-image-2277" src="{{ site.baseurl }}/assets/2021/08/d817862488ea47d683756ffa2da72a85.png" alt="" width="388" height="369" /></a><br />
Fonte: Russinovich, M at all. Windows Internals: 5. ed. Washington: Microsoft, 2009. Pg 336</p>
<p>Para nosso estudo vale ressaltar uma tabela extremamente importante que é a TEB (Thread Environment Block), por compatibilidade também conhecida como TIB (Thread Information Block). A TEB pode ser utilizada para obter uma série de informações do processo sem a necessidade de realizar chamadas para as APIs Win32. Entre outras informações armazena o endereço do SEH e o endereço da tabela PEB (Process Environment Block), que por sua vez através da PEB pode-se obter acesso a IAT (Import Address Table) e muito mais.<br />
A TEB pode pode ser acessada através do registrador de segmento FS.</p>
<h3>Loader</h3>
<p>No momento da inicialização do aplicativo uma série de atividades são realizadas. Na prática o loader é executado antes do código da própria aplicação de forma que o mesmo é transparente ao usuário. Dentre as atividades em que o loader é responsável iremos destacar duas que são importantes para nosso estudo:</p>
<ul>
<li>Tratar a IAT (Import Address Table) da aplicação e olhar para todas as DLLs que a aplicação necessita, bem como analisar recursivamente a IAS de todas as DLLs carregadas, seguido da análise da tabela de exportação das DLLs para ter certeza que as funções desejadas estão presentes.</li>
<li>Carregar e descarregar DLLs em tempo de execução, mesmo as carregadas sobre demanda e manter a lista de todos os módulos conhecida como Módules Database ou também como LDR (Loader Data Table).</li>
</ul>
<h2>Análise da block api 32 bits</h2>
<p>A biblioteca da Block API está disponível no github da Metasploit em <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="noopener noreferrer">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></p>
<h3>Utilização</h3>
<p>Antes de adentrarmos a análise do código da BlockAPI vamos a um exemplo de utilização.</p>
<p>Neste exemplo iremos utilizar a função ExitProcess documentada em <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess</a></p>
<p>Tendo sua sintaxe como abaixo:</p>
<p>[sourcecode language="shell"]<br />
void ExitProcess(<br />
  UINT uExitCode<br />
);<br />
[/sourcecode]</p>
<p>&nbsp;</p>
<h4>Código C</h4>
<p>[sourcecode language="shell"]<br />
#include &lt;Windows.h&gt;<br />
#include &lt;stdio.h&gt;</p>
<p>void main(){</p>
<p>    ExitProcess(0);</p>
<p>}<br />
[/sourcecode]</p>
<h4>Hash da api</h4>
<p>A block_api espera como entrada no topo da pilha o hash da função desejada seguido dos parâmetros da função.</p>
<p>Para o cálculo do hash da função utilizaremos uma aplicação desenvolvida por mim disponível em <a href="https://github.com/helviojunior/addrfinder" target="_blank" rel="noopener noreferrer">https://github.com/helviojunior/addrfinder</a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png"><img class="alignnone size-full wp-image-2278" src="{{ site.baseurl }}/assets/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png" alt="" width="1222" height="334" /></a></p>
<p>Note que o hash da função <strong>ExitProcess</strong> é <strong>0x56A2B5F0</strong>, este hash não se altera mesmo em releases diferentes do windows.</p>
<h4>Assembly - utilizando a block_api</h4>
<p>[sourcecode language="shell"]<br />
[BITS 32]</p>
<p>global _start</p>
<p>_start:<br />
    jmp short block_api</p>
<p>get_block_api:<br />
    pop edi                     ; Copia o endereço da block_api no registrador edi</p>
<p>                                ; Sai da aplicação sem aprentar erro<br />
    xor eax,eax                 ; Zera EAX<br />
    push eax                    ; Coloca na pilha o &quot;exit code&quot; = 0x00</p>
<p>                                ; Realiza a chamada da função ExitProcess<br />
    push 0x56A2B5F0             ; Coloca o endereço do hash função ExitProcess na pilha<br />
    call edi                    ; Executa a block_api para localizar e executar a função</p>
<p>block_api:<br />
    call get_block_api<br />
    %include &quot;../block_api.asm&quot;<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/5033fcd6f11140fcb573c532cee9d279.png"><img class="alignnone size-full wp-image-2279" src="{{ site.baseurl }}/assets/2021/08/5033fcd6f11140fcb573c532cee9d279.png" alt="" width="1920" height="846" /></a></p>
<p>Como podemos observar no código acima na linha 22 realizamos a inclusão do arquivo da biblioteca (exatamente o mesmo arquivo listado no link do github acima)</p>
<p>Utilizando a estratégia de JMP; Call; POP salvamos o endereço da primeira instrução da block_api no registrador EDI</p>
<p>Sendo assim podemos colocar na pilha de forma que ficará como abaixo:</p>
<ul>
<li>ESP + 0x00 = 0x56A2B5F0</li>
<li>ESP + 0x04 = 0x00000000</li>
</ul>
<p>E posteriormente executamos a block_api através da instrução <strong>call edi</strong></p>
<h4>Montagem e executando</h4>
<p>Para a montagem (conversão dos mnemônico ASM para binário/hexa) utilizaremos o NASM e para a execução utilizaremos o ShellcodeTester (Disponível em <a href="https://github.com/helviojunior/shellcodetester" target="_blank" rel="noopener noreferrer">https://github.com/helviojunior/shellcodetester</a>)</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/117c5675f98f4c608304ce20b0fde377.png"><img class="alignnone size-full wp-image-2280" src="{{ site.baseurl }}/assets/2021/08/117c5675f98f4c608304ce20b0fde377.png" alt="" width="1920" height="669" /></a></p>
<p>Podemos ver que a montagem ocorreu com sucesso, agora podemos abrir no shellcode tester Arquivo &gt; Abrir e selecione o <strong>exit.o</strong></p>
<p>Selecione as opções <strong>32 bits</strong> e <strong>Adicionar um breakpoint antes do shellcode</strong> e clique em Executar</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/a96eebb6fc5c4d229fbb4c5c1ef41feb.png"><img class="alignnone size-full wp-image-2281" src="{{ site.baseurl }}/assets/2021/08/a96eebb6fc5c4d229fbb4c5c1ef41feb.png" alt="" width="1700" height="1054" /></a></p>
<p>Neste momento aparecerá um alerta para anexar o debugger</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/850cad29f9314944ad4706bfacb19041.png"><img class="alignnone size-full wp-image-2282" src="{{ site.baseurl }}/assets/2021/08/850cad29f9314944ad4706bfacb19041.png" alt="" width="872" height="356" /></a></p>
<p><span style="color: #ff0000;"><strong>NÃO clique em OK</strong></span>, vá no Windbg clique em File &gt; Attach to Process</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/c99d8980034544f4ad90054bbaff8da7.png"><img class="alignnone size-full wp-image-2283" src="{{ site.baseurl }}/assets/2021/08/c99d8980034544f4ad90054bbaff8da7.png" alt="" width="1050" height="522" /></a></p>
<p>Selecione o processo <strong>runner.exe</strong></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/bedaad542bd641378f9b533b3094fb93.png"><img class="alignnone size-full wp-image-2284" src="{{ site.baseurl }}/assets/2021/08/bedaad542bd641378f9b533b3094fb93.png" alt="" width="840" height="824" /></a></p>
<p>Na linha de comando do WinDbg digite g (de GO) para continuar a execução e pressione enter</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/76b862ca0c354dd4b08d5f795c3abc15.png"><img class="alignnone size-full wp-image-2285" src="{{ site.baseurl }}/assets/2021/08/76b862ca0c354dd4b08d5f795c3abc15.png" alt="" width="1920" height="1156" /></a></p>
<p>Após isso a mensagem <strong>Debuggee is running...</strong> deve aparecer</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/a7d19e909f3941b5ba4e62f0952d074d.png"><img class="alignnone size-full wp-image-2286" src="{{ site.baseurl }}/assets/2021/08/a7d19e909f3941b5ba4e62f0952d074d.png" alt="" width="1920" height="1151" /></a></p>
<p>Agora volte no alerta e pressione OK</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/850cad29f9314944ad4706bfacb19041.png"><img class="alignnone size-full wp-image-2282" src="{{ site.baseurl }}/assets/2021/08/850cad29f9314944ad4706bfacb19041.png" alt="" width="872" height="356" /></a></p>
<p>Neste momento uma mensagem aparecerá na console do WinDBG</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/19703e5c46704abda4add7881e27b36b.png"><img class="alignnone size-full wp-image-2287" src="{{ site.baseurl }}/assets/2021/08/19703e5c46704abda4add7881e27b36b.png" alt="" width="1920" height="1153" /></a></p>
<h2>Análise do nosso shellcode</h2>
<p>Antes de chegar efetivamente na biblioteca da block api nós temos algumas instruções das quais podemos colocar lado a lado com nosso código</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png"><img class="alignnone size-full wp-image-2289" src="{{ site.baseurl }}/assets/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png" alt="" width="1920" height="765" /></a></p>
<p>Como o foco é na execução da própria block_api vamos até o ponto da chamada <strong>call edi</strong></p>
<p>Neste momento temos no registrador EDI o endereço da block_api</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/19c8531c17944b009ff8244113f6172f.png"><img class="alignnone size-full wp-image-2290" src="{{ site.baseurl }}/assets/2021/08/19c8531c17944b009ff8244113f6172f.png" alt="" width="1920" height="1151" /></a></p>
<p>E começaremos a nossa análise deste ponto</p>
<h2>Análise da block_api</h2>
<p>Para facilitar o processo de análise vou colocando o código da block_api conforme formos evoluindo no mesmo.</p>
<h3>Tabelas</h3>
<p>Como comentado anteriormente há uma série de tabelas existentes e utilizadas em nosso aplicativo, sendo assim segue um diagrama com o fluxo que realizaremos na próximas instruções</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/fb50b1ae0c2247498d36b0864c28432a.png"><img class="alignnone size-full wp-image-2291" src="{{ site.baseurl }}/assets/2021/08/fb50b1ae0c2247498d36b0864c28432a.png" alt="" width="900" height="308" /></a></p>
<p>Primeiramente utilizaremos o registrador de segmento FS em seu offset 0x30 para obter o endereço relativo (offset) de memória da tabela TEB, posteriormente pegaremos de dentro da TEB em seu offset 0x0C o endereço da tabela LDR e por fim dentro da tabela LDR pegaremos o endereço de memória do primeiro elemento da array InMemoryOrderModuleList.</p>
<h3>Termos de memória</h3>
<h4>VRA (Virtual Relative Addres)</h4>
<p>Daqui para frente utilizaremos o termo VRA (Virtual Relative Address) este termo refere-se a um endereço de memória relativo ao Base Address (ou também conhecido como Offset), de forma que o offset de uma DLL só se altera se houver a recompilação da mesma, o que o ASLR interfere é no BaseAddress, este sim se altera a cada reboot da maquina ou a cada execução da aplicação.</p>
<h4>VMA (Virtual Memory Address)</h4>
<p>O VMA é igual ao VRA + BaseAddress, ou seja o endereço virtual que pode ser utilizado dentro da aplicação.</p>
<h3>Função api_call</h3>
<p>Segue abaixo o trecho de código da primeira função api_call</p>
<p>[sourcecode language="shell"]<br />
api_call:<br />
  pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.<br />
  mov ebp, esp               ; Create a new stack frame<br />
  xor edx, edx               ; Zero EDX<br />
  mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB<br />
  mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr<br />
  mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list<br />
[/sourcecode]</p>
<h4>pushad</h4>
<p>Pushad é uma instrução que coloca na pilha todos os registradores, em outras palavras, salva o valor de todos os registradores na pilha. Este processo consome 20 bytes da pilha</p>
<h4>mov ebp, esp</h4>
<p>Copia o endereço do topo da pilha para ebp. Este processo é conhecido como prólogo de uma função, ou seja, está igualando ESP e EBP para iniciar um novo <strong>stack frame</strong></p>
<h4>xor edx, edx</h4>
<p>A operação matematica XOR de um valor com ele mesmo sempre resultará em Zero, sendo assim esta instrução zera o valor do registrador EDX</p>
<h4>mov edx, [fs:edx+0x30]</h4>
<p>Copia o VRA da PEB para dentro do registrador EDX</p>
<p>Dentro do windbg podemos visualizar essa informação com o comando abaixo</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt nt!_TEB @$teb<br />
ntdll!_TEB<br />
   +0x000 NtTib            : _NT_TIB<br />
   +0x01c EnvironmentPointer : (null)<br />
   +0x020 ClientId         : _CLIENT_ID<br />
   +0x028 ActiveRpcHandle  : (null)<br />
   +0x02c ThreadLocalStoragePointer : 0x0146a988 Void<br />
   +0x030 ProcessEnvironmentBlock : 0x010da000 _PEB<br />
   +0x034 LastErrorValue   : 0<br />
   +0x038 CountOfOwnedCriticalSections : 0<br />
   +0x03c CsrClientThread  : (null)<br />
   +0x040 Win32ThreadInfo  : (null)<br />
   +0x044 User32Reserved   : [26] 0<br />
   +0x0ac UserReserved     : [5] 0<br />
   +0x0c0 WOW32Reserved    : 0x77c16000 Void<br />
   +0x0c4 CurrentLocale    : 0x409<br />
   +0x0c8 FpSoftwareStatusRegister : 0<br />
   +0x0cc ReservedForDebuggerInstrumentation : [16] (null)<br />
   +0x10c SystemReserved1  : [26] (null)<br />
   +0x174 PlaceholderCompatibilityMode : 0 ''<br />
   +0x175 PlaceholderHydrationAlwaysExplicit : 0 ''<br />
   +0x176 PlaceholderReserved : [10]  &quot;&quot;<br />
   +0x180 ProxiedProcessId : 0<br />
[/sourcecode]</p>
<p>E confirmando a informação após a execução da instrução</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/21769f1837a241d0b7dcf1cc39f28526.png"><img class="alignnone size-full wp-image-2292" src="{{ site.baseurl }}/assets/2021/08/21769f1837a241d0b7dcf1cc39f28526.png" alt="" width="1920" height="718" /></a></p>
<h4>mov edx, [edx+0xc]</h4>
<p>Copia o VRA da LDR para dentro do registrador EDX</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt nt!_PEB 0x010da000<br />
ntdll!_PEB<br />
   +0x000 InheritedAddressSpace : 0 ''<br />
   +0x001 ReadImageFileExecOptions : 0 ''<br />
   +0x002 BeingDebugged    : 0x1 ''<br />
   +0x003 BitField         : 0 ''<br />
   +0x003 ImageUsesLargePages : 0y0<br />
   +0x003 IsProtectedProcess : 0y0<br />
   +0x003 IsImageDynamicallyRelocated : 0y0<br />
   +0x003 SkipPatchingUser32Forwarders : 0y0<br />
   +0x003 IsPackagedProcess : 0y0<br />
   +0x003 IsAppContainer   : 0y0<br />
   +0x003 IsProtectedProcessLight : 0y0<br />
   +0x003 IsLongPathAwareProcess : 0y0<br />
   +0x004 Mutant           : 0xffffffff Void<br />
   +0x008 ImageBaseAddress : 0x00f40000 Void<br />
   +0x00c Ldr              : 0x77d40c40 _PEB_LDR_DATA<br />
   +0x010 ProcessParameters : 0x013d19d0 _RTL_USER_PROCESS_PARAMETERS<br />
   +0x014 SubSystemData    : (null)<br />
   +0x018 ProcessHeap      : 0x013d0000 Void<br />
   +0x01c FastPebLock      : 0x77d409e0 _RTL_CRITICAL_SECTION<br />
   +0x020 AtlThunkSListPtr : (null)<br />
   +0x024 IFEOKey          : (null)<br />
   +0x028 CrossProcessFlags : 9<br />
   +0x028 ProcessInJob     : 0y1<br />
   +0x028 ProcessInitializing : 0y0<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/637cc9ff49334ee78bcf36a095d040ea.png"><img class="alignnone size-full wp-image-2293" src="{{ site.baseurl }}/assets/2021/08/637cc9ff49334ee78bcf36a095d040ea.png" alt="" width="1920" height="753" /></a></p>
<h4>mov edx, [edx+0x14]</h4>
<p>Copia o VRA do primeiro elemento da array <strong>InMemoryOrderModuleList</strong> da tabela LDR para o registrador EDX.</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt _PEB_LDR_DATA 0x77d40c40<br />
ntdll!_PEB_LDR_DATA<br />
   +0x000 Length           : 0x30<br />
   +0x004 Initialized      : 0x1 ''<br />
   +0x008 SsHandle         : (null)<br />
   +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x13d32a0 - 0x140d710 ]<br />
   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x13d32a8 - 0x140d718 ]<br />
   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x13d31c8 - 0x140d670 ]<br />
   +0x024 EntryInProgress  : (null)<br />
   +0x028 ShutdownInProgress : 0 ''<br />
   +0x02c ShutdownThreadId : (null)<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8d5afbd757e84622bee6ac7587f5d806.png"><img class="alignnone size-full wp-image-2294" src="{{ site.baseurl }}/assets/2021/08/8d5afbd757e84622bee6ac7587f5d806.png" alt="" width="1920" height="688" /></a></p>
<p>Neste ponto temos em <strong>EDX</strong> o VRA do primeiro elemento da lista duplamente encadeada <strong>InMemoryOrderModuleList</strong>.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/263625546a4046e3b33d92971fae19ea.png"><img class="alignnone size-full wp-image-2295" src="{{ site.baseurl }}/assets/2021/08/263625546a4046e3b33d92971fae19ea.png" alt="" width="1678" height="864" /></a></p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt _LIST_ENTRY (0x77d40c40 + 0x14)<br />
ntdll!_LIST_ENTRY<br />
 [ 0x13d32a8 - 0x140d718 ]<br />
   +0x000 Flink            : 0x013d32a8 _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]<br />
   +0x004 Blink            : 0x0140d718 _LIST_ENTRY [ 0x77d40c54 - 0x140d878 ]</p>
<p>[/sourcecode]</p>
<p>Essa informação não parece muito útil, mas conforme podemos visualizar na documentação (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a>) a estrutura LIST_ENTRY faz parte de uma estrutura maior chamada _LDR_DATA_TABLE_ENTRY</p>
<p>[sourcecode language="shell"]<br />
typedef struct _LIST_ENTRY {<br />
   struct _LIST_ENTRY *Flink;<br />
   struct _LIST_ENTRY *Blink;<br />
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</p>
<p>typedef struct _LDR_DATA_TABLE_ENTRY {<br />
    PVOID Reserved1[2];<br />
    LIST_ENTRY InMemoryOrderLinks;<br />
    PVOID Reserved2[2];<br />
    PVOID DllBase;<br />
    PVOID EntryPoint;<br />
    PVOID Reserved3;<br />
    UNICODE_STRING FullDllName;<br />
    BYTE Reserved4[8];<br />
    PVOID Reserved5[3];<br />
    union {<br />
        ULONG CheckSum;<br />
        PVOID Reserved6;<br />
    };<br />
    ULONG TimeDateStamp;<br />
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;<br />
[/sourcecode]</p>
<p>Para realizar o dump da estrutura temos de subtrair 0x08 do endereço da _LIST_ENTRY com o objetivo de encontrar o início da estrutura _LDR_DATA_TABLE_ENTRY</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt _LDR_DATA_TABLE_ENTRY (013d32a8 - 0x8)<br />
ntdll!_LDR_DATA_TABLE_ENTRY<br />
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x13d31b8 - 0x77d40c4c ]<br />
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]<br />
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]<br />
   +0x018 DllBase          : 0x00f40000 Void<br />
   +0x01c EntryPoint       : (null)<br />
   +0x020 SizeOfImage      : 0xa2000<br />
   +0x024 FullDllName      : _UNICODE_STRING &quot;C:\Tools\ShellcodeTester\Runner.exe&quot;<br />
   +0x02c BaseDllName      : _UNICODE_STRING &quot;Runner.exe&quot;<br />
   +0x034 FlagGroup        : [4]  &quot;???&quot;<br />
   +0x034 Flags            : 0x14022c4<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png"><img class="alignnone size-full wp-image-2296" src="{{ site.baseurl }}/assets/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png" alt="" width="1674" height="954" /></a></p>
<h3>Função next_mod</h3>
<p>[sourcecode language="shell"]<br />
next_mod:                    ;<br />
  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)<br />
  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check<br />
  xor edi, edi               ; Clear EDI which will store the hash of the module name<br />
[/sourcecode]</p>
<h4>mov esi, [edx+0x28]</h4>
<p>Copia o VMA do nome do módulo</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; du @esi<br />
013d1eb6  &quot;Runner.exe&quot;<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png"><img class="alignnone size-full wp-image-2297" src="{{ site.baseurl }}/assets/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png" alt="" width="1920" height="704" /></a></p>
<h4>movzx ecx, word [edx+0x26]</h4>
<p>Recupera o tamanho do nome do módulo, lembrando que cada caractere em unicode corresponde a 2 bytes e temos mais os 2 null bytes no final</p>
<p>Em nosso cenário:</p>
<ul>
<li>Runner.exe = 10 Caracteres + 1 null byte</li>
<li>11 * 2 = 22</li>
</ul>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png"><img class="alignnone size-full wp-image-2298" src="{{ site.baseurl }}/assets/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png" alt="" width="1920" height="675" /></a></p>
<h4>xor edi, edi</h4>
<p>Zera o EDI para utilizar como local de armazenamento do hash do nome do módulo</p>
<h3>Função loop_modname</h3>
<p>[sourcecode language="shell"]<br />
loop_modname:                ;<br />
  xor eax, eax               ; Clear EAX<br />
  lodsb                      ; Read in the next byte of the name<br />
  cmp al, 'a'                ; Some versions of Windows use lower case module names<br />
  jl not_lowercase           ;<br />
  sub al, 0x20               ; If so normalise to uppercase<br />
[/sourcecode]</p>
<h4>xor eax, eax</h4>
<p>Zera EAX</p>
<h4>lodsb</h4>
<p>Carrega o primeiro byte vindo do ESI para o registrador AL.</p>
<h4>cmp al, 'a'</h4>
<p>Compara o byte recebido com o caractere 'a'</p>
<h4>jl not_lowercase</h4>
<p>Antes de vermos a comparação propriamente dita vamos analisar a tabela ASCII</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png"><img class="alignnone size-full wp-image-2299" src="{{ site.baseurl }}/assets/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png" alt="" width="1920" height="1277" /></a></p>
<p>Observe na tabela ASCII que o alfabeto minúsculo vai do hexa-decimal 0x61 até 0x7a e o maiúsculo vai de 0x41 a 0x5a, então:</p>
<ul>
<li>O minúsculo é exatamente 0x20 bytes que sua representação em maiúsculo</li>
<li>O hexa-decimal do caractere em minúsculo é maior que sua representação em maúsculo</li>
</ul>
<p>A instrução JL (Jump Short if less) verifica se o caractere em questão é menor que o caractere 'a', considerando que os valores em decimal/hexa-decimal dos caracteres em maiúsculo são menores que os em minúsculo, se sim o caractere é maiúsculo, neste cenário salta para a função <strong>not_lowercase</strong></p>
<h4>sub al, 0x20</h4>
<p>Caso o caractere seja minúsculo, basta subtratir 0x20 que ele se tornará maiúsculo</p>
<h3>Função not_lowercase</h3>
<p>Esta é uma função grande que na verdade realiza as seguintes operaçÕes:</p>
<ul>
<li>Cálculo do hash do nome do módulo</li>
<li>Resgata uma série de informações do módulo (Base Address, índice na lista, tabela de exports, número de funções, tabela de nomes da funções)</li>
</ul>
<p>Desta forma iremos analisar parte por parte dessa função (em pequenos códigos)</p>
<p>[sourcecode language="shell"]<br />
not_lowercase:               ;<br />
  ror edi, 0xd               ; Rotate right our hash value<br />
  add edi, eax               ; Add the next byte of the name<br />
  dec ecx<br />
  jnz loop_modname           ; Loop until we have read enough<br />
  ; We now have the module hash computed<br />
  push edx                   ; Save the current position in the module list for later<br />
  push edi                   ; Save the current module hash for later<br />
[/sourcecode]</p>
<h4>ror edi, 0xd</h4>
<p>Rotaciona 0xd (decimal, 13) bits para a direita do valor presente no EDI (Hash Value)</p>
<h4>add edi, eax</h4>
<p>Adiciona o byte (resgatado do nome da função) ao valor presente no EDI e salva o resultado no próprio EDI</p>
<h4>dec ecx</h4>
<p>Decrementa o ECX (nosso contador)</p>
<h4>jnz loop_modname</h4>
<p>Jump short if not zero, verifica se o resultado da ultima operação matemática é diferente de zero, ou seja, irá saltar para a função <strong>loop_modname</strong> enquanto o ECX for maior que zero</p>
<h4>push edx</h4>
<p>Salva na pilha o valor de EDX que neste momento representa o índice do módulo na tabela LDR.InMemoryOrderModuleList</p>
<h4>push edi</h4>
<p>Salva na pilha o hash do nome do módulo atual</p>
<h3>Função not_lowercase - parte 2</h3>
<p>Essa fase da função irá buscar as informações das funções exportadas de dentro do módulo atual.</p>
<p>[sourcecode language="shell"]<br />
; Proceed to iterate the export address table,<br />
  mov edx, [edx+0x10]        ; Get this modules base address<br />
  mov eax, [edx+0x3c]        ; Get PE header<br />
  add eax, edx               ; Add the modules base address<br />
  mov eax, [eax+0x78]        ; Get export tables RVA<br />
  test eax, eax              ; Test if no export address table is present<br />
  jz get_next_mod1           ; If no EAT present, process the next module<br />
  add eax, edx               ; Add the modules base address<br />
  push eax                   ; Save the current modules EAT<br />
  mov ecx, [eax+0x18]        ; Get the number of function names<br />
  mov ebx, [eax+0x20]        ; Get the rva of the function names<br />
  add ebx, edx               ; Add the modules base address<br />
[/sourcecode]</p>
<h4>mov edx, [edx+0x10]</h4>
<p>Neste momento ainda temos no EDX o endereço da estrutura _LIST_ENTRY do módulo atual, sendo assim em seu offset 0x10 tem-se o BaseAddress do módulo, desta forma esta instrução copia o BaseAddress do módulo que está sendo analisado para o Registrador EDX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/472981a7d03842059a6aa08dc1264726.png"><img class="alignnone size-full wp-image-2300" src="{{ site.baseurl }}/assets/2021/08/472981a7d03842059a6aa08dc1264726.png" alt="" width="1672" height="856" /></a></p>
<p>Note que para realizar o parse da estrutura _LDR_DATA_TABLE_ENTRY temos de subtrair 0x08, então o Offset que aparece na imagem é 0x18, ou seja 0x10 + 0x08. Onde temos o valor 0x00f40000</p>
<p>Valor este que podemos confirma de mais outros 2 modos</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png"><img class="alignnone size-full wp-image-2301" src="{{ site.baseurl }}/assets/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png" alt="" width="1584" height="672" /></a></p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dd @edx + 10<br />
013d32b8  00f40000 00000000 000a2000 00480046<br />
013d32c8  013d1e84 00160014 013d1eb6 014022c4<br />
013d32d8  0000ffff 77d40ac0 013d31f4 5f125ed8<br />
013d32e8  00000000 00000000 013d3350 013d3350<br />
013d32f8  013d3350 00000000 00000000 00000000<br />
013d3308  00000000 00000000 0140d099 013d4f64<br />
013d3318  013d38c4 00000000 00400000 00000000<br />
013d3328  11fb4e0f 01d79199 10078c54 00000004</p>
<p>0:009&gt; lm m runner<br />
Browse full module list<br />
start    end        module name<br />
00f40000 00fe2000   Runner   C (no symbols)<br />
[/sourcecode]</p>
<p>Neste momento temos em EDX o BaseAddress do módulo que está sendo verificado.</p>
<h3>Binary internals</h3>
<p>Para facilitar o entendimento vamos adentrar nas tabelas que iremos resgatar as informações</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/b9a2470b34804531b292d9276ac26780.png"><img class="alignnone size-full wp-image-2302" src="{{ site.baseurl }}/assets/2021/08/b9a2470b34804531b292d9276ac26780.png" alt="" width="1129" height="633" /></a></p>
<h4>MS-DOS PE HEader</h4>
<p>https://www.aldeid.com/wiki/PE-Portable-executable</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/76ca63c41bf6481e9884ffd78bc9730a.png"><img class="alignnone size-full wp-image-2303" src="{{ site.baseurl }}/assets/2021/08/76ca63c41bf6481e9884ffd78bc9730a.png" alt="" width="910" height="1214" /></a></p>
<h4>PE HEader</h4>
<p>BaseAssress + 0x3c = Início do PE Header</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/5fa512a8337a42f2a2a48f2b29147736.png"><img class="alignnone size-full wp-image-2304" src="{{ site.baseurl }}/assets/2021/08/5fa512a8337a42f2a2a48f2b29147736.png" alt="" width="1920" height="447" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/6fee8b530ed94e9e8f3a7060f0883a51.png"><img class="alignnone size-full wp-image-2305" src="{{ site.baseurl }}/assets/2021/08/6fee8b530ed94e9e8f3a7060f0883a51.png" alt="" width="1920" height="579" /></a></p>
<h4>Export Table</h4>
<p><a href="https://www.aldeid.com/wiki/PE-Portable-executable#Export_Table" target="_blank" rel="noopener noreferrer">https://www.aldeid.com/wiki/PE-Portable-executable#Export_Table</a></p>
<p>A tabela de exports está no offset 0x78 a partir do início do PE Header. Cada módulo (Executável/DLL) conterá o seu próprio PE Header e consequentemente a sua tabela de exportação.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/e65af62396474ecaa86ea23feaade247.png"><img class="alignnone size-full wp-image-2306" src="{{ site.baseurl }}/assets/2021/08/e65af62396474ecaa86ea23feaade247.png" alt="" width="1920" height="509" /></a></p>
<h3>Função not_lowercase - parte 2 continuação</h3>
<p>Temos na imagem o parse dos dados da DOS_HEADER</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt ntdll!_IMAGE_DOS_HEADER 00f40000<br />
   +0x000 e_magic          : 0x5a4d<br />
   +0x002 e_cblp           : 0x90<br />
   +0x004 e_cp             : 3<br />
   +0x006 e_crlc           : 0<br />
   +0x008 e_cparhdr        : 4<br />
   +0x00a e_minalloc       : 0<br />
   +0x00c e_maxalloc       : 0xffff<br />
   +0x00e e_ss             : 0<br />
   +0x010 e_sp             : 0xb8<br />
   +0x012 e_csum           : 0<br />
   +0x014 e_ip             : 0<br />
   +0x016 e_cs             : 0<br />
   +0x018 e_lfarlc         : 0x40<br />
   +0x01a e_ovno           : 0<br />
   +0x01c e_res            : [4] 0<br />
   +0x024 e_oemid          : 0<br />
   +0x026 e_oeminfo        : 0<br />
   +0x028 e_res2           : [10] 0<br />
   +0x03c e_lfanew         : 0n128<br />
0:009&gt; ? 0n128<br />
Evaluate expression: 128 = 00000080<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/c1869b05a5bd4058856189c64a200c77.png"><img class="alignnone size-full wp-image-2307" src="{{ site.baseurl }}/assets/2021/08/c1869b05a5bd4058856189c64a200c77.png" alt="" width="1676" height="1172" /></a></p>
<h4>mov eax, [edx+0x3c]</h4>
<p>Copia RVA do PE Header para o registrador EAX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/c0c2939453d0432caaa0e6df186057a5.png"><img class="alignnone size-full wp-image-2308" src="{{ site.baseurl }}/assets/2021/08/c0c2939453d0432caaa0e6df186057a5.png" alt="" width="1680" height="1264" /></a></p>
<p>Podemos observar que o EAX teve seu valor definido como 0x80, ou seja o PE Header está em Base Address + 0x80 como vemos no output abaixo</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt ntdll!_IMAGE_NT_HEADERS 00f40000 + 0x80<br />
   +0x000 Signature        : 0x4550<br />
   +0x004 FileHeader       : _IMAGE_FILE_HEADER<br />
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png"><img class="alignnone size-full wp-image-2309" src="{{ site.baseurl }}/assets/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png" alt="" width="1920" height="672" /></a></p>
<p>Adicionalmente podemos observar os cabeçalhos adicionais no Offset 0x80 em relação ao PE Header</p>
<p>[sourcecode language="shell"]<br />
0:009&gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 00f40000 + 0x80 + 0x18<br />
   +0x000 Magic            : 0x10b<br />
   +0x002 MajorLinkerVersion : 0x30 '0'<br />
   +0x003 MinorLinkerVersion : 0 ''<br />
   +0x004 SizeOfCode       : 0x51e00<br />
   +0x008 SizeOfInitializedData : 0x4b800<br />
   +0x00c SizeOfUninitializedData : 0<br />
   +0x010 AddressOfEntryPoint : 0x53cf2<br />
   +0x014 BaseOfCode       : 0x2000<br />
   +0x018 BaseOfData       : 0x54000<br />
   +0x01c ImageBase        : 0x400000<br />
   +0x020 SectionAlignment : 0x2000<br />
   +0x024 FileAlignment    : 0x200<br />
   +0x028 MajorOperatingSystemVersion : 4<br />
   +0x02a MinorOperatingSystemVersion : 0<br />
   +0x02c MajorImageVersion : 0<br />
   +0x02e MinorImageVersion : 0<br />
   +0x030 MajorSubsystemVersion : 4<br />
   +0x032 MinorSubsystemVersion : 0<br />
   +0x034 Win32VersionValue : 0<br />
   +0x038 SizeOfImage      : 0xa2000<br />
   +0x03c SizeOfHeaders    : 0x200<br />
   +0x040 CheckSum         : 0<br />
   +0x044 Subsystem        : 2<br />
   +0x046 DllCharacteristics : 0x8540<br />
   +0x048 SizeOfStackReserve : 0x100000<br />
   +0x04c SizeOfStackCommit : 0x1000<br />
   +0x050 SizeOfHeapReserve : 0x100000<br />
   +0x054 SizeOfHeapCommit : 0x1000<br />
   +0x058 LoaderFlags      : 0<br />
   +0x05c NumberOfRvaAndSizes : 0x10<br />
   +0x060 DataDirectory    : [16] _IMAGE_DATA_DIRECTORY<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png"><img class="alignnone size-full wp-image-2310" src="{{ site.baseurl }}/assets/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png" alt="" width="1676" height="1122" /></a></p>
<p>Dentro dos cabeçalhos adicionais podemos encontrar que a Export table (DataDirectory) encontra-se no Offset 0x60 relativo aos cabeçalhos adicionais.</p>
<p>Desta forma se considerarmos que os cabeçalhos adicionais estão em 0x18 em relação ao PE Heder podemos então inferir que com relação ao PE Header a Exporta table está (0x18 + 0x60) = 0x78</p>
<h4>add eax, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA do PE Header e o salva no registrador EAX</p>
<h4>mov eax, [eax+0x78]</h4>
<p>Copia o RVA da tabela de exports para o registrador EAX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png"><img class="alignnone size-full wp-image-2311" src="{{ site.baseurl }}/assets/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png" alt="" width="1920" height="671" /></a></p>
<p>Como pode-se observar este é um cenário onde o módulo atual não detém nenhuma função exportada. Sendo assim iremos adicionar um breakpoint neste ponto do código para podermos executar o código até que chegue no módulo desejado. Como a função exitprocess está dentro do módulo kernel32.dll vamos executar o código até chegar neste ponto dentro do módulo kernel32.dll.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/711ed42a3fd44518960877bcbb2f48bb.png"><img class="alignnone size-full wp-image-2312" src="{{ site.baseurl }}/assets/2021/08/711ed42a3fd44518960877bcbb2f48bb.png" alt="" width="1920" height="653" /></a></p>
<p>Note que agora vamos executar o comando g, e a execução segue até nosso breakpoint, posteriormente podemos inspecionar qual é o módulo que estamos tratando com o comando <strong>lm a @edx</strong> uma vez que temos em ECX o BaseAddress do módulo atual</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/7997667cafec4e4e88a171ae43c7f922.png"><img class="alignnone size-full wp-image-2313" src="{{ site.baseurl }}/assets/2021/08/7997667cafec4e4e88a171ae43c7f922.png" alt="" width="1920" height="680" /></a></p>
<p>Uma vez que chegamos a kernel32.dll, podemos continuar a verificação.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/08564e0c70724f328f260baea7f34fdc.png"><img class="alignnone size-full wp-image-2314" src="{{ site.baseurl }}/assets/2021/08/08564e0c70724f328f260baea7f34fdc.png" alt="" width="1920" height="666" /></a></p>
<h4>test eax, eax</h4>
<p>Verifica se há uma tabela de exports</p>
<p>Existe a tabela, ou seja EAX é diferente de zero, então o JMP não vai ocorrer.</p>
<h4>jz get_next_mod1</h4>
<p>Jump near if 0, verifica se o resultado da ultima operação matemática foi zero, se sim, realiza o salto. De forma que verificará se não há tabela de exports salta para a função get_next_mod1, caso contrário continua para a proxima instrução</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png"><img class="alignnone size-full wp-image-2315" src="{{ site.baseurl }}/assets/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png" alt="" width="1920" height="702" /></a></p>
<h4>add eax, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da tabela de exportação e o salva no registrador EAX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png"><img class="alignnone size-full wp-image-2316" src="{{ site.baseurl }}/assets/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png" alt="" width="1920" height="696" /></a></p>
<h4>push eax</h4>
<p>Salva na pilha o VMA da tabela de exports do módulo atual</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png"><img class="alignnone size-full wp-image-2317" src="{{ site.baseurl }}/assets/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png" alt="" width="1920" height="750" /></a></p>
<h4>mov ecx, [eax+0x18]</h4>
<p>Uma vez que temos em EAX o VMA da tabela de exporta copia o número de funções exportadas para o registrador ECX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png"><img class="alignnone size-full wp-image-2318" src="{{ site.baseurl }}/assets/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png" alt="" width="1920" height="702" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/9db1702461b648c2b5b3f05eec7b2304.png"><img class="alignnone size-full wp-image-2319" src="{{ site.baseurl }}/assets/2021/08/9db1702461b648c2b5b3f05eec7b2304.png" alt="" width="1920" height="1228" /></a></p>
<h4>mov ebx, [eax+0x20]</h4>
<p>Copia o RVA do array com o nome das funções exportadas (AddressOfNames) para o registrador EBX</p>
<h4>add ebx, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA do array contendo o nome de todas as funções exportadas pelo módulo atual e o salva no registrador EBX</p>
<p>Neste momento temos em EBX o endereço de memória com o nome da primeira função</p>
<h3>Função get_next_func</h3>
<p>[sourcecode language="shell"]<br />
; Computing the module hash + function hash<br />
get_next_func:               ;<br />
  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps below<br />
  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next module<br />
  dec ecx                    ; Decrement the function name counter<br />
  mov esi, [ebx+ecx*4]       ; Get rva of next module name<br />
  add esi, edx               ; Add the modules base address<br />
  xor edi, edi               ; Clear EDI which will store the hash of the function name<br />
[/sourcecode]</p>
<h4>test ecx, ecx</h4>
<p>Realiza uma verificação entre ECX e ECX</p>
<h4>jz get_next_mod</h4>
<p>Jump near if 0, salta para a função get_next_mod caso o resultado da ultima operação matematica seja zero, ou seja, caso ECX (que é nosso contador de funções) tenha chegado a zero, salta para o ponto de código responsável por iniciar o processo de verificação do próximo módulo. Caso seja ECX maior que zero, continua a execução para a proxima instrução.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/9cf736a54e064aefbb9720a26e91121a.png"><img class="alignnone size-full wp-image-2320" src="{{ site.baseurl }}/assets/2021/08/9cf736a54e064aefbb9720a26e91121a.png" alt="" width="1920" height="689" /></a></p>
<p>ECX diferente de zero, então o JMP não irá ocorrer</p>
<h4>dec ecx</h4>
<p>Decrementa 01 de ECX</p>
<h4>mov esi, [ebx+ecx*4]</h4>
<p>Resgata o RVA do nome da função. Onde:</p>
<p>- EBX: Contém o VMA do início da array que detém o nome das funções<br />
- ECX: índice numérico dentro da função<br />
- ECX * 4: índico numérico multiplicado por 4 Bytes (32 bits) que representa cada endereço que contém o nome da função</p>
<h4>add esi, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do nome da função e o salva no registrador EAX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/41dad8cb4ece46e8932b9dc629527137.png"><img class="alignnone size-full wp-image-2321" src="{{ site.baseurl }}/assets/2021/08/41dad8cb4ece46e8932b9dc629527137.png" alt="" width="1920" height="697" /></a></p>
<p>Como no decorrer dest loop iremos decrementando o ECX, na pratica vamos varrendo a lista de traz p/ frente, sendo assim na primeira intereção tremos o nome da última função do array.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png"><img class="alignnone size-full wp-image-2322" src="{{ site.baseurl }}/assets/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png" alt="" width="1920" height="467" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png"><img class="alignnone size-full wp-image-2323" src="{{ site.baseurl }}/assets/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png" alt="" width="1920" height="1228" /></a></p>
<h4>xor edi, edi</h4>
<p>Zera o registrador EDI para utiliza-lo como armazenamento do hash da função</p>
<h3>Função loop_funcname</h3>
<p>[sourcecode language="shell"]<br />
loop_funcname:               ;<br />
  xor eax, eax               ; Clear EAX<br />
  lodsb                      ; Read in the next byte of the ASCII function name<br />
  ror edi, 0xd               ; Rotate right our hash value<br />
  add edi, eax               ; Add the next byte of the name<br />
  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)<br />
  jne loop_funcname          ; If we have not reached the null terminator, continue<br />
  add edi, [ebp-8]           ; Add the current module hash to the function hash<br />
  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for<br />
  jnz get_next_func          ; Go compute the next function hash if we have not found it<br />
  ; If found, fix up stack, call the function and then value else compute the next one...<br />
  pop eax                    ; Restore the current modules EAT<br />
  mov ebx, [eax+0x24]        ; Get the ordinal table rva<br />
  add ebx, edx               ; Add the modules base address<br />
  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal<br />
  mov ebx, [eax+0x1c]        ; Get the function addresses table rva<br />
  add ebx, edx               ; Add the modules base address<br />
  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA<br />
  add eax, edx               ; Add the modules base address to get the functions actual VA<br />
[/sourcecode]</p>
<h4>xor eax, eax</h4>
<p>Zera o registrador EAX</p>
<h4>lodsb</h4>
<p>Carrega o primeiro byte vindo do ESI para o registrador AL.</p>
<h4>ror edi, 0xd</h4>
<p>Rotaciona 0xd (decimal, 13) bits para a direita do valor presente no EDI (Hash Value)</p>
<h4>add edi, eax</h4>
<p>Adiciona o byte (resgatado do nome da função) ao valor presente no EDI e salva o resultado no próprio EDI</p>
<h4>cmp al, ah</h4>
<p>Compara o byte copiado pela função lodsb salvo em AL com o registrador AH (que neste cenário será zero)</p>
<h4>jne loop_funcname</h4>
<p>Jump near if not equal, verifica se o resultado da última comparação não é iguial, ou seja, se o último byte copiado em AL é diferente de zero, caso seja diferente de zero retorna para o início da função loop_funcname para continuar copiando os bytes do nome da função e assim calculando o hash. Caso tenha chegado no terminador de string \0 (NULL Byte) continua para a próxima instrução</p>
<h4>add edi, [ebp-8]</h4>
<p>Soma o hash do nome da função recem cálculada com o hash do nome do módulo calculado anteriormente e salvo em ebp-8, salvando o resultado no registrador EDI</p>
<h4>cmp edi, [ebp+0x24]</h4>
<p>Compara se o hash cálculado é igual ao hash desejado. Onde:<br />
- EDI: Hash cálculado com o nome do módulo + Nome da função<br />
- EBP + 0x24: Posição da memória que detém o Hash da função desejada. Em nosso exemplo, este Hash foi adicionado na pilha com o PUSH 0x56A2B5F0 que é o hash da função ExitProcess</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png"><img class="alignnone size-full wp-image-2324" src="{{ site.baseurl }}/assets/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png" alt="" width="1222" height="334" /></a></p>
<p>Vamos então colocar um breakpoint nessa função para verificar após o cálculo do hash do nome de cada função + o hash do módulo, tendo então o hash final da função para posteriormente poder verificar se é igual ao desejado.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/0e00a89fcb68481aad7fa79e32224480.png"><img class="alignnone size-full wp-image-2325" src="{{ site.baseurl }}/assets/2021/08/0e00a89fcb68481aad7fa79e32224480.png" alt="" width="1920" height="672" /></a></p>
<h4>jnz get_next_func</h4>
<p>Jump near if not zero, caso a comparação anterior aponte como hash diferentes o código será direcionado para a função get_next_func, responsável por verificar a próxima função exportada do módulo atual. Caso os hashes sejam iguais continua para o fluxo da proxima instrução.</p>
<h4>pop eax</h4>
<p>Restaura para o registrador EAX o VMA da tabela de exports do módulo atual. Este valor foi salvo na pilha através do PUSH EAX realizado anteriormente.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png"><img class="alignnone size-full wp-image-2326" src="{{ site.baseurl }}/assets/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png" alt="" width="1830" height="1684" /></a></p>
<p>Colocamos um breakpoint nessa instrução, pois só chegaremos nela no momento em que os hashes forem iguais e posteriormente liberei a execução.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png"><img class="alignnone size-full wp-image-2327" src="{{ site.baseurl }}/assets/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png" alt="" width="1920" height="690" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/fe1adf21706641a7bd213526c575cd32.png"><img class="alignnone size-full wp-image-2328" src="{{ site.baseurl }}/assets/2021/08/fe1adf21706641a7bd213526c575cd32.png" alt="" width="1920" height="661" /></a></p>
<h4>mov ebx, [eax+0x24]</h4>
<p>Relembrando a estrutura da Export table</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/e65af62396474ecaa86ea23feaade247-1.png"><img class="alignnone size-full wp-image-2329" src="{{ site.baseurl }}/assets/2021/08/e65af62396474ecaa86ea23feaade247-1.png" alt="" width="1920" height="509" /></a></p>
<p>Temos no offset 0x24 o array AddressOfNameOrdinals, sendo assim esta instrução copia o VMA do array AddressOfNameOrdinals para o registrador EBX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/dade3a9912334bcfb6573adb18d485f0.png"><img class="alignnone size-full wp-image-2330" src="{{ site.baseurl }}/assets/2021/08/dade3a9912334bcfb6573adb18d485f0.png" alt="" width="1920" height="681" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png"><img class="alignnone size-full wp-image-2331" src="{{ site.baseurl }}/assets/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png" alt="" width="1920" height="1225" /></a></p>
<h4>add ebx, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do array AddressOfNameOrdinals e o salva no registrador EBX</p>
<h4>mov cx, [ebx+2*ecx]</h4>
<p>Em ECX temos o índice da função desejada dentro da array AddressOfNames, como os arrays AddressOfNames e AddressOfNameOrdinals utilizam o mesmo índice podemos reaproveita-lo para endontrar o RVA da função dentro do array AddressOfNameOrdinals. Dentro da array AddressOfNames utiliamos ECX * 4 para saltar em cada um dos registros da array, pois cada registro dentro da AddressOfNames é um valor DWORD, ja na array AddressOfNameOrdinals cada registro é um WORD, sendo assim iremos multiplicar por 0x02 para saltar em cada registro. Conforme podemos observar na tabela de exports do módulo kernel32.dll</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png"><img class="alignnone size-full wp-image-2332" src="{{ site.baseurl }}/assets/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png" alt="" width="1920" height="1223" /></a></p>
<h4>mov ebx, [eax+0x1c]</h4>
<p>Antes de utilizar o novo índice calculado anteriormente iremos pegar o RVA do AddressOfFunctions no índice 0x1c da Export table e o salva no registrador EBX</p>
<h4>add ebx, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da do array AddressOfFunctions e o salva no registrador EBX</p>
<h4>mov eax, [ebx+4*ecx]</h4>
<p>Resgata o RVA da função desejada dentro da array AddressOfFunctions utilizando o offset resgatado da array AddressOfNameOrdinals. Onde:</p>
<ul>
<li>EDX: Endereço virtual do AddressOfFunctions</li>
<li>ECX: Índice da função desejada (resgatado do array AddressOfNameOrdinals)</li>
<li>ECX * 4: Índice da função * 4 bytes de cada endereço</li>
</ul>
<h4>add eax, edx</h4>
<p>Adiciona o RVA com o BaseAddress do módulo atual para obter o VMA da função desejada e o salva no registrador EAX</p>
<p>Nota: Este ja é o endereço de execução da função e pode ser usado pela instrução <strong>call eax</strong> (por exemplo).</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png"><img class="alignnone size-full wp-image-2333" src="{{ site.baseurl }}/assets/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png" alt="" width="1920" height="1152" /></a></p>
<h3>Funçao finish</h3>
<p>[sourcecode language="shell"]<br />
finish:<br />
  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad<br />
  pop ebx                    ; Clear off the current modules hash<br />
  pop ebx                    ; Clear off the current position in the module list<br />
  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered<br />
  pop ecx                    ; Pop off the origional return address our caller will have pushed<br />
  pop edx                    ; Pop off the hash value our caller will have pushed<br />
  push ecx                   ; Push back the correct return value<br />
  jmp eax                    ; Jump into the required function<br />
[/sourcecode]</p>
<h4>mov [esp+0x24], eax</h4>
<p>Altera o valor orginal do EAX adicionado na pilha pelo <strong>pushad</strong> para o endereço da função desejada (que recem calculamos). Este processo é necessário pois daqui algumas instruções iremos restaurar os registrados como estavm no momento da chamada da nossa função. Neste momento o WAX conterá o VMA da função que desejamos chamar.</p>
<h4>pop ebx</h4>
<p>Remove da pilha o hash do módulo atual</p>
<h4>pop ebx</h4>
<p>Remove da pilha a posição atual na listagem de módulos</p>
<h4>popad</h4>
<p>Restaura todos os registradores conforme seus valores iniciais. Nota para o EAX que será restaurado com o valor que sobrescrevemos a 2 instruçÕes.</p>
<h4>pop ecx</h4>
<p>Remove da pilha e copia para o registrador ECX o endereço de retorno do nosso fluxo de execução original. Este endereço foi adicionado automaticamente na pilha no momento da chamada da instrução CALL.</p>
<h4>pop edx</h4>
<p>Remove da pilha o hash da função que adicionamos antes da chamada da função call</p>
<h4>push ecx</h4>
<p>Adiciona novamente na pilha o endereço de retorno para que após a execução da função desejada o código possa continuar sua execução normalmente.</p>
<h4>jmp eax</h4>
<p>Salta para o endereço da função em que se deseja executar. Do ponto de vista do fluxo de código não continuaremos para as próximas instruções que será estudadas a segir, pois uma vez saltado para a função desejada a mesma finalizará com um RET que retornará, então, para nosso fluxo de execução original.</p>
<h3>Funções adicionais</h3>
<p>[sourcecode language="shell"]<br />
get_next_mod:                ;<br />
  pop eax                    ; Pop off the current (now the previous) modules EAT<br />
get_next_mod1:               ;<br />
  pop edi                    ; Pop off the current (now the previous) modules hash<br />
  pop edx                    ; Restore our position in the module list<br />
  mov edx, [edx]             ; Get the next module<br />
  jmp next_mod               ; Process this module<br />
[/sourcecode]</p>
<p>Conforme podemos visualizar ha outras funções no final do código da biblioteca que ja foram referenciados anteriormente e fazem parte do processo de execução.</p>
<h2>Conclusão</h2>
<p>Como vimos através do estudo da biblioteca block_api é possível localizar em tempo de execução todos os módulos carregados no sistema, inclusive os carregados em tempo de execução, e suas respectivas funções exportadas.</p>
<h2>Treinamento</h2>
<p>Deseja aprender passo a passo como realizar a criação de um Shellcode? Então da uma olhada em nosso treinamento de Shellcoding onde vamos do zero a criação de um shell reverso windows e linux, passando por shellcoding 32 e 64 bits.</p>
<p>Link do treinamento: <a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/" target="_blank" rel="noopener noreferrer">https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/</a></p>
<p><a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/"><img class="aligncenter size-full" src="{{ site.baseurl }}/assets/2021/08/image" width="1200" height="600" /></a></p>
<h2>Fontes:</h2>
<ul>
<li>Pavel, Y at all. Windows Internals Part 1: 7. ed. Washington: Microsoft, 2017.</li>
<li>Russinovich, M at all. Windows Internals: 5. ed. Washington: Microsoft, 2009.</li>
<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Win32_Thread_Information_Block</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a></li>
<li><a href="https://www.aldeid.com/wiki/PE-Portable-executable" target="_blank" rel="noopener noreferrer">https://www.aldeid.com/wiki/PE-Portable-executable</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a></li>
<li><a href="https://infoslack.com/devops/linux-101-arquitetura" target="_blank" rel="noopener noreferrer">https://infoslack.com/devops/linux-101-arquitetura</a></li>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html" target="_blank" rel="noopener noreferrer">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a></li>
<li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=ySKEF8MHcZA</a></li>
<li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm" target="_blank" rel="noopener noreferrer">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a></li>
<li><a href="https://sec4us.com.br/cheatsheet/shellcoding" target="_blank" rel="noopener noreferrer">https://sec4us.com.br/cheatsheet/shellcoding</a></li>
</ul>
