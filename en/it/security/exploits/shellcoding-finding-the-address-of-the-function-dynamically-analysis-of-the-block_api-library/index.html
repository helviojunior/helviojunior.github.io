<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library." /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this article, we will dissect the Metasploit 32 bits library called Block API, responsible for dynamically locating the addresses of functions within the loaded modules in the application." /><meta property="og:description" content="In this article, we will dissect the Metasploit 32 bits library called Block API, responsible for dynamically locating the addresses of functions within the loaded modules in the application." /><link rel="canonical" href="https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" /><meta property="og:url" content="https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-15T16:26:52-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library." /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-12-15T12:13:17-03:00","datePublished":"2021-08-15T16:26:52-03:00","description":"In this article, we will dissect the Metasploit 32 bits library called Block API, responsible for dynamically locating the addresses of functions within the loaded modules in the application.","headline":"Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/"},"url":"https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/"}</script><title>Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library. | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/en"> En </a> </span> <span> <a href="/it"> It </a> </span> <span> <a href="/security"> Security </a> </span> <span> <a href="/exploits"> Exploits </a> </span> <span>Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 15, 2021, 4:26 PM -0300" prep="on" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Dec 15, 2023, 12:13 PM -0300" prefix="Updated " > Dec 15, 2023 <i class="unloaded">2023-12-15T12:13:17-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5675 words">31 min</span></div></div><div class="post-content"><h2 id="introduction"><span class="me-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In this article, we will dissect the Metasploit 32 bits library called Block API, responsible for dynamically locating the addresses of functions within the loaded modules in the application.</p><p>However, before we delve into the subject of this post, it’s interesting to conceptualize a few things. The first of them is the term “Shellcoding.”</p><p>Shellcoding is a term commonly used to refer to code written in assembly language during the process of binary exploitation (on Windows and Linux), whether for creating a reverse shell, bind shell, executing commands, running an application, and so on.</p><p>In the process of creating shellcode, we have the possibility to work with two strategies: the first one using syscalls, and the second one using APIs from the subsystems of the operating system.</p><h2 id="windows-and-linux-architecture"><span class="me-2">Windows and Linux Architecture</span><a href="#windows-and-linux-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In a simplified manner, the image below illustrates the architecture of the Linux operating system.</p><p><a href="/assets/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8359a0a3ce9f4b8c8645c9cedffca97e.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Source: <a href="https://infoslack.com/devops/linux-101-arquitetura">https://infoslack.com/devops/linux-101-arquitetura</a></p><p>Similarly, the figure below illustrates the architecture of Windows.</p><p><a href="/assets/2021/08/36c41ddc969a4761a25396a46edbf8a3.png" class="img-link shimmer" ><img data-src="/assets/2021/08/36c41ddc969a4761a25396a46edbf8a3.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Source: Pavel, Y at all. Windows Internals Part 1: 1st ed. Washington: Microsoft, 2017. Pg 47</p><h2 id="syscalls-problem"><span class="me-2">Syscall’s Problem</span><a href="#syscalls-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As observed in both architectures (Windows and Linux), there are two possibilities to make calls to the operating system. The first one is using the libraries and subsystems of the operating system (glibc, kernel32.dll, user32.dll, etc.), and the second methodology is using system calls (also known as syscalls).</p><p>In Linux, it is very common and easy to use syscalls because the syscall IDs do not change with new releases, versions, and are extensively documented. In a Windows environment, on the other hand, there is no official documentation on this topic, and its use is highly discouraged because the syscall IDs change with each OS release. Therefore, a shellcode does not become reliable.</p><p>It’s worth noting that there are techniques to identify syscall IDs and use them, but that’s a topic for another article.</p><p>In a Windows environment, it’s common for shellcoders to use functions exposed directly by the Windows APIs (also known as subsystems), such as Kernel32.dll and user32.dll, etc.</p><p>For a deeper dive into this topic, I recommend watching Rafael Salema’s video <a href="https://www.youtube.com/watch?v=nQNxAje5SxI">Stop calling APIs! Demystifying direct syscall</a>.</p><h2 id="objective-of-this-article"><span class="me-2">Objective of this Article</span><a href="#objective-of-this-article" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In Windows shellcoding, we usually use operating system APIs, and these APIs typically run on the operating system with <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization - ASLR</a>. This means that with each execution, reboot of the operating system, or compilation of the DLL, there is a different address for function calls.</p><p>Therefore, for a shellcode to be reliable, it needs to have a method to dynamically identify the address of a function.</p><p>In our training, we teach how to use the Metasploit libraries called Block API for this purpose. These libraries are available at:</p><ul><li><strong>32 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a><li><strong>64 bits:</strong> <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a></ul><blockquote class="prompt-tip"><p>By the way, I made some optimizations to ensure that the 64-bit version of the ASM code doesn’t contain null bytes, and as a bonus, there was a reduction in size. Due to internal reasons, and as explained in the Pull Request comments, it wasn’t merged, but for those interested, here is the reference: <a href="https://github.com/rapid7/metasploit-framework/pull/17934">Pull Request #17934</a>.</p></blockquote><p>We also have a mini-training available on our YouTube channel about 64-bit Shellcoding (In Brazilian Language): <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a>, using this library.</p><p>In this article, we will step-by-step dissect what this library does, which structures, tables, and application data it analyzes to precisely identify the exact address of a function within Windows. Therefore, this article will focus solely on the Windows operating system.</p><h2 id="concepts-and-additional-references"><span class="me-2">Concepts and Additional References</span><a href="#concepts-and-additional-references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>During this study, we will discuss various topics and emphasize or delve deeper into only what is relevant to our study. For a better understanding and in-depth knowledge, I recommend referring to the following materials:</p><ul><li>Windows PE Format: PE stands for Portable Executable, which, in practice, refers to any executable binary on Windows, including .exe and .dll files. Technical specifications can be found here: <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a> and <a href="https://www.aldeid.com/wiki/PE-Portable-executable">https://www.aldeid.com/wiki/PE-Portable-executable</a>.<li>Intel® 64 and IA-32 Architectures Software Developer Manuals: This manual provides detailed information on various development aspects for Intel processors. In this article, we focus on understanding the main assembly instructions used. You can find the manual here: <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a>.<li>WinDBG: In this article, we will use WinDBG as a debugger, which is available here: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a>.<li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a></ul><blockquote class="prompt-warning"><p>If you are not familiar with assembly instructions, pointers, and the stack, I recommend watching this YouTube lecture <a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a> before continuing with this article, as it covers many essential concepts necessary for understanding this article.</p></blockquote><h2 id="installing-windbg"><span class="me-2">Installing WinDbg</span><a href="#installing-windbg" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To install WinDBG, download the Windows 10 SDK from the following link: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p><p><a href="/assets/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png" class="img-link shimmer" ><img data-src="/assets/2021/08/63543e7e146c45a298bd1f122c0f5ccf.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>After installation, configure the storage location and download of debug symbols.</p><p>Open WinDBG x68 and go to File &gt; Symbol File Path, then add the following content:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>srv<span class="k">*</span>c:<span class="se">\s</span>ymbols<span class="k">*</span>http://msdl.microsoft.com/download/symbols
</pre></table></code></div></div><p><a href="/assets/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8996097d1a4d4be9b6ef0fb04a5f3859.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Load any 32-bit application like:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>C:<span class="se">\W</span>indows<span class="se">\S</span>ysWOW64<span class="se">\n</span>otepad.exe
</pre></table></code></div></div><p><a href="/assets/2021/08/f50155a62904444dae9b7655288ae33f.png" class="img-link shimmer" ><img data-src="/assets/2021/08/f50155a62904444dae9b7655288ae33f.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Reload all symbols:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>.reload /f
</pre></table></code></div></div><p><a href="/assets/2021/08/388d8891016e4654a101bc40fb85bc0b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/388d8891016e4654a101bc40fb85bc0b.png" alt="" class="lazyload" data-proofer-ignore></a></p><h2 id="process-internals"><span class="me-2">Process Internals</span><a href="#process-internals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Each Windows process is represented by an EPROCESS (Executive Process) block. The EPROCESS block contains a series of pointers to a large number of other structures, such as ETHREADS, TEB, PED, and more.</p><p>The figure below simplifies the diagram of process and thread structures.</p><p><a href="/assets/2021/08/d817862488ea47d683756ffa2da72a85.png" class="img-link shimmer" ><img data-src="/assets/2021/08/d817862488ea47d683756ffa2da72a85.png" alt="" class="lazyload" data-proofer-ignore></a><br /> Source: Russinovich, M at all. Windows Internals: 5th ed. Washington: Microsoft, 2009. Pg 336</p><p>For our study, it’s worth noting an extremely important table known as the TEB (Thread Environment Block), also referred to as TIB (Thread Information Block) for compatibility reasons. The TEB can be used to obtain various pieces of information about the process without the need to make Win32 API calls. Among other information, it stores the address of the SEH (Structured Exception Handling) and the address of the PEB (Process Environment Block) table, which in turn can provide access to the IAT (Import Address Table) and more. The TEB can be accessed through the FS segment register.</p><h3 id="loader"><span class="me-2">Loader</span><a href="#loader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>During the initialization of an application, a series of activities take place. In practice, the loader runs before the application’s own code, making it transparent to the user. Among the activities for which the loader is responsible, we will highlight two that are important for our study:</p><ul><li>Handling the IAT (Import Address Table) of the application and examining all the DLLs that the application needs, as well as recursively analyzing the IAT of all loaded DLLs, followed by an examination of the export table of the DLLs to ensure that the desired functions are present.<li>Loading and unloading DLLs at runtime, including those loaded on demand, and maintaining a list of all modules, known as the Modules Database or also as LDR (Loader Data Table).</ul><h2 id="analysis-of-the-block-api-32-bits"><span class="me-2">Analysis of the Block API 32 bits</span><a href="#analysis-of-the-block-api-32-bits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The Block API library is available on the Metasploit GitHub at <a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a>.</p><h3 id="usage"><span class="me-2">Usage</span><a href="#usage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Before we delve into the analysis of the Block API code, let’s look at an example of its usage.</p><p>In this example, we will use the ExitProcess function documented at <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess</a>, which has the following syntax:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ExitProcess</span><span class="p">(</span>
  <span class="n">UINT</span> <span class="n">uExitCode</span>
<span class="p">);</span>
</pre></table></code></div></div><h4 id="c-code"><span class="me-2">C Code</span><a href="#c-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div file="exit.c" class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="exit.c"><i class="far fa-file-code fa-fw"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExitProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="api-hash"><span class="me-2">API Hash</span><a href="#api-hash" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>The block_api expects, as input at the top of the stack, the hash of the desired function followed by the function’s parameters.</p><p>To calculate the hash of the function, we will use an application developed by me, available at <a href="https://github.com/helviojunior/addrfinder">https://github.com/helviojunior/addrfinder</a>.</p><p><a href="/assets/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8e005921686341d4a9de29bd0d4dd1ef.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note that the hash of the <strong>ExitProcess</strong> function is <strong>0x56A2B5F0</strong>, and this hash remains the same even in different releases of Windows.</p><h4 id="assembly---using-the-block_api"><span class="me-2">Assembly - Using the block_api</span><a href="#assembly---using-the-block_api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div file="exit.asm" class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="exit.asm"><i class="far fa-file-code fa-fw"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>[BITS 32]

global _start

_start:
jmp short block_api

get_block_api:
pop edi ; Copy the address of block_api to the edi register

; Exit the application without displaying an error
xor eax, eax ; Clear EAX
push eax ; Push the "exit code" = 0x00 onto the stack

; Call the ExitProcess function
push 0x56A2B5F0 ; Push the hash address of the ExitProcess function onto the stack
call edi ; Execute the block_api to locate and execute the function

block_api:
call get_block_api
%include "../block_api.asm"
</pre></table></code></div></div><p><a href="/assets/2021/08/5033fcd6f11140fcb573c532cee9d279.png" class="img-link shimmer" ><img data-src="/assets/2021/08/5033fcd6f11140fcb573c532cee9d279.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>As we can see in the code above, on line 22, we include the library file (exactly the same file listed on the GitHub link above).</p><p>Using the JMP; Call; POP strategy, we save the address of the first instruction of block_api in the EDI register. This allows us to push the following onto the stack:</p><ul><li>ESP + 0x00 = 0x56A2B5F0<li>ESP + 0x04 = 0x00000000</ul><p>We then execute the block_api using the instruction <strong>call edi</strong>.</p><h4 id="assembly---assembling-and-running"><span class="me-2">Assembly - Assembling and Running</span><a href="#assembly---assembling-and-running" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote class="prompt-warning"><p>We will use the <code class="language-plaintext highlighter-rouge">shellcodetester</code> application developed by me for testing. You can install it directly via PyPi with the command <code class="language-plaintext highlighter-rouge">pip3 install shellcodetester</code>.</p></blockquote><p>For assembly (conversion of ASM mnemonics to binary/hex), we will use ShellcodeTester (Available at <a href="https://github.com/helviojunior/shellcodetester">https://github.com/helviojunior/shellcodetester</a>)</p><p>To install it, simply use the following command:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>pip3 <span class="nb">install</span> <span class="nt">--upgrade</span> shellcodetester
</pre></table></code></div></div><p>After installation, assemble and compile an EXE using the command:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>shellcodetester <span class="nt">-asm</span> exit.asm <span class="nt">--break-point</span>
</pre></table></code></div></div><p>Open WinDbg and execute the generated file <code class="language-plaintext highlighter-rouge">st-exit.exe</code>.</p><p>Now, in the WinDbg console, enter the <code class="language-plaintext highlighter-rouge">go</code> command.</p><h2 id="analysis-of-our-shellcode"><span class="me-2">Analysis of Our Shellcode</span><a href="#analysis-of-our-shellcode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Before we reach the block api library itself, we have some instructions that we can compare side by side with our code.</p><p><a href="/assets/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png" class="img-link shimmer" ><img data-src="/assets/2021/08/bd6ffc8df5b345508a8b063e73cea5b3.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Since the focus is on the execution of the block_api itself, let’s go to the point of the <strong>call edi</strong> instruction.</p><p>At this point, the EDI register contains the address of the block_api.</p><p><a href="/assets/2021/08/19c8531c17944b009ff8244113f6172f.png" class="img-link shimmer" ><img data-src="/assets/2021/08/19c8531c17944b009ff8244113f6172f.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>We will start our analysis from this point.</p><h2 id="analysis-of-block_api"><span class="me-2">Analysis of block_api</span><a href="#analysis-of-block_api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To facilitate the analysis process, I will provide the code of the block_api as we progress through it.</p><h3 id="tables"><span class="me-2">Tables</span><a href="#tables" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>As mentioned earlier, there are several tables that exist and are used in our application. Therefore, here is a diagram showing the flow we will follow in the upcoming instructions.</p><p><a href="/assets/2021/08/fb50b1ae0c2247498d36b0864c28432a.png" class="img-link shimmer" ><img data-src="/assets/2021/08/fb50b1ae0c2247498d36b0864c28432a.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>First, we will use the FS segment register at offset 0x30 to obtain the relative memory address (offset) of the TEB table. Next, we will retrieve from inside the TEB at offset 0x0C the address of the LDR table. Finally, within the LDR table, we will obtain the memory address of the first element of the InMemoryOrderModuleList array.</p><h3 id="memory-terms"><span class="me-2">Memory Terms</span><a href="#memory-terms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="vra-virtual-relative-address"><span class="me-2">VRA (Virtual Relative Address)</span><a href="#vra-virtual-relative-address" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>From now on, we will use the term VRA (Virtual Relative Address). This term refers to a memory address relative to the Base Address (also known as Offset). The offset of a DLL only changes if the DLL is recompiled. What ASLR affects is the Base Address, which does change with each machine reboot or each application execution.</p><h4 id="vma-virtual-memory-address"><span class="me-2">VMA (Virtual Memory Address)</span><a href="#vma-virtual-memory-address" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>VMA is equal to VRA + BaseAddress, which means it’s the virtual address that can be used within the application.</p><h3 id="api_call-function"><span class="me-2">api_call Function</span><a href="#api_call-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Here is the code snippet of the first api_call function:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>api_call:
pushad ; We preserve all the registers for the caller, bar EAX and ECX.
mov ebp, esp ; Create a new stack frame
xor edx, edx ; Zero EDX
mov edx, [fs:edx+0x30] ; Get a pointer to the PEB
mov edx, [edx+0xc] ; Get PEB-&gt;Ldr
mov edx, [edx+0x14] ; Get the first module from the InMemoryOrder module list
</pre></table></code></div></div><h4 id="pushad"><span class="me-2">pushad</span><a href="#pushad" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>The pushad instruction pushes all registers onto the stack, saving the values of all registers on the stack. This process consumes 20 bytes of stack space.</p><h4 id="mov-ebp-esp"><span class="me-2">mov ebp, esp</span><a href="#mov-ebp-esp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the address of the top of the stack to ebp. This process is known as the prologue of a function, which means it sets ESP and EBP equal to start a new stack frame.</p><h4 id="xor-edx-edx"><span class="me-2">xor edx, edx</span><a href="#xor-edx-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>The XOR mathematical operation of a value with itself always results in zero. Therefore, this instruction zeroes the value of the EDX register.</p><h4 id="mov-edx-fsedx0x30"><span class="me-2">mov edx, [fs:edx+0x30]</span><a href="#mov-edx-fsedx0x30" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the VRA of the PEB into the EDX register.</p><p>Within Windbg, we can view this information using the following command:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>0:009&gt; dt nt!_TEB @$teb
ntdll!_TEB
+0x000 NtTib : _NT_TIB
+0x01c EnvironmentPointer : (null)
+0x020 ClientId : _CLIENT_ID
+0x028 ActiveRpcHandle : (null)
+0x02c ThreadLocalStoragePointer : 0x0146a988 Void
+0x030 ProcessEnvironmentBlock : 0x010da000 _PEB
+0x034 LastErrorValue : 0
+0x038 CountOfOwnedCriticalSections : 0
+0x03c CsrClientThread : (null)
+0x040 Win32ThreadInfo : (null)
+0x044 User32Reserved : [26] 0
+0x0ac UserReserved : [5] 0
+0x0c0 WOW32Reserved : 0x77c16000 Void
+0x0c4 CurrentLocale : 0x409
+0x0c8 FpSoftwareStatusRegister : 0
+0x0cc ReservedForDebuggerInstrumentation : [16] (null)
+0x10c SystemReserved1 : [26] (null)
+0x174 PlaceholderCompatibilityMode : 0 ''
+0x175 PlaceholderHydrationAlwaysExplicit : 0 ''
+0x176 PlaceholderReserved : [10] ""
+0x180 ProxiedProcessId : 0
</pre></table></code></div></div><p>After executing the instruction, we can confirm the information:</p><p><a href="/assets/2021/08/21769f1837a241d0b7dcf1cc39f28526.png" class="img-link shimmer" ><img data-src="/assets/2021/08/21769f1837a241d0b7dcf1cc39f28526.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-edx-edx0xc"><span class="me-2">mov edx, [edx+0xc]</span><a href="#mov-edx-edx0xc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the VRA of the LDR into the EDX register.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre>0:009&gt; dt nt!_PEB 0x010da000
ntdll!_PEB
+0x000 InheritedAddressSpace : 0 ''
+0x001 ReadImageFileExecOptions : 0 ''
+0x002 BeingDebugged : 0x1 ''
+0x003 BitField : 0 ''
+0x003 ImageUsesLargePages : 0y0
+0x003 IsProtectedProcess : 0y0
+0x003 IsImageDynamicallyRelocated : 0y0
+0x003 SkipPatchingUser32Forwarders : 0y0
+0x003 IsPackagedProcess : 0y0
+0x003 IsAppContainer : 0y0
+0x003 IsProtectedProcessLight : 0y0
+0x003 IsLongPathAwareProcess : 0y0
+0x004 Mutant : 0xffffffff Void
+0x008 ImageBaseAddress : 0x00f40000 Void
+0x00c Ldr : 0x77d40c40 _PEB_LDR_DATA
+0x010 ProcessParameters : 0x013d19d0 _RTL_USER_PROCESS_PARAMETERS
+0x014 SubSystemData : (null)
+0x018 ProcessHeap : 0x013d0000 Void
+0x01c FastPebLock : 0x77d409e0 _RTL_CRITICAL_SECTION
+0x020 AtlThunkSListPtr : (null)
+0x024 IFEOKey : (null)
+0x028 CrossProcessFlags : 9
+0x028 ProcessInJob : 0y1
+0x028 ProcessInitializing : 0y0
</pre></table></code></div></div><p><a href="/assets/2021/08/637cc9ff49334ee78bcf36a095d040ea.png" class="img-link shimmer" ><img data-src="/assets/2021/08/637cc9ff49334ee78bcf36a095d040ea.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-edx-edx0x14"><span class="me-2">mov edx, [edx+0x14]</span><a href="#mov-edx-edx0x14" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the VRA of the first element of the <strong>InMemoryOrderModuleList</strong> array from the LDR table into the EDX register.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>0:009&gt; dt _PEB_LDR_DATA 0x77d40c40
ntdll!_PEB_LDR_DATA
+0x000 Length : 0x30
+0x004 Initialized : 0x1 ''
+0x008 SsHandle : (null)
+0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x13d32a0 - 0x140d710 ]
+0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x13d32a8 - 0x140d718 ]
+0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x13d31c8 - 0x140d670 ]
+0x024 EntryInProgress : (null)
+0x028 ShutdownInProgress : 0 ''
+0x02c ShutdownThreadId : (null)
</pre></table></code></div></div><p>[<a href="/assets/2021/08/8d5afbd757e84622bee6ac7587f5d806.png" class="popup img-link "><img data-src="/assets/2021/08/8d5afbd757e84622bee6ac7587f5d806.png" alt="" class="lazyload" data-proofer-ignore></a>](/assets/2021/08</p><p>/8d5afbd757e84622bee6ac7587f5d806.png)</p><p>At this point, EDX contains the VRA of the first element in the doubly-linked list <strong>InMemoryOrderModuleList</strong>.</p><p><a href="/assets/2021/08/263625546a4046e3b33d92971fae19ea.png" class="img-link shimmer" ><img data-src="/assets/2021/08/263625546a4046e3b33d92971fae19ea.png" alt="" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>0:009&gt; dt _LIST_ENTRY (0x77d40c40 + 0x14)
ntdll!_LIST_ENTRY
[ 0x13d32a8 - 0x140d718 ]
+0x000 Flink : 0x013d32a8 _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]
+0x004 Blink : 0x0140d718 _LIST_ENTRY [ 0x77d40c54 - 0x140d878 ]
</pre></table></code></div></div><p>This information may not seem very useful, but as we can see in the documentation (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a>), the LIST_ENTRY structure is part of a larger structure called <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code>.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>typedef struct _LIST_ENTRY {  
struct _LIST_ENTRY *Flink;  
struct _LIST_ENTRY *Blink;  
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY {  
PVOID Reserved1[2];  
LIST_ENTRY InMemoryOrderLinks;  
PVOID Reserved2[2];  
PVOID DllBase;  
PVOID EntryPoint;  
PVOID Reserved3;  
UNICODE_STRING FullDllName;  
BYTE Reserved4[8];  
PVOID Reserved5[3];  
union {  
ULONG CheckSum;  
PVOID Reserved6;  
};  
ULONG TimeDateStamp;  
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;  
</pre></table></code></div></div><p>To dump the structure, we need to subtract 0x08 from the address of <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code> in order to find the start of the <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code> structure.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>0:009&gt; dt _LDR_DATA_TABLE_ENTRY (013d32a8 - 0x8)
ntdll!_LDR_DATA_TABLE_ENTRY
+0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x13d31b8 - 0x77d40c4c ]
+0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x13d31c0 - 0x77d40c54 ]
+0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
+0x018 DllBase : 0x00f40000 Void
+0x01c EntryPoint : (null)
+0x020 SizeOfImage : 0xa2000
+0x024 FullDllName : _UNICODE_STRING "C:\Tools\ShellcodeTester\Runner.exe"
+0x02c BaseDllName : _UNICODE_STRING "Runner.exe"
+0x034 FlagGroup : [4] "???"
+0x034 Flags : 0x14022c4
</pre></table></code></div></div><p><a href="/assets/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png" class="img-link shimmer" ><img data-src="/assets/2021/08/d7bfcd1e25424cdfa2e17772de1c8dd2.png" alt="" class="lazyload" data-proofer-ignore></a></p><h3 id="function-next_mod"><span class="me-2">Function next_mod</span><a href="#function-next_mod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>next_mod: 
mov esi, [edx+0x28] ; Get pointer to module's name (unicode string)
movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check
xor edi, edi ; Clear EDI which will store the hash of the module name
</pre></table></code></div></div><h4 id="mov-esi-edx0x28"><span class="me-2">mov esi, [edx+0x28]</span><a href="#mov-esi-edx0x28" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the VMA of the module name.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>0:009&gt; du @esi
013d1eb6 "Runner.exe"
</pre></table></code></div></div><p><a href="/assets/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8a5a33bf66554437b4d62050bd0ffcf8.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="movzx-ecx-word-edx0x26"><span class="me-2">movzx ecx, word [edx+0x26]</span><a href="#movzx-ecx-word-edx0x26" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction retrieves the length of the module name. Keep in mind that each Unicode character corresponds to 2 bytes, and we also have 2 null bytes at the end. In our scenario:</p><ul><li>Runner.exe = 10 characters + 1 null byte<li>11 * 2 = 22</ul><p><a href="/assets/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/3339f66e40354ec6bcf91b0dc4c6335e.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="xor-edi-edi"><span class="me-2">xor edi, edi</span><a href="#xor-edi-edi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Clears EDI to use it as a storage location for the hash of the module name.</p><h3 id="function-loop_modname"><span class="me-2">Function loop_modname</span><a href="#function-loop_modname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>loop_modname: 
xor eax, eax ; Clear EAX
lodsb ; Read in the next byte of the name
cmp al, 'a' ; Some versions of Windows use lower case module names
jl not_lowercase ;
sub al, 0x20 ; If so, normalize to uppercase
</pre></table></code></div></div><h4 id="xor-eax-eax"><span class="me-2">xor eax, eax</span><a href="#xor-eax-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Clears EAX.</p><h4 id="lodsb"><span class="me-2">lodsb</span><a href="#lodsb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Loads the next byte from ESI into the AL register.</p><h4 id="cmp-al-a"><span class="me-2">cmp al, ‘a’</span><a href="#cmp-al-a" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compares the byte received with the character ‘a’.</p><h4 id="jl-not_lowercase"><span class="me-2">jl not_lowercase</span><a href="#jl-not_lowercase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Before we look at the comparison itself, let’s analyze the ASCII table:</p><p><a href="/assets/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png" class="img-link shimmer" ><img data-src="/assets/2021/08/1c806d639e2e4ce89a3fa1bc9a6c2bae.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Observe in the ASCII table that lowercase letters range from hexadecimal 0x61 to 0x7a, and uppercase letters range from 0x41 to 0x5a. So:</p><ul><li>Lowercase is exactly 0x20 bytes more than their uppercase representation.<li>The hexadecimal value of the lowercase character is greater than its uppercase representation.</ul><p>The JL (Jump Short if Less) instruction checks if the character in question is less than the character ‘a’. Considering that the decimal/hexadecimal values of uppercase characters are less than those of lowercase characters, if it’s true, the character is uppercase, and in this scenario, it jumps to the <strong>not_lowercase</strong> function.</p><h4 id="sub-al-0x20"><span class="me-2">sub al, 0x20</span><a href="#sub-al-0x20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>If the character is lowercase, subtracting 0x20 will turn it into uppercase.</p><h3 id="function-not_lowercase---part-2-continued"><span class="me-2">Function not_lowercase - Part 2 Continued</span><a href="#function-not_lowercase---part-2-continued" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In this phase of the function, we are retrieving information about the exported functions from the current module.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>; Proceed to iterate the export address table,
mov edx, [edx+0x10] ; Get this module's base address
mov eax, [edx+0x3c] ; Get PE header
add eax, edx ; Add the module's base address
mov eax, [eax+0x78] ; Get the export table's RVA
test eax, eax ; Test if no export address table is present
jz get_next_mod1 ; If no EAT present, process the next module
add eax, edx ; Add the module's base address
push eax ; Save the current module's EAT
mov ecx, [eax+0x18] ; Get the number of function names
mov ebx, [eax+0x20] ; Get the RVA of the function names
add ebx, edx ; Add the module's base address
</pre></table></code></div></div><h4 id="mov-edx-edx0x10"><span class="me-2">mov edx, [edx+0x10]</span><a href="#mov-edx-edx0x10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>At this point, EDX still holds the address of the <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code> structure of the current module. So, at its offset 0x10, we have the BaseAddress of the module. This instruction copies the BaseAddress of the module being analyzed to the EDX register.</p><p><a href="/assets/2021/08/472981a7d03842059a6aa08dc1264726.png" class="img-link shimmer" ><img data-src="/assets/2021/08/472981a7d03842059a6aa08dc1264726.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note that to parse the <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code> structure, we need to subtract 0x08, so the offset shown in the image is 0x18, which is 0x10 + 0x08. This corresponds to the value 0x00f40000.</p><p>We can also confirm this value in two more ways:</p><p><a href="/assets/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png" class="img-link shimmer" ><img data-src="/assets/2021/08/b5d48cd0bece439d8eca9dad186b0dfc.png" alt="" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>0:009&gt; dd @edx + 10
013d32b8 00f40000 00000000 000a2000 00480046
013d32c8 013d1e84 00160014 013d1eb6 014022c4
013d32d8 0000ffff 77d40ac0 013d31f4 5f125ed8
013d32e8 00000000 00000000 013d3350 013d3350
013d32f8 013d3350 00000000 00000000 00000000
013d3308 00000000 00000000 0140d099 013d4f64
013d3318 013d38c4 00000000 00400000 00000000
013d3328 11fb4e0f 01d79199 10078c54 00000004
</pre></table></code></div></div><p><a href="/assets/2021/08/c1869b05a5bd4058856189c64a200c77.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c1869b05a5bd4058856189c64a200c77.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-eax-edx0x3c"><span class="me-2">mov eax, [edx+0x3c]</span><a href="#mov-eax-edx0x3c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This instruction copies the RVA of the PE Header to the EAX register.</p><p><a href="/assets/2021/08/c0c2939453d0432caaa0e6df186057a5.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c0c2939453d0432caaa0e6df186057a5.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>We can see that EAX has been set to 0x80, which means the PE Header is at Base Address + 0x80, as shown in the following output:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>0:009&gt; dt ntdll!_IMAGE_NT_HEADERS 00f40000 + 0x80
+0x000 Signature : 0x4550
+0x004 FileHeader : _IMAGE_FILE_HEADER
+0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER
</pre></table></code></div></div><p><a href="/assets/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png" class="img-link shimmer" ><img data-src="/assets/2021/08/cd76b4aa6eda47228e542fa09a92e7d7.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Additionally, we can see the additional headers at Offset 0x80 relative to the PE Header:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>0:009&gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 00f40000 + 0x80 + 0x18
+0x000 Magic : 0x10b
+0x002 MajorLinkerVersion : 0x30 '0'
+0x003 MinorLinkerVersion : 0 ''
+0x004 SizeOfCode : 0x51e00
+0x008 SizeOfInitializedData : 0x4b800
+0x00c SizeOfUninitializedData : 0
+0x010 AddressOfEntryPoint : 0x53cf2
+0x014 BaseOfCode : 0x2000
+0x018 BaseOfData : 0x54000
+0x01c ImageBase : 0x400000
+0x020 SectionAlignment : 0x2000


+0x024 FileAlignment : 0x200
+0x028 MajorOperatingSystemVersion : 4
+0x02a MinorOperatingSystemVersion : 0
+0x02c MajorImageVersion : 0
+0x02e MinorImageVersion : 0
+0x030 MajorSubsystemVersion : 4
+0x032 MinorSubsystemVersion : 0
+0x034 Win32VersionValue : 0
+0x038 SizeOfImage : 0xa2000
+0x03c SizeOfHeaders : 0x200
+0x040 CheckSum : 0
+0x044 Subsystem : 2
+0x046 DllCharacteristics : 0x8540
+0x048 SizeOfStackReserve : 0x100000
+0x04c SizeOfStackCommit : 0x1000
+0x050 SizeOfHeapReserve : 0x100000
+0x054 SizeOfHeapCommit : 0x1000
+0x058 LoaderFlags : 0
+0x05c NumberOfRvaAndSizes : 0x10
+0x060 DataDirectory : [16] _IMAGE_DATA_DIRECTORY
</pre></table></code></div></div><p><a href="/assets/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9eb697ab4e664ea6b9b9e8e19f93a37b.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Within the additional headers, we can find that the Export table (DataDirectory) is located at Offset 0x60 relative to the additional headers.</p><p>Therefore, if we consider that the additional headers are at 0x18 in relation to the PE Header, we can infer that, with respect to the PE Header, the Export table is at (0x18 + 0x60) = 0x78.</p><h4 id="add-eax-edx"><span class="me-2">add eax, edx</span><a href="#add-eax-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the PE Header and saves it in the EAX register.</p><h4 id="mov-eax-eax0x78"><span class="me-2">mov eax, [eax+0x78]</span><a href="#mov-eax-eax0x78" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Copies the RVA of the export table to the EAX register.</p><p><a href="/assets/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png" class="img-link shimmer" ><img data-src="/assets/2021/08/c4da462e06744a94b3d1e2ead1bc3d1d.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>As you can see, this is a scenario where the current module does not have any exported functions. Therefore, we will add a breakpoint at this point in the code to execute the code until it reaches the desired module. Since the <code class="language-plaintext highlighter-rouge">exitprocess</code> function is within the <code class="language-plaintext highlighter-rouge">kernel32.dll</code> module, we will execute the code until it reaches this point within the <code class="language-plaintext highlighter-rouge">kernel32.dll</code> module.</p><p><a href="/assets/2021/08/711ed42a3fd44518960877bcbb2f48bb.png" class="img-link shimmer" ><img data-src="/assets/2021/08/711ed42a3fd44518960877bcbb2f48bb.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Note that now we will execute the “g” command, and the execution proceeds until our breakpoint. Subsequently, we can inspect which module we are dealing with using the <code class="language-plaintext highlighter-rouge">lm a @edx</code> command, as we have the BaseAddress of the current module in ECX.</p><p><a href="/assets/2021/08/7997667cafec4e4e88a171ae43c7f922.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7997667cafec4e4e88a171ae43c7f922.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Once we have reached <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, we can continue the inspection.</p><p><a href="/assets/2021/08/08564e0c70724f328f260baea7f34fdc.png" class="img-link shimmer" ><img data-src="/assets/2021/08/08564e0c70724f328f260baea7f34fdc.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="test-eax-eax"><span class="me-2">test eax, eax</span><a href="#test-eax-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Checks if there is an export table.</p><p>If the table exists, i.e., EAX is not zero, the JMP instruction will not occur.</p><h4 id="jz-get_next_mod1"><span class="me-2">jz get_next_mod1</span><a href="#jz-get_next_mod1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if zero. It checks if the result of the last mathematical operation was zero. If yes, it performs the jump, verifying that there is no export table. Otherwise, it continues to the next instruction.</p><p><a href="/assets/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png" class="img-link shimmer" ><img data-src="/assets/2021/08/bd1ee4dbb0494fb397452b53f7fc56f2.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="add-eax-edx-1"><span class="me-2">add eax, edx</span><a href="#add-eax-edx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the export table and saves it in the EAX register.</p><p><a href="/assets/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png" class="img-link shimmer" ><img data-src="/assets/2021/08/ddbd3d34d7754dc7bf6da2911c34a0fb.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="push-eax"><span class="me-2">push eax</span><a href="#push-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Saves the VMA of the export table of the current module on the stack.</p><p><a href="/assets/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png" class="img-link shimmer" ><img data-src="/assets/2021/08/31d074c5b9c94b2a806bd8d6a78728a7.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ecx-eax0x18"><span class="me-2">mov ecx, [eax+0x18]</span><a href="#mov-ecx-eax0x18" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Now that we have the VMA of the export table in EAX, it copies the number of exported functions to the ECX register.</p><p><a href="/assets/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png" class="img-link shimmer" ><img data-src="/assets/2021/08/8dc9a7d1e4e747d0b5d0e5610294ff3b.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/9db1702461b648c2b5b3f05eec7b2304.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9db1702461b648c2b5b3f05eec7b2304.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax0x20"><span class="me-2">mov ebx, [eax+0x20]</span><a href="#mov-ebx-eax0x20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>It copies the RVA of the array containing the names of exported functions (AddressOfNames) to the EBX register.</p><h4 id="add-ebx-edx"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the array containing the names of all functions exported by the current module and saves it in the EBX register.</p><p>At this point, we have the memory address with the name of the first function in EBX.</p><h3 id="function-get_next_func"><span class="me-2">Function <code class="language-plaintext highlighter-rouge">get_next_func</code></span><a href="#function-get_next_func" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>; Computing the module hash + function hash  
get_next_func: ;  
test ecx, ecx ; Changed from jecxz to accommodate the larger offset produced by random jumps below  
jz get_next_mod ; When we reach the start of the EAT (we search backward), process the next module  
dec ecx ; Decrement the function name counter  
mov esi, [ebx+ecx*4] ; Get RVA of the next module name  
add esi, edx ; Add the module's base address  
xor edi, edi ; Clear EDI, which will store the hash of the function name  
</pre></table></code></div></div><h4 id="test-ecx-ecx"><span class="me-2">test ecx, ecx</span><a href="#test-ecx-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Performs a comparison between ECX and ECX.</p><h4 id="jz-get_next_mod"><span class="me-2">jz get_next_mod</span><a href="#jz-get_next_mod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if zero. It jumps to the <code class="language-plaintext highlighter-rouge">get_next_mod</code> function if the result of the last mathematical operation is zero, i.e., if ECX (our function counter) reaches zero, it jumps to the code responsible for starting the process of checking the next module. Otherwise, it continues to the next instruction.</p><p><a href="/assets/2021/08/9cf736a54e064aefbb9720a26e91121a.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9cf736a54e064aefbb9720a26e91121a.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>ECX is not zero, so the JMP will not occur.</p><h4 id="dec-ecx"><span class="me-2">dec ecx</span><a href="#dec-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Decrements ECX by 1.</p><h4 id="mov-esi-ebx--ecx-"><span class="me-2">mov esi, [ebx + ecx *</span><a href="#mov-esi-ebx--ecx-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>4]</p><p>Retrieves the RVA of the function name. Where:</p><ul><li>EBX: Contains the VMA of the beginning of the array that holds the function names.<li>ECX: Numeric index within the function.<li>ECX * 4: Numeric index multiplied by 4 bytes (32 bits) representing each address containing the function name.</ul><h4 id="add-esi-edx"><span class="me-2">add esi, edx</span><a href="#add-esi-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the function name and saves it in the ESI register.</p><p><a href="/assets/2021/08/41dad8cb4ece46e8932b9dc629527137.png" class="img-link shimmer" ><img data-src="/assets/2021/08/41dad8cb4ece46e8932b9dc629527137.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>As we decrement ECX during this loop, we effectively traverse the list backward. So, in the first iteration, we have the name of the last function in the array.</p><p><a href="/assets/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png" class="img-link shimmer" ><img data-src="/assets/2021/08/60bfdfab2d57477d884782fe7b53e6dd.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png" class="img-link shimmer" ><img data-src="/assets/2021/08/a82745678fc44ebbb9b3b9a943b6db86.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="xor-edi-edi-1"><span class="me-2">xor edi, edi</span><a href="#xor-edi-edi-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Clears the EDI register for use as storage for the function hash.</p><h3 id="function-loop_funcname"><span class="me-2">Function <code class="language-plaintext highlighter-rouge">loop_funcname</code></span><a href="#function-loop_funcname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>loop_funcname: ;  
xor eax, eax ; Clear EAX  
lodsb ; Read in the next byte of the ASCII function name  
ror edi, 0xd ; Rotate right our hash value  
add edi, eax ; Add the next byte of the name  
cmp al, ah ; Compare AL (the next byte from the name) to AH (null)  
jne loop_funcname ; If we have not reached the null terminator, continue  
add edi, [ebp-8] ; Add the current module hash to the function hash  
cmp edi, [ebp+0x24] ; Compare the hash to the one we are searching for  
jnz get_next_func ; Go compute the next function hash if we have not found it  
; If found, fix up stack, call the function, and then value else compute the next one...  
pop eax ; Restore the current module's EAT  
mov ebx, [eax+0x24] ; Get the ordinal table RVA  
add ebx, edx ; Add the module's base address  
mov cx, [ebx+2*ecx] ; Get the desired function's ordinal  
mov ebx, [eax+0x1c] ; Get the function addresses table RVA  
add ebx, edx ; Add the module's base address  
mov eax, [ebx+4*ecx] ; Get the desired function's RVA  
add eax, edx ; Add the module's base address to get the function's actual VA  
</pre></table></code></div></div><h4 id="xor-eax-eax-1"><span class="me-2">xor eax, eax</span><a href="#xor-eax-eax-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Clears the EAX register.</p><h4 id="lodsb-1"><span class="me-2">lodsb</span><a href="#lodsb-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Loads the next byte from ESI into the AL register.</p><h4 id="ror-edi-0xd"><span class="me-2">ror edi, 0xd</span><a href="#ror-edi-0xd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Rotates the hash value in EDI right by 0xd bits.</p><h4 id="add-edi-eax"><span class="me-2">add edi, eax</span><a href="#add-edi-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the next byte from the name to the value in EDI and saves the result in EDI.</p><h4 id="cmp-al-ah"><span class="me-2">cmp al, ah</span><a href="#cmp-al-ah" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compares AL (the next byte from the name) to AH (null).</p><h4 id="jne-loop_funcname"><span class="me-2">jne loop_funcname</span><a href="#jne-loop_funcname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if not equal. It checks if the result of the last comparison is not equal, i.e., if the last byte copied into AL is not zero. If it’s not zero, it returns to the beginning of the <code class="language-plaintext highlighter-rouge">loop_funcname</code> function to continue copying the bytes of the function name and thus calculate the hash. If it has reached the null terminator \0 (NULL Byte), it continues to the next instruction.</p><h4 id="add-edi-ebp-8"><span class="me-2">add edi, [ebp-8]</span><a href="#add-edi-ebp-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the hash of the function name, which was just calculated, to the hash of the module name calculated earlier and saved in ebp-8, saving the result in the EDI register.</p><h4 id="cmp-edi-ebp0x24"><span class="me-2">cmp edi, [ebp+0x24]</span><a href="#cmp-edi-ebp0x24" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Compares if the calculated hash is equal to the desired hash. Where:</p><ul><li>EDI: Hash calculated with the module name + function name.<li>EBP + 0x24: Memory location holding the hash of the desired function. In our example, this hash was added to the stack with the PUSH 0x56A2B5F0, which is the hash of the <code class="language-plaintext highlighter-rouge">ExitProcess</code> function.</ul><p><a href="/assets/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png" class="img-link shimmer" ><img data-src="/assets/2021/08/1eb1b42fa6714ad58a8e3e811f1f27db.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>We will set a breakpoint in this function to check the final hash of the function after calculating the hash of each function name + the module hash to later verify if it matches the desired hash.</p><p><a href="/assets/2021/08/0e00a89fcb68481aad7fa79e32224480.png" class="img-link shimmer" ><img data-src="/assets/2021/08/0e00a89fcb68481aad7fa79e32224480.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="jnz-get_next_func"><span class="me-2">jnz get_next_func</span><a href="#jnz-get_next_func" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jump near if not zero. If the previous comparison indicates different hashes, the code will be directed to the <code class="language-plaintext highlighter-rouge">get_next_func</code> function, responsible for checking the next exported function of the current module. If the hashes are equal, it continues to the flow of the next instruction.</p><h4 id="pop-eax"><span class="me-2">pop eax</span><a href="#pop-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Restores the VMA of the export table of the current module to the EAX register. This value was saved on the stack by the previous PUSH EAX.</p><p><a href="/assets/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png" class="img-link shimmer" ><img data-src="/assets/2021/08/11ba7a2da13e4e9abdccf6d1fc7f8a34.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>We set a breakpoint at this instruction because we will only reach it when the hashes are equal, and we will release the execution afterward.</p><p><a href="/assets/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png" class="img-link shimmer" ><img data-src="/assets/2021/08/dadd5c5e07d046d2b792a7625c6bc5b0.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/fe1adf21706641a7bd213526c575cd32.png" class="img-link shimmer" ><img data-src="/assets/2021/08/fe1adf21706641a7bd213526c575cd32.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax0x24"><span class="me-2">mov ebx, [eax+0x24]</span><a href="#mov-ebx-eax0x24" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Remembering the Export table structure</p><p><a href="/assets/2021/08/e65af62396474ecaa86ea23feaade247-1.png" class="img-link shimmer" ><img data-src="/assets/2021/08/e65af62396474ecaa86ea23feaade247-1.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>At offset 0x24, we have the AddressOfNameOrdinals array, so this instruction copies the VMA of the AddressOfNameOrdinals array into the EBX register.</p><p><a href="/assets/2021/08/dade3a9912334bcfb6573adb18d485f0.png" class="img-link shimmer" ><img data-src="/assets/2021/08/dade3a9912334bcfb6573adb18d485f0.png" alt="" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7235f7e1e42345fbb5fbae23607b7d81.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="add-ebx-edx-1"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the AddressOfNameOrdinals array and saves it in the EBX register.</p><h4 id="mov-cx-ebx--2--ecx"><span class="me-2">mov cx, [ebx + 2 * ecx]</span><a href="#mov-cx-ebx--2--ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>In ECX, we have the index of the desired function within the AddressOfNames array. Since the AddressOfNames and AddressOfNameOrdinals arrays use the same index, we can reuse it to find the RVA of the function within the AddressOfNameOrdinals array. In the AddressOfNames array, we use ECX * 4 to jump to each of the records in the array because each record in AddressOfNames is a DWORD value, whereas in the AddressOfNameOrdinals array, each record is a WORD, so we multiply by 0x02 to jump to each record. As we can see in the exports table of the kernel32.dll module:</p><p><a href="/assets/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png" class="img-link shimmer" ><img data-src="/assets/2021/08/7315b13c4f8948799c7b7da081ec7d7e.png" alt="" class="lazyload" data-proofer-ignore></a></p><h4 id="mov-ebx-eax--0x1c"><span class="me-2">mov ebx, [eax + 0x1c]</span><a href="#mov-ebx-eax--0x1c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Before using the newly calculated index, we obtain the RVA of the AddressOfFunctions at index 0x1c in the Export table and save it in the EBX register.</p><h4 id="add-ebx-edx-2"><span class="me-2">add ebx, edx</span><a href="#add-ebx-edx-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the AddressOfFunctions array and saves it in the EBX register.</p><h4 id="mov-eax-ebx--4--ecx"><span class="me-2">mov eax, [ebx + 4 * ecx]</span><a href="#mov-eax-ebx--4--ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Retrieves the RVA of the desired function within the AddressOfFunctions array using the offset retrieved from the AddressOfNameOrdinals array. Where:</p><ul><li>EDX: Virtual address of AddressOfFunctions<li>ECX: Index of the desired function (retrieved from the AddressOfNameOrdinals array)<li>ECX * 4: Index of the function * 4 bytes for each address</ul><h4 id="add-eax-edx-2"><span class="me-2">add eax, edx</span><a href="#add-eax-edx-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the RVA with the BaseAddress of the current module to obtain the VMA of the desired function and saves it in the EAX register.</p><blockquote class="prompt-warning"><p>This is the execution address of the function and can be used by the <code class="language-plaintext highlighter-rouge">call eax</code> instruction, for example.</p></blockquote><p><a href="/assets/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png" class="img-link shimmer" ><img data-src="/assets/2021/08/9f1a8e78225b4bb08c7b0502a31ddeaa.png" alt="" class="lazyload" data-proofer-ignore></a></p><h3 id="finish-function"><span class="me-2">Finish function</span><a href="#finish-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>finish:
mov [esp+0x24], eax ; Overwrite the old EAX value with the desired API address for the upcoming popad
pop ebx ; Clear the current module's hash
pop ebx ; Clear the current position in the module list
popad ; Restore all of the caller's registers, except EAX, ECX, and EDX, which are clobbered
pop ecx ; Pop off the original return address our caller will have pushed
pop edx ; Pop off the hash value our caller will have pushed
push ecx ; Push back the correct return value
jmp eax ; Jump to the required function
</pre></table></code></div></div><h4 id="mov-esp0x24-eax"><span class="me-2">mov [esp+0x24], eax</span><a href="#mov-esp0x24-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Changes the original value of EAX added to the stack by “pushad” to the address of the desired function (which we just calculated). This process is necessary because in a few instructions, we will restore the registers to their initial values as they were at the time of the function call. At this point, EAX will contain the VMA of the function we want to call.</p><h4 id="pop-ebx"><span class="me-2">pop ebx</span><a href="#pop-ebx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Removes the current module’s hash from the stack.</p><h4 id="pop-ebx-1"><span class="me-2">pop ebx</span><a href="#pop-ebx-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Removes the current position in the module list from the stack.</p><h4 id="popad"><span class="me-2">popad</span><a href="#popad" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Restores all registers to their initial values. Note that EAX will be restored with the value we overwrote two instructions ago.</p><h4 id="pop-ecx"><span class="me-2">pop ecx</span><a href="#pop-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Removes the stack and copies the original return address from our original execution flow to the ECX register. This address was automatically added to the stack at the time of the CALL instruction.</p><h4 id="pop-edx"><span class="me-2">pop edx</span><a href="#pop-edx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Removes the hash of the function that we added before the CALL instruction from the stack.</p><h4 id="push-ecx"><span class="me-2">push ecx</span><a href="#push-ecx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Adds the return address back to the stack so that after the execution of the desired function, the code can continue its execution normally.</p><h4 id="jmp-eax"><span class="me-2">jmp eax</span><a href="#jmp-eax" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Jumps to the address of the desired function to execute it. From the code flow perspective, we will not continue to the next instructions that will be studied next because once we jump to the desired function, it will finish with a RET instruction, which will return to our original execution flow.</p><h3 id="additional-functions"><span class="me-2">Additional functions</span><a href="#additional-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>get_next_mod: ;
pop eax ; Pop off the current (now the previous) module's EAT
get_next_mod1: ;
pop edi ; Pop off the current (now the previous) module's hash
pop edx ; Restore our position in the module list
mov edx, [edx] ; Get the next module
jmp next_mod ; Process this module
</pre></table></code></div></div><p>As we can see, there are other functions at the end of the library code that have already been referenced earlier and are part of the execution process.</p><h2 id="conclusion"><span class="me-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As we have seen through the study of the block_api library, it is possible to dynamically locate all the modules loaded in the system, including those loaded at runtime, and their respective exported functions.</p><h2 id="training"><span class="me-2">Training</span><a href="#training" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Interested in learning step by step how to create a shellcode? Take a look at our Shellcoding training, where we cover everything from scratch to creating a reverse shell for both Windows and Linux, including shellcoding for 32 and 64-bit systems.</p><p>Training Link: <a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/">https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/</a></p><p><a href="https://sec4us.com.br/treinamentos/shellcoding-para-desenvolvimento-de-exploits/" class="img-link shimmer" ><img data-src="/assets/2021/08/image" alt="" class="lazyload" data-proofer-ignore></a></p><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Pavel, Y at all. Windows Internals Part 1: 7th ed. Washington: Microsoft, 2017.<li>Russinovich, M at all. Windows Internals: 5th ed. Washington: Microsoft, 2009.<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">https://en.wikipedia.org/wiki/Win32_Thread_Information_Block</a><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a><li><a href="https://www.aldeid.com/wiki/PE-Portable-executable">https://www.aldeid.com/wiki/PE-Portable-executable</a><li><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format</a><li><a href="https://infoslack.com/devops/linux-101-arquitetura">https://infoslack.com/devops/linux-101-arquitetura</a><li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</a><li><a href="https://www.youtube.com/watch?v=ySKEF8MHcZA">https://www.youtube.com/watch?v=ySKEF8MHcZA</a><li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</a><li><a href="https://cheatsheet.sec4us.com.br/shellcoding">https://cheatsheet.sec4us.com.br/shellcoding</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/exploits-development/'>Exploits Development</a>, <a href='/categories/offensive-security/'>Offensive Security</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/offensive-security/" class="post-tag no-text-decoration" >Offensive Security</a> <a href="/tags/buffer-overflow/" class="post-tag no-text-decoration" >Buffer Overflow</a> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >Shellcoding</a> <a href="/tags/osed/" class="post-tag no-text-decoration" >OSED</a> <a href="/tags/osee/" class="post-tag no-text-decoration" >OSEE</a> <a href="/tags/osce3/" class="post-tag no-text-decoration" >OSCE3</a> <a href="/tags/pentest/" class="post-tag no-text-decoration" >Pentest</a> <a href="/tags/exploits-development/" class="post-tag no-text-decoration" >Exploits Development</a> <a href="/tags/windows-internals/" class="post-tag no-text-decoration" >Windows Internals</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library. - Helvio Junior&url=https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library. - Helvio Junior&u=https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library. - Helvio Junior&url=https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/"><div class="card-body"> <span class="timeago small" > Aug 15, 2021 <i class="unloaded">2021-08-15T16:26:52-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</h3><div class="text-muted small"><p> Introdução Neste artigo iremos dissecar a biblioteca da Metasploit chamada Block API responsável por localizar em tempo de execução o endereço das funções dentro dos módulos carregados na aplicaçã...</p></div></div></a></div><div class="card"> <a href="/it/disassemble-raw-file/"><div class="card-body"> <span class="timeago small" > Jan 31, 2020 <i class="unloaded">2020-01-31T09:36:10-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Disassemble raw file</h3><div class="text-muted small"><p> Em um processo de exploitation ou engenharia reversa é bem comum a necessidade de realizar um disassemble de um objeto. Muitas vezes se faz necessário realizar isso em um arquivo não reconhecido a...</p></div></div></a></div><div class="card"> <a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/"><div class="card-body"> <span class="timeago small" > Sep 14, 2021 <i class="unloaded">2021-09-14T15:26:04-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</h3><div class="text-muted small"><p> Introdução Meu nome é Hélvio Junior, também conhecido como M4v3r1ck. Para quem me conhece, sabe da minha paixão estudo sobre low level exploitation, envolvendo buffer overflow, process injection e...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/security/criacao-de-exploits/shellcoding-encontrando-endereco-da-funcao-dinamicamente-analise-da-biblioteca-block_api/" class="btn btn-outline-primary" prompt="Older"><p>Shellcoding - Encontrando endereço da função dinamicamente. Análise da biblioteca block_api</p></a> <a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/" class="btn btn-outline-primary" prompt="Newer"><p>OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Shellcoding - Finding the address of the function dynamically. Analysis of the block_api library.'; this.page.url = 'https://www.helviojunior.com.br/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/'; this.page.identifier = '/en/it/security/exploits/shellcoding-finding-the-address-of-the-function-dynamically-analysis-of-the-block_api-library/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
