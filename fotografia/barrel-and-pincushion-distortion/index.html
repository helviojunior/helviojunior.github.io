<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Barrel and pincushion distortion" /><meta name="author" content="Helvio Junior (m4v3r1ck)" /><meta property="og:locale" content="en_US" /><meta name="description" content="Distorção em barril (barrel distortion) ocorre quando a ampliação no centro da lente é maior do que nas extremidades. Lentes olho de peixe (fisheye) produzem este tipo de distorção em resultado de uma cena hemisférica a ser projetada sobre uma superfície plana. O inverso da distorção em barril é conhecido como pincushion distortion ( distorção almofada de alfinetes) ou inverse barrel distortion. Para ilustrar estes 2 tipos de distorção vamos utilizar uma imagem com gradeado. Ao lado esquerdo tem-se a imagem original seguida dos efeitos barrel e pincushion respectivamente. A motivação deste post foi não encontrar nenhum algoritmo interessante para C# (CSharp) realizando estas duas distorções, desta forma após realizar algumas leituras pela internet, e achar muitas formulas que não funcionavam ou estavam incompletas, resolvi criar meu próprio algoritmo. Neste post não entrarei em detalhes do algoritmo, mas somente na forma de utilização final dele, porém o código dele está completo e funcional abaixo. A chamada principal da função é a: [sourcecode language=&quot;csharp&quot;] BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor); [/sourcecode] Onde: sourceImage é a imagem que será distorcida; factor é o fator de distorção, este campo aceita valores de -1 até 1; autoCrop define se será realizado o corte automático da imagem; backgroundColor é utilizaso, caso não haja o corte automático da imagem, para preenchimento do fundo. Exemplo 1: Neste exemplo será utilizado um fator 0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção pincushion. Exemplo 2: Neste exemplo será utilizado um fator -0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção de barril. Por estes 2 efeitos pode-se observar que o fator negativo implica na distorção barril e o positivo na distorção pincushion. Exemplo 3: Neste exemplo será utilizado um fator 0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 4: Neste exemplo será utilizado um fator -0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo de corte: Os próximos exemplos utilizam o parâmetro de corte para não deixar áreas vazias na imagem. Em cada um deles será mostrado 2 imagens a primeira com um quadrado vermelho indicando onde será realizado o corte, e a outra, a imagem com o corte realizado. Exemplo 5: Neste exemplo será utilizado um fator 0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 6: Neste exemplo será utilizado um fator -0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 7: Neste exemplo será utilizado um fator 0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 8: Neste exemplo será utilizado um fator -0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo com fotos reais: Nestes exemplos será utilizado a foto abaixo: Fator 0.1 sem corte: Fator 0.1 com corte: Fator -0.1 sem corte: Fator -0.1 com corte: Para finalizar segue o código completo do aplicativo. Download: Código fonte Barrel.cs Código: [sourcecode language=&quot;csharp&quot;] using System; using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using System.Runtime.InteropServices; namespace HelvioJunior { class Program { static void Main(string[] args) { Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;test.jpg&quot;); bmp = BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;new_test.jpg&quot;); bmp.Dispose(); Console.WriteLine(&quot;Pressione ENTER para finalizar&quot;); Console.ReadLine(); } static public Bitmap BarrelDistortion(Bitmap StartImage, double factor) { return BarrelDistortion(StartImage, factor, true, Color.Transparent); } static public Bitmap BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor) { Bitmap StartImage = null; BitmapData srcBitmapData = null; Byte[] srcPixels = null; Byte[] dstPixels = null; Bitmap NewImage = null; BitmapData dstBitmapData = null; try { // Verifica se bpp (Bits Per Pixel) é 8, 24, ou 32 int Depth = System.Drawing.Bitmap.GetPixelFormatSize(sourceImage.PixelFormat); if (Depth != 8 &amp;&amp; Depth != 24 &amp;&amp; Depth != 32) { throw new ArgumentException(&quot;Only 8, 24 and 32 bpp images are supported.&quot;); } // Recupera a contagem dos componentes de cor int cCount = Depth / 8; Size baseSize = new Size(sourceImage.Width, sourceImage.Height); //verifica se é uma imagem de baixa e precisa redimencionar para melhorar a qualidade //e não gerar serrilhamento da imagem Int32 maxSize = Math.Max(sourceImage.Width, sourceImage.Height); if (maxSize &lt; 3000) { float percent = 3000F / (float)maxSize; baseSize = new Size((Int32)((float)sourceImage.Width * percent), (Int32)((float)sourceImage.Height * percent)); } StartImage = new Bitmap(baseSize.Width, baseSize.Height, sourceImage.PixelFormat); StartImage.SetResolution(sourceImage.HorizontalResolution, sourceImage.VerticalResolution); //Cria o objeto de desenho e fundo branco Graphics g = Graphics.FromImage(StartImage); g.SmoothingMode = SmoothingMode.AntiAlias; g.InterpolationMode = InterpolationMode.HighQualityBicubic; g.PixelOffsetMode = PixelOffsetMode.HighQuality; g.DrawImage(sourceImage, new Rectangle(-1, -1, baseSize.Width + 1, baseSize.Height + 1), 0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel); g.Dispose(); // Bloqueia a imagem de origem e copia para o array de bytes e libera a imagem de origem srcBitmapData = StartImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.ReadOnly, StartImage.PixelFormat); srcPixels = new byte[StartImage.Width * StartImage.Height * (Depth / 8)]; Marshal.Copy(srcBitmapData.Scan0, srcPixels, 0, srcPixels.Length); StartImage.UnlockBits(srcBitmapData); srcBitmapData = null; //Cria o array de bytes da imagem de destino dstPixels = new Byte[srcPixels.Length]; //Preenche todo o quadro com a cor de fundo selecionada Int32 index = ((1 * StartImage.Width) + 1) * cCount; //index = ((Y * Width) + X) * cCount do { if (Depth == 32) // Para 32 bpp define Red, Green, Blue e Alpha { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; dstPixels[index++] = backgroundColor.A; // a } if (Depth == 24) // Para 24 bpp define Red, Green e Blue { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; } if (Depth == 8) // Para 8 bpp define o valor da cor (Red, Green and Blue como sendo a mesma coisa) { dstPixels[index++] = backgroundColor.B; } } while (index &lt; srcPixels.Length); //Calcula a amplitude máxima possível para a imagem e multiplica pelo fator desejados double amp = 0; double ang = Math.PI * 0.5; for (Int32 a = 0; a &lt; StartImage.Height; a++) { int y = (int)((StartImage.Height / 2) - amp * Math.Sin(ang)); if ((y &lt; 0) || (y &gt; StartImage.Height)) break; amp = a; } amp = (amp - 2) * (factor &lt; -1 ? -1 : (factor &gt; 1 ? 1 : factor)); //Define variáveis que calcula os pontos de corte (se houver) Int32 x1, y1, x2, y2; x1 = StartImage.Width; y1 = StartImage.Height; x2 = 0; y2 = 0; //Copia pixel a pixel para as novas posições index = ((1 * StartImage.Width) + 1) * cCount; do { Int32 y = (Int32)((index / cCount) / StartImage.Width); Int32 x = (index / cCount) - (y * StartImage.Width); Point pt = NewPoint(new Point(x, y), StartImage.Width, StartImage.Height, amp, factor &lt; 0); //Valores para crop if (factor &gt;= 0) { if (x == StartImage.Width / 2) { if (pt.Y &lt; y1) y1 = pt.Y; if (pt.Y &gt; y2) y2 = pt.Y; } if (y == StartImage.Height / 2) { if (pt.X &lt; x1) x1 = pt.X; if (pt.X &gt; x2) x2 = pt.X; } } else { if ((x == 1) &amp;&amp; (y == 1)) { y1 = pt.Y; x1 = pt.X; } if ((x == StartImage.Width - 1) &amp;&amp; (y == StartImage.Height - 1)) { y2 = pt.Y; x2 = pt.X; } } //Indice de bytes onde será aplicada o pixel Int32 dstIndex = ((pt.Y * StartImage.Width) + pt.X) * cCount; if (Depth == 32) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; dstPixels[dstIndex + 3] = srcPixels[index++]; // a } if (Depth == 24) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; } if (Depth == 8) { dstPixels[dstIndex] = srcPixels[index++]; } } while (index &lt; srcPixels.Length); //Cria a nova imagem com base no array de bytes previamente criado NewImage = new Bitmap(StartImage.Width, StartImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); dstBitmapData = NewImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.WriteOnly, StartImage.PixelFormat); Marshal.Copy(dstPixels, 0, dstBitmapData.Scan0, dstPixels.Length); NewImage.UnlockBits(dstBitmapData); /* // Para efeito de visualização, desenha o quadrado onde será realizado o corte Graphics g2 = Graphics.FromImage(NewImage); g2.SmoothingMode = SmoothingMode.AntiAlias; g2.InterpolationMode = InterpolationMode.HighQualityBicubic; g2.PixelOffsetMode = PixelOffsetMode.HighQuality; g2.DrawRectangle(new Pen(new SolidBrush(Color.Red), 3), new Rectangle(x1, y1, x2 - x1, y2 - y1)); g2.Dispose();*/ //Gera a imagem final, com crop ou coo o redimencionamento real Bitmap FinalImage = new Bitmap(sourceImage.Width, sourceImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); Graphics g1 = Graphics.FromImage(FinalImage); g1.SmoothingMode = SmoothingMode.AntiAlias; g1.InterpolationMode = InterpolationMode.HighQualityBicubic; g1.PixelOffsetMode = PixelOffsetMode.HighQuality; //Realiza o corte se estiver habilitado o corte automático e houver necessidade de corte if ((autoCrop) &amp;&amp; ((x1 &gt; 0) || (y1 &gt; 0) || (x2 &lt; NewImage.Height) || (y2 &lt; NewImage.Height))) { Rectangle cropRect = new Rectangle(x1, y1, x2 - x1, y2 - y1); g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), cropRect.X, cropRect.Y, cropRect.Width, cropRect.Height, GraphicsUnit.Pixel); } else { g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), 0, 0, NewImage.Width, NewImage.Height, GraphicsUnit.Pixel); } g1.Dispose(); g1 = null; NewImage = null; return FinalImage; } finally { srcBitmapData = null; srcPixels = null; dstPixels = null; dstBitmapData = null; } } private static Point NewPoint(Point AtualPoint, Int32 Width, Int32 Height, double Aplitude, Boolean inverse) { Point uP = AtualPoint; int pY, pX; double aY, aX; aY = aX = 0; double angX = Math.PI * 1 * (double)uP.X / (double)Width; double caX = Aplitude * ((((double)Height / 2F) - (double)uP.Y) / ((double)Height / 2F)); double angY = Math.PI * 1 * (double)uP.Y / (double)Height; double caY = Aplitude * ((((double)Width / 2F) - (double)uP.X) / ((double)Width / 2F)); if (inverse) { double iAng = Math.PI * -1 * 0.5; aX = (caX * Math.Sin(iAng)); aY = (caY * Math.Sin(iAng)); } pY = (int)(uP.Y + aX + caX * Math.Sin(angX)); pX = (int)(uP.X + aY + caY * Math.Sin(angY)); return new Point(pX, pY); } } } [/sourcecode]" /><meta property="og:description" content="Distorção em barril (barrel distortion) ocorre quando a ampliação no centro da lente é maior do que nas extremidades. Lentes olho de peixe (fisheye) produzem este tipo de distorção em resultado de uma cena hemisférica a ser projetada sobre uma superfície plana. O inverso da distorção em barril é conhecido como pincushion distortion ( distorção almofada de alfinetes) ou inverse barrel distortion. Para ilustrar estes 2 tipos de distorção vamos utilizar uma imagem com gradeado. Ao lado esquerdo tem-se a imagem original seguida dos efeitos barrel e pincushion respectivamente. A motivação deste post foi não encontrar nenhum algoritmo interessante para C# (CSharp) realizando estas duas distorções, desta forma após realizar algumas leituras pela internet, e achar muitas formulas que não funcionavam ou estavam incompletas, resolvi criar meu próprio algoritmo. Neste post não entrarei em detalhes do algoritmo, mas somente na forma de utilização final dele, porém o código dele está completo e funcional abaixo. A chamada principal da função é a: [sourcecode language=&quot;csharp&quot;] BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor); [/sourcecode] Onde: sourceImage é a imagem que será distorcida; factor é o fator de distorção, este campo aceita valores de -1 até 1; autoCrop define se será realizado o corte automático da imagem; backgroundColor é utilizaso, caso não haja o corte automático da imagem, para preenchimento do fundo. Exemplo 1: Neste exemplo será utilizado um fator 0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção pincushion. Exemplo 2: Neste exemplo será utilizado um fator -0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção de barril. Por estes 2 efeitos pode-se observar que o fator negativo implica na distorção barril e o positivo na distorção pincushion. Exemplo 3: Neste exemplo será utilizado um fator 0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 4: Neste exemplo será utilizado um fator -0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo de corte: Os próximos exemplos utilizam o parâmetro de corte para não deixar áreas vazias na imagem. Em cada um deles será mostrado 2 imagens a primeira com um quadrado vermelho indicando onde será realizado o corte, e a outra, a imagem com o corte realizado. Exemplo 5: Neste exemplo será utilizado um fator 0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 6: Neste exemplo será utilizado um fator -0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 7: Neste exemplo será utilizado um fator 0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 8: Neste exemplo será utilizado um fator -0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo com fotos reais: Nestes exemplos será utilizado a foto abaixo: Fator 0.1 sem corte: Fator 0.1 com corte: Fator -0.1 sem corte: Fator -0.1 com corte: Para finalizar segue o código completo do aplicativo. Download: Código fonte Barrel.cs Código: [sourcecode language=&quot;csharp&quot;] using System; using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using System.Runtime.InteropServices; namespace HelvioJunior { class Program { static void Main(string[] args) { Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;test.jpg&quot;); bmp = BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;new_test.jpg&quot;); bmp.Dispose(); Console.WriteLine(&quot;Pressione ENTER para finalizar&quot;); Console.ReadLine(); } static public Bitmap BarrelDistortion(Bitmap StartImage, double factor) { return BarrelDistortion(StartImage, factor, true, Color.Transparent); } static public Bitmap BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor) { Bitmap StartImage = null; BitmapData srcBitmapData = null; Byte[] srcPixels = null; Byte[] dstPixels = null; Bitmap NewImage = null; BitmapData dstBitmapData = null; try { // Verifica se bpp (Bits Per Pixel) é 8, 24, ou 32 int Depth = System.Drawing.Bitmap.GetPixelFormatSize(sourceImage.PixelFormat); if (Depth != 8 &amp;&amp; Depth != 24 &amp;&amp; Depth != 32) { throw new ArgumentException(&quot;Only 8, 24 and 32 bpp images are supported.&quot;); } // Recupera a contagem dos componentes de cor int cCount = Depth / 8; Size baseSize = new Size(sourceImage.Width, sourceImage.Height); //verifica se é uma imagem de baixa e precisa redimencionar para melhorar a qualidade //e não gerar serrilhamento da imagem Int32 maxSize = Math.Max(sourceImage.Width, sourceImage.Height); if (maxSize &lt; 3000) { float percent = 3000F / (float)maxSize; baseSize = new Size((Int32)((float)sourceImage.Width * percent), (Int32)((float)sourceImage.Height * percent)); } StartImage = new Bitmap(baseSize.Width, baseSize.Height, sourceImage.PixelFormat); StartImage.SetResolution(sourceImage.HorizontalResolution, sourceImage.VerticalResolution); //Cria o objeto de desenho e fundo branco Graphics g = Graphics.FromImage(StartImage); g.SmoothingMode = SmoothingMode.AntiAlias; g.InterpolationMode = InterpolationMode.HighQualityBicubic; g.PixelOffsetMode = PixelOffsetMode.HighQuality; g.DrawImage(sourceImage, new Rectangle(-1, -1, baseSize.Width + 1, baseSize.Height + 1), 0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel); g.Dispose(); // Bloqueia a imagem de origem e copia para o array de bytes e libera a imagem de origem srcBitmapData = StartImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.ReadOnly, StartImage.PixelFormat); srcPixels = new byte[StartImage.Width * StartImage.Height * (Depth / 8)]; Marshal.Copy(srcBitmapData.Scan0, srcPixels, 0, srcPixels.Length); StartImage.UnlockBits(srcBitmapData); srcBitmapData = null; //Cria o array de bytes da imagem de destino dstPixels = new Byte[srcPixels.Length]; //Preenche todo o quadro com a cor de fundo selecionada Int32 index = ((1 * StartImage.Width) + 1) * cCount; //index = ((Y * Width) + X) * cCount do { if (Depth == 32) // Para 32 bpp define Red, Green, Blue e Alpha { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; dstPixels[index++] = backgroundColor.A; // a } if (Depth == 24) // Para 24 bpp define Red, Green e Blue { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; } if (Depth == 8) // Para 8 bpp define o valor da cor (Red, Green and Blue como sendo a mesma coisa) { dstPixels[index++] = backgroundColor.B; } } while (index &lt; srcPixels.Length); //Calcula a amplitude máxima possível para a imagem e multiplica pelo fator desejados double amp = 0; double ang = Math.PI * 0.5; for (Int32 a = 0; a &lt; StartImage.Height; a++) { int y = (int)((StartImage.Height / 2) - amp * Math.Sin(ang)); if ((y &lt; 0) || (y &gt; StartImage.Height)) break; amp = a; } amp = (amp - 2) * (factor &lt; -1 ? -1 : (factor &gt; 1 ? 1 : factor)); //Define variáveis que calcula os pontos de corte (se houver) Int32 x1, y1, x2, y2; x1 = StartImage.Width; y1 = StartImage.Height; x2 = 0; y2 = 0; //Copia pixel a pixel para as novas posições index = ((1 * StartImage.Width) + 1) * cCount; do { Int32 y = (Int32)((index / cCount) / StartImage.Width); Int32 x = (index / cCount) - (y * StartImage.Width); Point pt = NewPoint(new Point(x, y), StartImage.Width, StartImage.Height, amp, factor &lt; 0); //Valores para crop if (factor &gt;= 0) { if (x == StartImage.Width / 2) { if (pt.Y &lt; y1) y1 = pt.Y; if (pt.Y &gt; y2) y2 = pt.Y; } if (y == StartImage.Height / 2) { if (pt.X &lt; x1) x1 = pt.X; if (pt.X &gt; x2) x2 = pt.X; } } else { if ((x == 1) &amp;&amp; (y == 1)) { y1 = pt.Y; x1 = pt.X; } if ((x == StartImage.Width - 1) &amp;&amp; (y == StartImage.Height - 1)) { y2 = pt.Y; x2 = pt.X; } } //Indice de bytes onde será aplicada o pixel Int32 dstIndex = ((pt.Y * StartImage.Width) + pt.X) * cCount; if (Depth == 32) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; dstPixels[dstIndex + 3] = srcPixels[index++]; // a } if (Depth == 24) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; } if (Depth == 8) { dstPixels[dstIndex] = srcPixels[index++]; } } while (index &lt; srcPixels.Length); //Cria a nova imagem com base no array de bytes previamente criado NewImage = new Bitmap(StartImage.Width, StartImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); dstBitmapData = NewImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.WriteOnly, StartImage.PixelFormat); Marshal.Copy(dstPixels, 0, dstBitmapData.Scan0, dstPixels.Length); NewImage.UnlockBits(dstBitmapData); /* // Para efeito de visualização, desenha o quadrado onde será realizado o corte Graphics g2 = Graphics.FromImage(NewImage); g2.SmoothingMode = SmoothingMode.AntiAlias; g2.InterpolationMode = InterpolationMode.HighQualityBicubic; g2.PixelOffsetMode = PixelOffsetMode.HighQuality; g2.DrawRectangle(new Pen(new SolidBrush(Color.Red), 3), new Rectangle(x1, y1, x2 - x1, y2 - y1)); g2.Dispose();*/ //Gera a imagem final, com crop ou coo o redimencionamento real Bitmap FinalImage = new Bitmap(sourceImage.Width, sourceImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); Graphics g1 = Graphics.FromImage(FinalImage); g1.SmoothingMode = SmoothingMode.AntiAlias; g1.InterpolationMode = InterpolationMode.HighQualityBicubic; g1.PixelOffsetMode = PixelOffsetMode.HighQuality; //Realiza o corte se estiver habilitado o corte automático e houver necessidade de corte if ((autoCrop) &amp;&amp; ((x1 &gt; 0) || (y1 &gt; 0) || (x2 &lt; NewImage.Height) || (y2 &lt; NewImage.Height))) { Rectangle cropRect = new Rectangle(x1, y1, x2 - x1, y2 - y1); g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), cropRect.X, cropRect.Y, cropRect.Width, cropRect.Height, GraphicsUnit.Pixel); } else { g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), 0, 0, NewImage.Width, NewImage.Height, GraphicsUnit.Pixel); } g1.Dispose(); g1 = null; NewImage = null; return FinalImage; } finally { srcBitmapData = null; srcPixels = null; dstPixels = null; dstBitmapData = null; } } private static Point NewPoint(Point AtualPoint, Int32 Width, Int32 Height, double Aplitude, Boolean inverse) { Point uP = AtualPoint; int pY, pX; double aY, aX; aY = aX = 0; double angX = Math.PI * 1 * (double)uP.X / (double)Width; double caX = Aplitude * ((((double)Height / 2F) - (double)uP.Y) / ((double)Height / 2F)); double angY = Math.PI * 1 * (double)uP.Y / (double)Height; double caY = Aplitude * ((((double)Width / 2F) - (double)uP.X) / ((double)Width / 2F)); if (inverse) { double iAng = Math.PI * -1 * 0.5; aX = (caX * Math.Sin(iAng)); aY = (caY * Math.Sin(iAng)); } pY = (int)(uP.Y + aX + caX * Math.Sin(angX)); pX = (int)(uP.X + aY + caY * Math.Sin(angY)); return new Point(pX, pY); } } } [/sourcecode]" /><link rel="canonical" href="https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" /><meta property="og:url" content="https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" /><meta property="og:site_name" content="Helvio Junior" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2013-02-15T21:21:52-02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Barrel and pincushion distortion" /><meta name="twitter:site" content="@helvioju" /><meta name="twitter:creator" content="@Helvio Junior (m4v3r1ck)" /><meta name="google-site-verification" content="JR4IIP9jfvOwxn2ybV_Qn0SrtDPlTrKomdPWgBuP55k"" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Helvio Junior (m4v3r1ck)"},"dateModified":"2023-08-17T00:19:29-03:00","datePublished":"2013-02-15T21:21:52-02:00","description":"Distorção em barril (barrel distortion) ocorre quando a ampliação no centro da lente é maior do que nas extremidades. Lentes olho de peixe (fisheye) produzem este tipo de distorção em resultado de uma cena hemisférica a ser projetada sobre uma superfície plana. O inverso da distorção em barril é conhecido como pincushion distortion ( distorção almofada de alfinetes) ou inverse barrel distortion. Para ilustrar estes 2 tipos de distorção vamos utilizar uma imagem com gradeado. Ao lado esquerdo tem-se a imagem original seguida dos efeitos barrel e pincushion respectivamente. A motivação deste post foi não encontrar nenhum algoritmo interessante para C# (CSharp) realizando estas duas distorções, desta forma após realizar algumas leituras pela internet, e achar muitas formulas que não funcionavam ou estavam incompletas, resolvi criar meu próprio algoritmo. Neste post não entrarei em detalhes do algoritmo, mas somente na forma de utilização final dele, porém o código dele está completo e funcional abaixo. A chamada principal da função é a: [sourcecode language=&quot;csharp&quot;] BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor); [/sourcecode] Onde: sourceImage é a imagem que será distorcida; factor é o fator de distorção, este campo aceita valores de -1 até 1; autoCrop define se será realizado o corte automático da imagem; backgroundColor é utilizaso, caso não haja o corte automático da imagem, para preenchimento do fundo. Exemplo 1: Neste exemplo será utilizado um fator 0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção pincushion. Exemplo 2: Neste exemplo será utilizado um fator -0.1 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Pode-se observar que o resultado foi uma leve distorção de barril. Por estes 2 efeitos pode-se observar que o fator negativo implica na distorção barril e o positivo na distorção pincushion. Exemplo 3: Neste exemplo será utilizado um fator 0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 4: Neste exemplo será utilizado um fator -0.5 sem corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, false, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo de corte: Os próximos exemplos utilizam o parâmetro de corte para não deixar áreas vazias na imagem. Em cada um deles será mostrado 2 imagens a primeira com um quadrado vermelho indicando onde será realizado o corte, e a outra, a imagem com o corte realizado. Exemplo 5: Neste exemplo será utilizado um fator 0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 6: Neste exemplo será utilizado um fator -0.1 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.1, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 7: Neste exemplo será utilizado um fator 0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, 0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo 8: Neste exemplo será utilizado um fator -0.5 com corte da imagem. [sourcecode language=&quot;csharp&quot;] Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;); bmp = ImageEfects.BarrelDistortion(bmp, -0.5, true, Color.White); bmp.Save(&quot;images_distorcida.jpg&quot;); bmp.Dispose(); [/sourcecode] Exemplo com fotos reais: Nestes exemplos será utilizado a foto abaixo: Fator 0.1 sem corte: Fator 0.1 com corte: Fator -0.1 sem corte: Fator -0.1 com corte: Para finalizar segue o código completo do aplicativo. Download: Código fonte Barrel.cs Código: [sourcecode language=&quot;csharp&quot;] using System; using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using System.Runtime.InteropServices; namespace HelvioJunior { class Program { static void Main(string[] args) { Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;test.jpg&quot;); bmp = BarrelDistortion(bmp, 0.1, false, Color.White); bmp.Save(&quot;new_test.jpg&quot;); bmp.Dispose(); Console.WriteLine(&quot;Pressione ENTER para finalizar&quot;); Console.ReadLine(); } static public Bitmap BarrelDistortion(Bitmap StartImage, double factor) { return BarrelDistortion(StartImage, factor, true, Color.Transparent); } static public Bitmap BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor) { Bitmap StartImage = null; BitmapData srcBitmapData = null; Byte[] srcPixels = null; Byte[] dstPixels = null; Bitmap NewImage = null; BitmapData dstBitmapData = null; try { // Verifica se bpp (Bits Per Pixel) é 8, 24, ou 32 int Depth = System.Drawing.Bitmap.GetPixelFormatSize(sourceImage.PixelFormat); if (Depth != 8 &amp;&amp; Depth != 24 &amp;&amp; Depth != 32) { throw new ArgumentException(&quot;Only 8, 24 and 32 bpp images are supported.&quot;); } // Recupera a contagem dos componentes de cor int cCount = Depth / 8; Size baseSize = new Size(sourceImage.Width, sourceImage.Height); //verifica se é uma imagem de baixa e precisa redimencionar para melhorar a qualidade //e não gerar serrilhamento da imagem Int32 maxSize = Math.Max(sourceImage.Width, sourceImage.Height); if (maxSize &lt; 3000) { float percent = 3000F / (float)maxSize; baseSize = new Size((Int32)((float)sourceImage.Width * percent), (Int32)((float)sourceImage.Height * percent)); } StartImage = new Bitmap(baseSize.Width, baseSize.Height, sourceImage.PixelFormat); StartImage.SetResolution(sourceImage.HorizontalResolution, sourceImage.VerticalResolution); //Cria o objeto de desenho e fundo branco Graphics g = Graphics.FromImage(StartImage); g.SmoothingMode = SmoothingMode.AntiAlias; g.InterpolationMode = InterpolationMode.HighQualityBicubic; g.PixelOffsetMode = PixelOffsetMode.HighQuality; g.DrawImage(sourceImage, new Rectangle(-1, -1, baseSize.Width + 1, baseSize.Height + 1), 0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel); g.Dispose(); // Bloqueia a imagem de origem e copia para o array de bytes e libera a imagem de origem srcBitmapData = StartImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.ReadOnly, StartImage.PixelFormat); srcPixels = new byte[StartImage.Width * StartImage.Height * (Depth / 8)]; Marshal.Copy(srcBitmapData.Scan0, srcPixels, 0, srcPixels.Length); StartImage.UnlockBits(srcBitmapData); srcBitmapData = null; //Cria o array de bytes da imagem de destino dstPixels = new Byte[srcPixels.Length]; //Preenche todo o quadro com a cor de fundo selecionada Int32 index = ((1 * StartImage.Width) + 1) * cCount; //index = ((Y * Width) + X) * cCount do { if (Depth == 32) // Para 32 bpp define Red, Green, Blue e Alpha { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; dstPixels[index++] = backgroundColor.A; // a } if (Depth == 24) // Para 24 bpp define Red, Green e Blue { dstPixels[index++] = backgroundColor.B; dstPixels[index++] = backgroundColor.G; dstPixels[index++] = backgroundColor.R; } if (Depth == 8) // Para 8 bpp define o valor da cor (Red, Green and Blue como sendo a mesma coisa) { dstPixels[index++] = backgroundColor.B; } } while (index &lt; srcPixels.Length); //Calcula a amplitude máxima possível para a imagem e multiplica pelo fator desejados double amp = 0; double ang = Math.PI * 0.5; for (Int32 a = 0; a &lt; StartImage.Height; a++) { int y = (int)((StartImage.Height / 2) - amp * Math.Sin(ang)); if ((y &lt; 0) || (y &gt; StartImage.Height)) break; amp = a; } amp = (amp - 2) * (factor &lt; -1 ? -1 : (factor &gt; 1 ? 1 : factor)); //Define variáveis que calcula os pontos de corte (se houver) Int32 x1, y1, x2, y2; x1 = StartImage.Width; y1 = StartImage.Height; x2 = 0; y2 = 0; //Copia pixel a pixel para as novas posições index = ((1 * StartImage.Width) + 1) * cCount; do { Int32 y = (Int32)((index / cCount) / StartImage.Width); Int32 x = (index / cCount) - (y * StartImage.Width); Point pt = NewPoint(new Point(x, y), StartImage.Width, StartImage.Height, amp, factor &lt; 0); //Valores para crop if (factor &gt;= 0) { if (x == StartImage.Width / 2) { if (pt.Y &lt; y1) y1 = pt.Y; if (pt.Y &gt; y2) y2 = pt.Y; } if (y == StartImage.Height / 2) { if (pt.X &lt; x1) x1 = pt.X; if (pt.X &gt; x2) x2 = pt.X; } } else { if ((x == 1) &amp;&amp; (y == 1)) { y1 = pt.Y; x1 = pt.X; } if ((x == StartImage.Width - 1) &amp;&amp; (y == StartImage.Height - 1)) { y2 = pt.Y; x2 = pt.X; } } //Indice de bytes onde será aplicada o pixel Int32 dstIndex = ((pt.Y * StartImage.Width) + pt.X) * cCount; if (Depth == 32) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; dstPixels[dstIndex + 3] = srcPixels[index++]; // a } if (Depth == 24) { dstPixels[dstIndex] = srcPixels[index++]; dstPixels[dstIndex + 1] = srcPixels[index++]; dstPixels[dstIndex + 2] = srcPixels[index++]; } if (Depth == 8) { dstPixels[dstIndex] = srcPixels[index++]; } } while (index &lt; srcPixels.Length); //Cria a nova imagem com base no array de bytes previamente criado NewImage = new Bitmap(StartImage.Width, StartImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); dstBitmapData = NewImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.WriteOnly, StartImage.PixelFormat); Marshal.Copy(dstPixels, 0, dstBitmapData.Scan0, dstPixels.Length); NewImage.UnlockBits(dstBitmapData); /* // Para efeito de visualização, desenha o quadrado onde será realizado o corte Graphics g2 = Graphics.FromImage(NewImage); g2.SmoothingMode = SmoothingMode.AntiAlias; g2.InterpolationMode = InterpolationMode.HighQualityBicubic; g2.PixelOffsetMode = PixelOffsetMode.HighQuality; g2.DrawRectangle(new Pen(new SolidBrush(Color.Red), 3), new Rectangle(x1, y1, x2 - x1, y2 - y1)); g2.Dispose();*/ //Gera a imagem final, com crop ou coo o redimencionamento real Bitmap FinalImage = new Bitmap(sourceImage.Width, sourceImage.Height, StartImage.PixelFormat); NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution); Graphics g1 = Graphics.FromImage(FinalImage); g1.SmoothingMode = SmoothingMode.AntiAlias; g1.InterpolationMode = InterpolationMode.HighQualityBicubic; g1.PixelOffsetMode = PixelOffsetMode.HighQuality; //Realiza o corte se estiver habilitado o corte automático e houver necessidade de corte if ((autoCrop) &amp;&amp; ((x1 &gt; 0) || (y1 &gt; 0) || (x2 &lt; NewImage.Height) || (y2 &lt; NewImage.Height))) { Rectangle cropRect = new Rectangle(x1, y1, x2 - x1, y2 - y1); g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), cropRect.X, cropRect.Y, cropRect.Width, cropRect.Height, GraphicsUnit.Pixel); } else { g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), 0, 0, NewImage.Width, NewImage.Height, GraphicsUnit.Pixel); } g1.Dispose(); g1 = null; NewImage = null; return FinalImage; } finally { srcBitmapData = null; srcPixels = null; dstPixels = null; dstBitmapData = null; } } private static Point NewPoint(Point AtualPoint, Int32 Width, Int32 Height, double Aplitude, Boolean inverse) { Point uP = AtualPoint; int pY, pX; double aY, aX; aY = aX = 0; double angX = Math.PI * 1 * (double)uP.X / (double)Width; double caX = Aplitude * ((((double)Height / 2F) - (double)uP.Y) / ((double)Height / 2F)); double angY = Math.PI * 1 * (double)uP.Y / (double)Height; double caY = Aplitude * ((((double)Width / 2F) - (double)uP.X) / ((double)Width / 2F)); if (inverse) { double iAng = Math.PI * -1 * 0.5; aX = (caX * Math.Sin(iAng)); aY = (caY * Math.Sin(iAng)); } pY = (int)(uP.Y + aX + caX * Math.Sin(angX)); pX = (int)(uP.X + aY + caY * Math.Sin(angY)); return new Point(pX, pY); } } } [/sourcecode]","headline":"Barrel and pincushion distortion","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/"},"url":"https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/"}</script><title>Barrel and pincushion distortion | Helvio Junior</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Helvio Junior"><meta name="application-name" content="Helvio Junior"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/m4v3r1ck.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Helvio Junior</a></div><div class="site-subtitle font-italic">Cyber security researcher, speaker, low level and binary exploitation entusiast. <br /><br />"I’m just a child who has never grown up. I still keep asking these 'how' & 'why' questions. Occasionally, I find an answer. Stephen Hawking"</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://www.linkedin.com/in/helviojunior" aria-label="linkedin" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.youtube.com/@Sec4US" aria-label="youtube" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-youtube"></i> </a> <a href="https://github.com/helviojunior" aria-label="github" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['helvio.junior','sec4us.com.br'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/fotografia"> Fotografia </a> </span> <span>Barrel and pincushion distortion</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Barrel and pincushion distortion</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Helvio Junior (m4v3r1ck) </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 15, 2013, 9:21 PM -0200" prep="on" > Feb 15, 2013 <i class="unloaded">2013-02-15T21:21:52-02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 17, 2023, 12:19 AM -0300" prefix="Updated " > Aug 17, 2023 <i class="unloaded">2023-08-17T00:19:29-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1649 words">9 min</span></div></div><div class="post-content"><p>Distorção em barril (barrel distortion) ocorre quando a ampliação no centro da lente é maior do que nas extremidades. Lentes olho de peixe (fisheye) produzem este tipo de distorção em resultado de uma cena hemisférica a ser projetada sobre uma superfície plana.</p><p>O inverso da distorção em barril é conhecido como pincushion distortion ( distorção almofada de alfinetes) ou inverse barrel distortion.</p><p>Para ilustrar estes 2 tipos de distorção vamos utilizar uma imagem com gradeado. Ao lado esquerdo tem-se a imagem original seguida dos efeitos barrel e pincushion respectivamente.</p><p><a href="/assets/2013/02/001.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 128'%3E%3C/svg%3E" title="001" data-src="/assets/2013/02/001-300x214.png" alt="" width="180" height="128" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/002-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 128'%3E%3C/svg%3E" title="002 (0.1)" data-src="/assets/2013/02/002-0.1-300x214.png" alt="" width="180" height="128" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/003-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 128'%3E%3C/svg%3E" title="003 (-0.1)" data-src="/assets/2013/02/003-0.1-300x214.png" alt="" width="180" height="128" class="lazyload" data-proofer-ignore></a></p><p>A motivação deste post foi não encontrar nenhum algoritmo interessante para C# (CSharp) realizando estas duas distorções, desta forma após realizar algumas leituras pela internet, e achar muitas formulas que não funcionavam ou estavam incompletas, resolvi criar meu próprio algoritmo. Neste post não entrarei em detalhes do algoritmo, mas somente na forma de utilização final dele, porém o código dele está completo e funcional abaixo.</p><p></p><p>A chamada principal da função é a:</p><p>[sourcecode language="csharp"]<br /> BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor);<br /> [/sourcecode]</p><p><strong>Onde:</strong><br /> sourceImage é a imagem que será distorcida;<br /> factor é o fator de distorção, este campo aceita valores de -1 até 1;<br /> autoCrop define se será realizado o corte automático da imagem;<br /> backgroundColor é utilizaso, caso não haja o corte automático da imagem, para preenchimento do fundo.</p><p><strong>Exemplo 1:</strong><br /> Neste exemplo será utilizado um fator 0.1 sem corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, 0.1, false, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/002-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="002 (0.1)" data-src="/assets/2013/02/002-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p>Pode-se observar que o resultado foi uma leve distorção pincushion.</p><p><strong>Exemplo 2:</strong><br /> Neste exemplo será utilizado um fator -0.1 sem corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, -0.1, false, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/003-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="003 (-0.1)" data-src="/assets/2013/02/003-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p>Pode-se observar que o resultado foi uma leve distorção de barril.</p><p>Por estes 2 efeitos pode-se observar que o fator negativo implica na distorção barril e o positivo na distorção pincushion.</p><p><strong>Exemplo 3:</strong><br /> Neste exemplo será utilizado um fator 0.5 sem corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, 0.5, false, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/004-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="004 (0.5)" data-src="/assets/2013/02/004-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo 4:</strong><br /> Neste exemplo será utilizado um fator -0.5 sem corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, -0.5, false, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/005-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="005 (-0.5)" data-src="/assets/2013/02/005-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo de corte:</strong><br /> Os próximos exemplos utilizam o parâmetro de corte para não deixar áreas vazias na imagem. Em cada um deles será mostrado 2 imagens a primeira com um quadrado vermelho indicando onde será realizado o corte, e a outra, a imagem com o corte realizado.</p><p><strong>Exemplo 5:</strong><br /> Neste exemplo será utilizado um fator 0.1 com corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, 0.1, true, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/006-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="006 (0.1)" data-src="/assets/2013/02/006-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/010-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="010 (0.1)" data-src="/assets/2013/02/010-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo 6:</strong><br /> Neste exemplo será utilizado um fator -0.1 com corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, -0.1, true, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/007-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="007 (-0.1)" data-src="/assets/2013/02/007-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/011-0.1.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="011 (-0.1)" data-src="/assets/2013/02/011-0.1-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo 7:</strong><br /> Neste exemplo será utilizado um fator 0.5 com corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, 0.5, true, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/008-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="008 (0.5)" data-src="/assets/2013/02/008-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/012-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="012 (0.5)" data-src="/assets/2013/02/012-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo 8:</strong><br /> Neste exemplo será utilizado um fator -0.5 com corte da imagem.</p><p>[sourcecode language="csharp"]<br /> Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;nome_do_arquivo.jpg&quot;);<br /> bmp = ImageEfects.BarrelDistortion(bmp, -0.5, true, Color.White);<br /> bmp.Save(&quot;images_distorcida.jpg&quot;);<br /> bmp.Dispose();<br /> [/sourcecode]</p><p><a href="/assets/2013/02/009-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="009 (-0.5)" data-src="/assets/2013/02/009-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a><a href="/assets/2013/02/013-0.5.png" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 214'%3E%3C/svg%3E" title="013 (-0.5)" data-src="/assets/2013/02/013-0.5-300x214.png" alt="" width="300" height="214" class="lazyload" data-proofer-ignore></a></p><p><strong>Exemplo com fotos reais:</strong><br /> Nestes exemplos será utilizado a foto abaixo:</p><p><a href="/assets/2013/02/foto1.jpg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 199'%3E%3C/svg%3E" title="foto1" data-src="/assets/2013/02/foto1-300x199.jpg" alt="" width="300" height="199" class="lazyload" data-proofer-ignore></a></p><p><strong>Fator 0.1 sem corte:</strong></p><p><a href="/assets/2013/02/014-0.1.jpg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 199'%3E%3C/svg%3E" title="014 (0.1)" data-src="/assets/2013/02/014-0.1-300x199.jpg" alt="" width="300" height="199" class="lazyload" data-proofer-ignore></a></p><p>Fator 0.1 com corte:</p><p><a href="/assets/2013/02/015-0.1.jpg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 199'%3E%3C/svg%3E" title="015 (0.1)" data-src="/assets/2013/02/015-0.1-300x199.jpg" alt="" width="300" height="199" class="lazyload" data-proofer-ignore></a></p><p><strong>Fator -0.1 sem corte:</strong></p><p><a href="/assets/2013/02/016-0.1.jpg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 199'%3E%3C/svg%3E" title="016 (0.1)" data-src="/assets/2013/02/016-0.1-300x199.jpg" alt="" width="300" height="199" class="lazyload" data-proofer-ignore></a></p><p><strong>Fator -0.1 com corte:</strong></p><p><a href="/assets/2013/02/017-0.1.jpg" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 199'%3E%3C/svg%3E" title="017 (0.1)" data-src="/assets/2013/02/017-0.1-300x199.jpg" alt="" width="300" height="199" class="lazyload" data-proofer-ignore></a></p><p>Para finalizar segue o código completo do aplicativo.</p><p>Download: <a href="/assets/2013/02/Barrel.zip">Código fonte Barrel.cs</a></p><p>Código:</p><p>[sourcecode language="csharp"]<br /> using System;<br /> using System.Drawing;<br /> using System.Drawing.Imaging;<br /> using System.Drawing.Drawing2D;<br /> using System.Runtime.InteropServices;</p><p>namespace HelvioJunior<br /> {<br /> class Program<br /> {<br /> static void Main(string[] args)<br /> {</p><p>Bitmap bmp = (Bitmap)Bitmap.FromFile(&quot;test.jpg&quot;);<br /> bmp = BarrelDistortion(bmp, 0.1, false, Color.White);<br /> bmp.Save(&quot;new_test.jpg&quot;);<br /> bmp.Dispose();</p><p>Console.WriteLine(&quot;Pressione ENTER para finalizar&quot;);<br /> Console.ReadLine();<br /> }</p><p>static public Bitmap BarrelDistortion(Bitmap StartImage, double factor)<br /> {<br /> return BarrelDistortion(StartImage, factor, true, Color.Transparent);<br /> }</p><p>static public Bitmap BarrelDistortion(Bitmap sourceImage, double factor, Boolean autoCrop, Color backgroundColor)<br /> {<br /> Bitmap StartImage = null;<br /> BitmapData srcBitmapData = null;<br /> Byte[] srcPixels = null;<br /> Byte[] dstPixels = null;<br /> Bitmap NewImage = null;<br /> BitmapData dstBitmapData = null;</p><p>try<br /> {</p><p>// Verifica se bpp (Bits Per Pixel) é 8, 24, ou 32<br /> int Depth = System.Drawing.Bitmap.GetPixelFormatSize(sourceImage.PixelFormat);<br /> if (Depth != 8 &amp;&amp; Depth != 24 &amp;&amp; Depth != 32)<br /> {<br /> throw new ArgumentException(&quot;Only 8, 24 and 32 bpp images are supported.&quot;);<br /> }</p><p>// Recupera a contagem dos componentes de cor<br /> int cCount = Depth / 8;</p><p>Size baseSize = new Size(sourceImage.Width, sourceImage.Height);</p><p>//verifica se é uma imagem de baixa e precisa redimencionar para melhorar a qualidade<br /> //e não gerar serrilhamento da imagem<br /> Int32 maxSize = Math.Max(sourceImage.Width, sourceImage.Height);<br /> if (maxSize &lt; 3000)<br /> {<br /> float percent = 3000F / (float)maxSize;<br /> baseSize = new Size((Int32)((float)sourceImage.Width * percent), (Int32)((float)sourceImage.Height * percent));<br /> }</p><p>StartImage = new Bitmap(baseSize.Width, baseSize.Height, sourceImage.PixelFormat);<br /> StartImage.SetResolution(sourceImage.HorizontalResolution, sourceImage.VerticalResolution);</p><p>//Cria o objeto de desenho e fundo branco<br /> Graphics g = Graphics.FromImage(StartImage);<br /> g.SmoothingMode = SmoothingMode.AntiAlias;<br /> g.InterpolationMode = InterpolationMode.HighQualityBicubic;<br /> g.PixelOffsetMode = PixelOffsetMode.HighQuality;<br /> g.DrawImage(sourceImage, new Rectangle(-1, -1, baseSize.Width + 1, baseSize.Height + 1), 0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel);<br /> g.Dispose();<br /> // Bloqueia a imagem de origem e copia para o array de bytes e libera a imagem de origem<br /> srcBitmapData = StartImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.ReadOnly, StartImage.PixelFormat);<br /> srcPixels = new byte[StartImage.Width * StartImage.Height * (Depth / 8)];<br /> Marshal.Copy(srcBitmapData.Scan0, srcPixels, 0, srcPixels.Length);<br /> StartImage.UnlockBits(srcBitmapData);<br /> srcBitmapData = null;</p><p>//Cria o array de bytes da imagem de destino<br /> dstPixels = new Byte[srcPixels.Length];</p><p>//Preenche todo o quadro com a cor de fundo selecionada<br /> Int32 index = ((1 * StartImage.Width) + 1) * cCount; //index = ((Y * Width) + X) * cCount<br /> do<br /> {<br /> if (Depth == 32) // Para 32 bpp define Red, Green, Blue e Alpha<br /> {<br /> dstPixels[index++] = backgroundColor.B;<br /> dstPixels[index++] = backgroundColor.G;<br /> dstPixels[index++] = backgroundColor.R;<br /> dstPixels[index++] = backgroundColor.A; // a<br /> }<br /> if (Depth == 24) // Para 24 bpp define Red, Green e Blue<br /> {<br /> dstPixels[index++] = backgroundColor.B;<br /> dstPixels[index++] = backgroundColor.G;<br /> dstPixels[index++] = backgroundColor.R;<br /> }<br /> if (Depth == 8)<br /> // Para 8 bpp define o valor da cor (Red, Green and Blue como sendo a mesma coisa)<br /> {<br /> dstPixels[index++] = backgroundColor.B;<br /> }</p><p>} while (index &lt; srcPixels.Length);<br /> //Calcula a amplitude máxima possível para a imagem e multiplica pelo fator desejados<br /> double amp = 0;<br /> double ang = Math.PI * 0.5;<br /> for (Int32 a = 0; a &lt; StartImage.Height; a++)<br /> {<br /> int y = (int)((StartImage.Height / 2) - amp * Math.Sin(ang));<br /> if ((y &lt; 0) || (y &gt; StartImage.Height))<br /> break;<br /> amp = a;<br /> }<br /> amp = (amp - 2) * (factor &lt; -1 ? -1 : (factor &gt; 1 ? 1 : factor));<br /> //Define variáveis que calcula os pontos de corte (se houver)<br /> Int32 x1, y1, x2, y2;<br /> x1 = StartImage.Width;<br /> y1 = StartImage.Height;<br /> x2 = 0;<br /> y2 = 0;</p><p>//Copia pixel a pixel para as novas posições<br /> index = ((1 * StartImage.Width) + 1) * cCount;<br /> do<br /> {</p><p>Int32 y = (Int32)((index / cCount) / StartImage.Width);<br /> Int32 x = (index / cCount) - (y * StartImage.Width);</p><p>Point pt = NewPoint(new Point(x, y), StartImage.Width, StartImage.Height, amp, factor &lt; 0);</p><p>//Valores para crop<br /> if (factor &gt;= 0)<br /> {<br /> if (x == StartImage.Width / 2)<br /> {<br /> if (pt.Y &lt; y1)<br /> y1 = pt.Y;</p><p>if (pt.Y &gt; y2)<br /> y2 = pt.Y;<br /> }</p><p>if (y == StartImage.Height / 2)<br /> {<br /> if (pt.X &lt; x1)<br /> x1 = pt.X;</p><p>if (pt.X &gt; x2)<br /> x2 = pt.X;<br /> }<br /> }<br /> else<br /> {<br /> if ((x == 1) &amp;&amp; (y == 1))<br /> {<br /> y1 = pt.Y;<br /> x1 = pt.X;<br /> }</p><p>if ((x == StartImage.Width - 1) &amp;&amp; (y == StartImage.Height - 1))<br /> {<br /> y2 = pt.Y;<br /> x2 = pt.X;<br /> }<br /> }</p><p>//Indice de bytes onde será aplicada o pixel<br /> Int32 dstIndex = ((pt.Y * StartImage.Width) + pt.X) * cCount;</p><p>if (Depth == 32)<br /> {<br /> dstPixels[dstIndex] = srcPixels[index++];<br /> dstPixels[dstIndex + 1] = srcPixels[index++];<br /> dstPixels[dstIndex + 2] = srcPixels[index++];<br /> dstPixels[dstIndex + 3] = srcPixels[index++]; // a<br /> }<br /> if (Depth == 24)<br /> {<br /> dstPixels[dstIndex] = srcPixels[index++];<br /> dstPixels[dstIndex + 1] = srcPixels[index++];<br /> dstPixels[dstIndex + 2] = srcPixels[index++];<br /> }<br /> if (Depth == 8)<br /> {<br /> dstPixels[dstIndex] = srcPixels[index++];<br /> }</p><p>} while (index &lt; srcPixels.Length);</p><p>//Cria a nova imagem com base no array de bytes previamente criado<br /> NewImage = new Bitmap(StartImage.Width, StartImage.Height, StartImage.PixelFormat);<br /> NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution);<br /> dstBitmapData = NewImage.LockBits(new Rectangle(0, 0, StartImage.Width, StartImage.Height), ImageLockMode.WriteOnly, StartImage.PixelFormat);<br /> Marshal.Copy(dstPixels, 0, dstBitmapData.Scan0, dstPixels.Length);<br /> NewImage.UnlockBits(dstBitmapData);</p><p>/*<br /> // Para efeito de visualização, desenha o quadrado onde será realizado o corte<br /> Graphics g2 = Graphics.FromImage(NewImage);<br /> g2.SmoothingMode = SmoothingMode.AntiAlias;<br /> g2.InterpolationMode = InterpolationMode.HighQualityBicubic;<br /> g2.PixelOffsetMode = PixelOffsetMode.HighQuality;<br /> g2.DrawRectangle(new Pen(new SolidBrush(Color.Red), 3), new Rectangle(x1, y1, x2 - x1, y2 - y1));<br /> g2.Dispose();*/</p><p>//Gera a imagem final, com crop ou coo o redimencionamento real<br /> Bitmap FinalImage = new Bitmap(sourceImage.Width, sourceImage.Height, StartImage.PixelFormat);<br /> NewImage.SetResolution(StartImage.HorizontalResolution, StartImage.VerticalResolution);</p><p>Graphics g1 = Graphics.FromImage(FinalImage);<br /> g1.SmoothingMode = SmoothingMode.AntiAlias;<br /> g1.InterpolationMode = InterpolationMode.HighQualityBicubic;<br /> g1.PixelOffsetMode = PixelOffsetMode.HighQuality;</p><p>//Realiza o corte se estiver habilitado o corte automático e houver necessidade de corte<br /> if ((autoCrop) &amp;&amp; ((x1 &gt; 0) || (y1 &gt; 0) || (x2 &lt; NewImage.Height) || (y2 &lt; NewImage.Height)))<br /> {<br /> Rectangle cropRect = new Rectangle(x1, y1, x2 - x1, y2 - y1);<br /> g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), cropRect.X, cropRect.Y, cropRect.Width, cropRect.Height, GraphicsUnit.Pixel);<br /> }<br /> else<br /> {<br /> g1.DrawImage(NewImage, new Rectangle(-1, -1, FinalImage.Width + 1, FinalImage.Height + 1), 0, 0, NewImage.Width, NewImage.Height, GraphicsUnit.Pixel);<br /> }</p><p>g1.Dispose();<br /> g1 = null;</p><p>NewImage = null;<br /> return FinalImage;<br /> }<br /> finally<br /> {<br /> srcBitmapData = null;<br /> srcPixels = null;<br /> dstPixels = null;<br /> dstBitmapData = null;<br /> }</p><p>}</p><p>private static Point NewPoint(Point AtualPoint, Int32 Width, Int32 Height, double Aplitude, Boolean inverse)<br /> {<br /> Point uP = AtualPoint;</p><p>int pY, pX;<br /> double aY, aX;</p><p>aY = aX = 0;</p><p>double angX = Math.PI * 1 * (double)uP.X / (double)Width;<br /> double caX = Aplitude * ((((double)Height / 2F) - (double)uP.Y) / ((double)Height / 2F));</p><p>double angY = Math.PI * 1 * (double)uP.Y / (double)Height;<br /> double caY = Aplitude * ((((double)Width / 2F) - (double)uP.X) / ((double)Width / 2F));</p><p>if (inverse)<br /> {<br /> double iAng = Math.PI * -1 * 0.5;<br /> aX = (caX * Math.Sin(iAng));<br /> aY = (caY * Math.Sin(iAng));<br /> }</p><p>pY = (int)(uP.Y + aX + caX * Math.Sin(angX));<br /> pX = (int)(uP.X + aY + caY * Math.Sin(angY));</p><p>return new Point(pX, pY);</p><p>}</p><p>}<br /> }<br /> [/sourcecode]</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/desenvolvimento/'>Desenvolvimento</a>, <a href='/categories/fotografia/'>Fotografia</a>, <a href='/categories/it/'>IT</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Barrel and pincushion distortion - Helvio Junior&url=https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Barrel and pincushion distortion - Helvio Junior&u=https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Barrel and pincushion distortion - Helvio Junior&url=https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/security/osint/localizando-ips-que-respondem-para-uma-url/">Localizando IPs que respondem para uma URL</a><li><a href="/security/osint/locating-url-ips-bypass-waf/">Locating IPs that respond to a URL</a><li><a href="/security/edr/instalando-elasticsearch-edr/">Instalando Elasticsearch EDR</a><li><a href="/it/instalando-openvpn-com-autenticacao-em-mysql/">Instalando OpenVPN com autenticação em MySQL</a><li><a href="/it/osce-osed-e-ecxd-certificacoes-de-desenvolvimento-de-exploits/">OSCE, OSED e eCXD: Certificações de desenvolvimento de Exploits</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/it/devel/enviando-alerta-do-zabbix-via-gtalk/"><div class="card-body"> <span class="timeago small" > May 23, 2013 <i class="unloaded">2013-05-23T12:30:02-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enviando alerta do Zabbix via Gtalk</h3><div class="text-muted small"><p> Este post tem o objetivo de demonstrar como criar um script para que o Zabbix possa enviar os alertas via Gtalk. Instalação dos pre-requisitos [sourcecode language="shell"]apt-get install python p...</p></div></div></a></div><div class="card"> <a href="/it/devel/carregando-e-utilizando-plug-ins-em-c/"><div class="card-body"> <span class="timeago small" > Aug 14, 2013 <i class="unloaded">2013-08-14T13:04:25-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Carregando e utilizando plug-ins em C#</h3><div class="text-muted small"><p> Este post demonstra como criar uma aplicação em C# que possibilite a interação com plug-ins. O método demonstrado é bastante simples e poderoso. Este método realiza os seguintes passos: Lista toda...</p></div></div></a></div><div class="card"> <a href="/it/devel/criando-documentacao-em-csharp-com-doxygen/"><div class="card-body"> <span class="timeago small" > Oct 26, 2013 <i class="unloaded">2013-10-26T12:46:06-02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Criando documentação em C# com doxygen (html e pdf)</h3><div class="text-muted small"><p> Doxygen é um sistema  open-source para a geração de documentação e referência de código, o doxygen realiza a documentação de diversas linguagens como C#, C++, Java e etc. A documentação é gerada a ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/it/devel/geracao-randomica-de-senha-com-c/" class="btn btn-outline-primary" prompt="Older"><p>Geração randômica de senha com C#</p></a> <a href="/it/configurando-802-1q-vlan-tagging/" class="btn btn-outline-primary" prompt="Newer"><p>Configurando 802.1q VLAN Tagging no linux</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Barrel and pincushion distortion'; this.page.url = 'https://www.helviojunior.com.br/fotografia/barrel-and-pincushion-distortion/'; this.page.identifier = '/fotografia/barrel-and-pincushion-distortion/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/helviojunior">Helvio junior (aka M4v3r1ck)</a>. <span data-toggle="tooltip" data-placement="top" title="Some rights reserved.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/offensive-security/">Offensive Security</a> <a class="post-tag" href="/tags/pentest/">Pentest</a> <a class="post-tag" href="/tags/autoridade-certificadora/">autoridade certificadora</a> <a class="post-tag" href="/tags/ca/">ca</a> <a class="post-tag" href="/tags/certificate-authority/">certificate authority</a> <a class="post-tag" href="/tags/openssl/">openssl</a> <a class="post-tag" href="/tags/osce3/">OSCE3</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/osed/">OSED</a> <a class="post-tag" href="/tags/osee/">OSEE</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.helviojunior.com.br{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
